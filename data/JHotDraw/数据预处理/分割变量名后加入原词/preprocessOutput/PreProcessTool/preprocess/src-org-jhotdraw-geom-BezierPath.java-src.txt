BezierPath bezi path java 1 1 1 1 2006 2006 03 03 22 22 Copyright copyright c c 1996 1996 2006 2006 by by the the original original authors author of of JHotDraw jhotdraw and and all all its it contributors contributor JHotDraw jhotdraw org org All all rights right reserved reserve This software software is is the the confidential confidential and and proprietary proprietary information information of of JHotDraw jhotdraw org org Confidential confidential Information information You you shall shall not not disclose disclose such such Confidential confidential Information information and and shall shall use use it it only only in in accordance accordance with with the the terms term of of the the license license agreement agreement you you entered enter into into with with JHotDraw jhotdraw org org package org org jhotdraw jhotdraw geom geom import java awt awt import java awt awt geom geom import java util util BezierPath bezi path allows allow the the construction construction of of paths path consisting consist of of straight straight lines line quadratic quadratic curves curve and and cubic cubic curves curve p p A a BezierPath bezi path represents represent a a geometric geometric path path constructed construct by by vertices vertex Each each Node node has ha three three control control points point C0 c0 C1 c1 C2 c2 A a mask mask defines define which which control control points point are are in in use use The the path path passes pass through through C0 c0 C1 c1 controls control the the curve curve going going towards toward C0 c0 C2 c2 controls control the the curve curve going going away away from from C0 c0 author author Werner wern Randelshofer randelshof version 1 1 1 1 2006 2006 03 03 22 22 Methods moveTo move to lineTo line to and and quadTo quad to added add br 1 1 0 0 January january 20 20 2006 2006 Created create public class BezierPath bezi path extends ArrayList list BezierPath bezi path Node node implements Shape shape Constant constant for control control point point C1 c1 public final static int C1 c1 MASK m a s k 1 1 Constant constant for control control point point C2 c2 public final static int C2 c2 MASK m a s k 2 2 Convenience convenience constant constant for control control point point C1 c1 and and C2 c2 public final static int C1C2 c1 c2 MASK m a s k C1 c1 MASK m a s k | | C2 c2 MASK m a s k We we cache cache a a GeneralPath general path instance instance to to speed speed up up Shape shape operations operation private transient GeneralPath general path generalPath general path We we cache cache the the index index of of the the outermost outermost node node to to speed speed up up method indexOfOutermostNode index of outermost node private int outer out 1 1 If this value value is is set set to to true closes close the the bezier bezi path path private boolean isClosed is close Defines define a a vertex vertex node node of of the the bezier bezi path path p p A a vertex vertex consists consist of of three three control control points point C0 c0 C1 c1 and and C2 c2 ul li The the bezier bezi path path always alway passes pass through through C0 c0 li li C1 c1 is is used use to to control control the the curve curve towards toward C0 c0 li li C2 c2 is is used use to to control control the the curve curve going going away away from from C0 c0 li ul public static class Node node implements Cloneable cloneable This mask mask is is used use to to describe describe which which control control points point in in addition addition to to C0 c0 are are in in effect effect public int mask mask 0 0 Control control point point x x coordinates coordinate public double x x new double 3 3 Control control point point y y coordinates coordinate public double y y new double 3 3 This is is a a hint hint for editing editing tools tool If this is is set set to to true the the editing editing tools tool shall shall keep keep all all control control points point on on the the same same line line public boolean keepColinear keep colinear true public Node node mask mask 1 1 public Node node Node node that that setTo set to that that public void setTo set to Node node that that this mask mask that that mask mask this keepColinear keep colinear that that keepColinear keep colinear System arraycopy arraycopy that that x x 0 0 this x x 0 0 3 3 System arraycopy arraycopy that that y y 0 0 this y y 0 0 3 3 public Node node Point2D point2 d Double c0 c0 this mask mask 0 0 x x 0 0 c0 c0 x x y y 0 0 c0 c0 y y x x 1 1 c0 c0 x x y y 1 1 c0 c0 y y x x 2 2 c0 c0 x x y y 2 2 c0 c0 y y public Node node int mask mask Point2D point2 d Double c0 c0 Point2D point2 d Double c1 c1 Point2D point2 d Double c2 c2 this mask mask mask mask x x 0 0 c0 c0 x x y y 0 0 c0 c0 y y x x 1 1 c1 c1 x x y y 1 1 c1 c1 y y x x 2 2 c2 c2 x x y y 2 2 c2 c2 y y public Node node double x0 x0 double y0 y0 this mask mask 0 0 x x 0 0 x0 x0 y y 0 0 y0 y0 x x 1 1 x0 x0 y y 1 1 y0 y0 x x 2 2 x0 x0 y y 2 2 y0 y0 public Node node int mask mask double x0 x0 double y0 y0 double x1 x1 double y1 y1 double x2 x2 double y2 y2 this mask mask mask mask x x 0 0 x0 x0 y y 0 0 y0 y0 x x 1 1 x1 x1 y y 1 1 y1 y1 x x 2 2 x2 x2 y y 2 2 y2 y2 public int getMask get mask return mask mask public void setMask set mask int newValue value mask mask newValue value public void setControlPoint set control point int index index Point2D point2 d Double p p x x index index p p x x y y index index p p y y public Point2D point2 d Double getControlPoint get control point int index index return new Point2D point2 d Double x x index index y y index index public void moveTo move to Point2D point2 d Double p p moveBy move by p p x x x x 0 0 p p y y y y 0 0 public void moveTo move to double x x double y y moveBy move by x x this x x 0 0 y y this y y 0 0 public void moveBy move by double dx dx double dy dy for int i i 0 0 i i 3 3 i++ i++ x x i i + + dx dx y y i i + + dy dy public Object clone clone try Node node that that Node node super clone clone that that x x this x x clone clone that that y y this y y clone clone return that that catch CloneNotSupportedException clone not support e e InternalError internal error new InternalError internal error initCause init cause e e throw error public String toString to StringBuilder builder buf buf new StringBuilder builder buf buf append append for int i i 0 0 i i 3 3 i++ i++ if i i 0 0 if mask mask i i i i buf buf append append else continue buf buf append append x x buf buf append append i i buf buf append append buf buf append append x x i i buf buf append append y y buf buf append append i i buf buf append append buf buf append append y y i i buf buf append append return buf buf toString to Creates create a a new instance instance public BezierPath bezi path Convenience convenience method for adding add a a control control point point with with a a single single coordinate coordinate C0 c0 public void add add Point2D point2 d Double c0 c0 add add new Node node 0 0 c0 c0 c0 c0 c0 c0 public void addPoint add point double x x double y y add add new Node node 0 0 x x y y x x y y x x y y Convenience convenience method for adding add a a control control point point with with three three coordinates coordinate C0 c0 C1 c1 and and C2 c2 with with a a mask mask public void add add int mask mask Point2D point2 d Double c0 c0 Point2D point2 d Double c1 c1 Point2D point2 d Double c2 c2 add add new Node node mask mask c0 c0 c1 c1 c2 c2 Convenience convenience method for changing change a a single single coordinate coordinate of of a a control control point point public void set set int index index int coord coord Point2D point2 d Double p p Node node c c get get index index c c x x coord coord p p x x c c y y coord coord p p y y Convenience convenience method for getting getting a a single single coordinate coordinate of of a a control control point point public Point2D point2 d Double get get int index index int coord coord Node node c c get get index index return new Point2D point2 d Double c c x x coord coord c c y y coord coord This must must be be called call after after the the BezierPath bezi path has ha been be changed change public void invalidatePath invalidate path generalPath general path null outer out 1 1 Recomputes recompute the the BezierPath bezi path if it it is is invalid invalid public void validatePath validate path if generalPath general path null generalPath general path toGeneralPath to general path Converts convert the the BezierPath bezi path into into a a GeneralPath general path public GeneralPath general path toGeneralPath to general path GeneralPath general path gp gp new GeneralPath general path gp gp setWindingRule set winding rule GeneralPath general path WIND w i n d EVEN e v e n ODD o d d if size size 0 0 gp gp moveTo move to 0 0 0 0 gp gp lineTo line to 0 0 0 0 + + 1 1 else if size size 1 1 Node node current current get get 0 0 gp gp moveTo move to float current current x x 0 0 float current current y y 0 0 gp gp lineTo line to float current current x x 0 0 float current current y y 0 0 + + 1 1 else Node node previous previou Node node current current previous previou current current get get 0 0 gp gp moveTo move to float current current x x 0 0 float current current y y 0 0 for int i i 1 1 n n size size i i n n i++ i++ previous previou current current current current get get i i if previous previou mask mask C2 c2 MASK m a s k 0 0 if current current mask mask C1 c1 MASK m a s k 0 0 gp gp lineTo line to float current current x x 0 0 float current current y y 0 0 else gp gp quadTo quad to float current current x x 1 1 float current current y y 1 1 float current current x x 0 0 float current current y y 0 0 else if current current mask mask C1 c1 MASK m a s k 0 0 gp gp quadTo quad to float previous previou x x 2 2 float previous previou y y 2 2 float current current x x 0 0 float current current y y 0 0 else gp gp curveTo curve to float previous previou x x 2 2 float previous previou y y 2 2 float current current x x 1 1 float current current y y 1 1 float current current x x 0 0 float current current y y 0 0 if isClosed is close if size size 1 1 previous previou get get size size 1 1 current current get get 0 0 if previous previou mask mask C2 c2 MASK m a s k 0 0 if current current mask mask C1 c1 MASK m a s k 0 0 gp gp lineTo line to float current current x x 0 0 float current current y y 0 0 else gp gp quadTo quad to float current current x x 1 1 float current current y y 1 1 float current current x x 0 0 float current current y y 0 0 else if current current mask mask C1 c1 MASK m a s k 0 0 gp gp quadTo quad to float previous previou x x 2 2 float previous previou y y 2 2 float current current x x 0 0 float current current y y 0 0 else gp gp curveTo curve to float previous previou x x 2 2 float previous previou y y 2 2 float current current x x 1 1 float current current y y 1 1 float current current x x 0 0 float current current y y 0 0 gp gp closePath close path return gp gp public boolean contains contain Point2D point2 d p p validatePath validate path return generalPath general path contains contain p p Returns true if the the outline outline of of this bezier bezi path path contains contain the the specified specify point point param p p The the point point to to be be tested test param tolerance tolerance The the tolerance tolerance for the the test test public boolean outlineContains outline contain Point2D point2 d Double p p double tolerance tolerance validatePath validate path PathIterator path iterator i i generalPath general path getPathIterator get path iterator new AffineTransform affine transform tolerance tolerance double coords coord new double 6 6 int type type i i currentSegment current segment coords coord double prevX prev x coords coord 0 0 double prevY prev y coords coord 1 1 i i next next while i i isDone is i i currentSegment current segment coords coord if Geom geom lineContainsPoint line contain point prevX prev x prevY prev y coords coord 0 0 coords coord 1 1 p p x x p p y y tolerance tolerance return true prevX prev x coords coord 0 0 prevY prev y coords coord 1 1 i i next next return false public boolean intersects intersect Rectangle2D rectangle2 d r r validatePath validate path return generalPath general path intersects intersect r r public PathIterator path iterator getPathIterator get path iterator AffineTransform affine transform at at validatePath validate path return generalPath general path getPathIterator get path iterator at at public boolean contains contain Rectangle2D rectangle2 d r r validatePath validate path return generalPath general path contains contain r r public PathIterator path iterator getPathIterator get path iterator AffineTransform affine transform at at double flatness flatness validatePath validate path return generalPath general path getPathIterator get path iterator at at flatness flatness public boolean intersects intersect double x x double y y double w w double h h validatePath validate path return generalPath general path intersects intersect x x y y w w h h public Rectangle2D rectangle2 d getBounds2D get bounds2 d validatePath validate path return generalPath general path getBounds2D get bounds2 d public Rectangle2D rectangle2 d Double getBounds2DDouble get bounds2 d validatePath validate path Rectangle2D rectangle2 d r r generalPath general path getBounds2D get bounds2 d if r r instanceof Rectangle2D rectangle2 d Double return Rectangle2D rectangle2 d Double r r else return new Rectangle2D rectangle2 d Double r r getX get x r r getY get y r r getWidth get width r r getHeight get height public Rectangle rectangle getBounds get bound validatePath validate path return generalPath general path getBounds get bound public boolean contains contain double x x double y y double w w double h h validatePath validate path return generalPath general path contains contain x x y y w w h h public boolean contains contain double x x double y y validatePath validate path return generalPath general path contains contain x x y y public void setClosed set close boolean newValue value if isClosed is close newValue value isClosed is close newValue value invalidatePath invalidate path public boolean isClosed is close return isClosed is close Creates create a a deep deep copy copy of of the the BezierPath bezi path public Object clone clone BezierPath bezi path that that BezierPath bezi path super clone clone for int i i 0 0 n n this size size i i n n i++ i++ that that set set i i Node node this get get i i clone clone return that that Transforms transform the the BezierPath bezi path param tx tx the the transformation transformation public void transform transform AffineTransform affine transform tx tx Point2D point2 d Double p p new Point2D point2 d Double for Node node cp cp this for int i i 0 0 i i 3 3 i++ i++ p p x x cp cp x x i i p p y y cp cp y y i i tx tx transform transform p p p p cp cp x x i i p p x x cp cp y y i i p p y y invalidatePath invalidate path public void setTo set to BezierPath bezi path that that while that that size size size size remove remove size size 1 1 for int i i 0 0 n n size size i i n n i++ i++ get get i i setTo set to that that get get i i while size size that that size size add add Node node that that get get size size clone clone Returns the the point point at at the the center center of of the the bezier bezi path path public Point2D point2 d Double getCenter get center double sx sx 0 0 double sy sy 0 0 for Node node p p this sx sx + + p p x x 0 0 sy sy + + p p y y 0 0 int n n size size return new Point2D point2 d Double sx sx n n sy sy n n Returns a a point point on on the the edge edge of of the the bezier bezi path path which which crosses cross the the line line from from the the center center of of the the bezier bezi path path to to the the specified specify point point If no no edge edge crosses cross the the line line the the nearest near C0 c0 control control point point is is returned public Point2D point2 d Double chop chop Point2D point2 d Double p p validatePath validate path return Geom geom chop chop generalPath general path p p Point2D point2 d Double ctr ctr getCenter get center Chopped chop point point double cx cx 1 1 double cy cy 1 1 double len len Double MAX m a x VALUE v a l u e Try for points point along along edge edge validatePath validate path PathIterator path iterator i i generalPath general path getPathIterator get path iterator new AffineTransform affine transform 1 1 double coords coord new double 6 6 int type type i i currentSegment current segment coords coord double prevX prev x coords coord 0 0 double prevY prev y coords coord 1 1 i i next next for i i isDone is i i next next i i currentSegment current segment coords coord Point2D point2 d Double chop chop Geom geom intersect intersect prevX prev x prevY prev y coords coord 0 0 coords coord 1 1 p p x x p p y y ctr ctr x x ctr ctr y y if chop chop null double cl cl Geom geom length2 length2 chop chop x x chop chop y y p p x x p p y y if cl cl len len len len cl cl cx cx chop chop x x cy cy chop chop y y prevX prev x coords coord 0 0 prevY prev y coords coord 1 1 if isClosed is close size size 1 1 Node node first first get get 0 0 Node node last last get get size size 1 1 Point2D point2 d Double chop chop Geom geom intersect intersect first first x x 0 0 first first y y 0 0 last last x x 0 0 last last y y 0 0 p p x x p p y y ctr ctr x x ctr ctr y y if chop chop null double cl cl Geom geom length2 length2 chop chop x x chop chop y y p p x x p p y y if cl cl len len len len cl cl cx cx chop chop x x cy cy chop chop y y if none none found found pick pick closest close vertex vertex if len len Double MAX m a x VALUE v a l u e for int j j 0 0 n n size size j j n n j++ j++ Node node cp cp get get j j double l l Geom geom length2 length2 cp cp x x 0 0 cp cp y y 0 0 p p x x p p y y if l l len len len len l l cx cx cp cp x x 0 0 cy cy cp cp y y 0 0 return new Point2D point2 d Double cx cx cy cy Return the the index index of of the the control control point point that that is is furthest furthest from from the the center center public int indexOfOutermostNode index of outermost node if outer out 1 1 Point2D point2 d Double ctr ctr getCenter get center outer out 0 0 double dist dist 0 0 for int i i 0 0 n n size size i i n n i++ i++ Node node cp cp get get i i double d d Geom geom length2 length2 ctr ctr x x ctr ctr y y cp cp x x 0 0 cp cp y y 0 0 if d d dist dist dist dist d d outer out i i return outer out Returns a a relative relative point point on on the the path path Where where 0 0 is is the the start start point point of of the the path path and and 1 1 is is the the end end point point of of the the path path param relative relative a a value value between between 0 0 and and 1 1 public Point2D point2 d Double getPointOnPath get point on path double relative relative double flatness flatness if size size 0 0 return null else if size size 1 1 return get get 0 0 getControlPoint get control point 0 0 if relative relative 0 0 return get get 0 0 getControlPoint get control point 0 0 else if relative relative 1 1 return get get size size 1 1 getControlPoint get control point 0 0 validatePath validate path Determine determine the the length length of of the the path path double len len 0 0 PathIterator path iterator i i generalPath general path getPathIterator get path iterator new AffineTransform affine transform flatness flatness double coords coord new double 6 6 int type type i i currentSegment current segment coords coord double prevX prev x coords coord 0 0 double prevY prev y coords coord 1 1 i i next next for i i isDone is i i next next i i currentSegment current segment coords coord len len + + Geom geom length length prevX prev x prevY prev y coords coord 0 0 coords coord 1 1 prevX prev x coords coord 0 0 prevY prev y coords coord 1 1 Compute compute the the relative relative point point on on the the path path double relativeLen relative len len len relative relative double pos po 0 0 i i generalPath general path getPathIterator get path iterator new AffineTransform affine transform flatness flatness type type i i currentSegment current segment coords coord prevX prev x coords coord 0 0 prevY prev y coords coord 1 1 i i next next for i i isDone is i i next next i i currentSegment current segment coords coord double segLen seg len Geom geom length length prevX prev x prevY prev y coords coord 0 0 coords coord 1 1 if pos po + + segLen seg len relativeLen relative len if true return new Point2D point2 d Double coords coord 0 0 coords coord 1 1 Compute compute the the relative relative Point2D point2 d Double on on the the line line return new Point2D point2 d Double prevX prev x pos po len len + + coords coord 0 0 pos po + + segLen seg len len len prevY prev y pos po len len + + coords coord 1 1 pos po + + segLen seg len len len double factor factor relativeLen relative len pos po segLen seg len return new Point2D point2 d Double prevX prev x 1 1 factor factor + + coords coord 0 0 factor factor prevY prev y 1 1 factor factor + + coords coord 1 1 factor factor pos po + + segLen seg len prevX prev x coords coord 0 0 prevY prev y coords coord 1 1 throw new InternalError internal We we should should never nev get get here here Gets get the the segment segment of of the the polyline polyline that that is is hit hit by by the the given given Point2D point2 d Double return the the index index of of the the segment segment or or 1 1 if no no segment segment was wa hit hit public int findSegment find segment Point2D point2 d Double find find float tolerance tolerance XXX x x x This works work only only for straight straight lines line Node node v1 v1 v2 v2 BezierPath bezi path tempPath temp path new BezierPath bezi path Node node t1 t1 t2 t2 tempPath temp path add add t1 t1 new Node node tempPath temp path add add t2 t2 new Node node for int i i 0 0 n n size size 1 1 i i n n i++ i++ v1 v1 get get i i v2 v2 get get i+1 i+1 if v1 v1 mask mask 0 0 v2 v2 mask mask 0 0 if Geom geom lineContainsPoint line contain point v1 v1 x x 0 0 v1 v1 y y 0 0 v2 v2 x x 0 0 v2 v2 y y 0 0 find find x x find find y y tolerance tolerance return i i else t1 t1 setTo set to v1 v1 t2 t2 setTo set to v2 v2 tempPath temp path invalidatePath invalidate path if tempPath temp path outlineContains outline contain find find tolerance tolerance return i i if isClosed is close size size 1 1 v1 v1 get get size size 1 1 v2 v2 get get 0 0 if v1 v1 mask mask 0 0 v2 v2 mask mask 0 0 if Geom geom lineContainsPoint line contain point v1 v1 x x 0 0 v1 v1 y y 0 0 v2 v2 x x 0 0 v2 v2 y y 0 0 find find x x find find y y tolerance tolerance return size size 1 1 else t1 t1 setTo set to v1 v1 t2 t2 setTo set to v2 v2 tempPath temp path invalidatePath invalidate path if tempPath temp path outlineContains outline contain find find tolerance tolerance return size size 1 1 return 1 1 Joins join two two segments segment into into one one if the the given given Point2D point2 d Double hits hit a a node node of of the the bezier bezi path path return the the index index of of the the joined join segment segment or or 1 1 if no no segment segment was wa joined join public int joinSegments join segment Point2D point2 d Double join join float tolerance tolerance for int i i 0 0 i i size size i++ i++ Node node p p get get i i if Geom geom length length p p x x 0 0 p p y y 0 0 join join x x join join y y tolerance tolerance remove remove i i return i i return 1 1 Splits split the the segment segment at at the the given given Point2D point2 d Double if a a segment segment was wa hit hit return the the index index of of the the segment segment or or 1 1 if no no segment segment was wa hit hit public int splitSegment split segment Point2D point2 d Double split split float tolerance tolerance int i i findSegment find segment split split tolerance tolerance int nextI next i i i + + 1 1 % % size size if i i 1 1 if get get i i mask mask C2 c2 MASK m a s k C2 c2 MASK m a s k get get nextI next i mask mask C1 c1 MASK m a s k 0 0 quadto quadto add add i i + + 1 1 new Node node C2 c2 MASK m a s k split split split split split split else if get get i i mask mask C2 c2 MASK m a s k 0 0 get get nextI next i mask mask C1 c1 MASK m a s k C1 c1 MASK m a s k quadto quadto add add i i + + 1 1 new Node node C2 c2 MASK m a s k split split split split split split else if get get i i mask mask C2 c2 MASK m a s k C2 c2 MASK m a s k get get nextI next i mask mask C1 c1 MASK m a s k C2 c2 MASK m a s k cubicto cubicto add add i i + + 1 1 new Node node C1 c1 MASK m a s k | | C2 c2 MASK m a s k split split split split split split else lineto lineto add add i i + + 1 1 new Node node split split return i+1 i+1 public void moveTo move to double x1 x1 double y1 y1 if size size 0 0 throw new IllegalPathStateException illegal path state moveTo move to only only allowed allow when when empty empty add add new Node node x1 x1 y1 y1 public void lineTo line to double x1 x1 double y1 y1 if size size 0 0 throw new IllegalPathStateException illegal path state lineTo line to only only allowed allow when when not not empty empty add add new Node node x1 x1 y1 y1 public void quadTo quad to double x1 x1 double y1 y1 double x2 x2 double y2 y2 if size size 0 0 throw new IllegalPathStateException illegal path state quadTo quad to only only allowed allow when when not not empty empty add add new Node node C1 c1 MASK m a s k x2 x2 y2 y2 x1 x1 y1 y1 x2 x2 y2 y2 public void curveTo curve to double x1 x1 double y1 y1 double x2 x2 double y2 y2 double x3 x3 double y3 y3 if size size 0 0 throw new IllegalPathStateException illegal path state curveTo curve to only only allowed allow when when not not empty empty Node node lastPoint last point get get size size 1 1 lastPoint last point mask mask | | C2 c2 MASK m a s k lastPoint last point x x 2 2 x1 x1 lastPoint last point y y 2 2 y1 y1 add add new Node node C1 c1 MASK m a s k x3 x3 y3 y3 x2 x2 y2 y2 x3 x3 y3 y3 public Point2D point2 d Double toPolygonArray to polygon Point2D point2 d Double points point new Point2D point2 d Double size size for int i i 0 0 n n size size i i n n i++ i++ points point i i new Point2D point2 d Double get get i i x x 0 0 get get i i y y 0 0 return points point 