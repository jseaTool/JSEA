standard utility variou miscallaneou utility function tab size 4 indent size 4 no tab collapse fold 1 1999 2006 matthieu casanova 2000 richard s hall 2001 dirk moebiu g n u 2 w i t h o u t n y w r r n t y m e r h n t b i l i t y f i t n e s s f o r p r t i u l r p u r p o s e g n u g n u 59 330 m 02111 1307 u s importsimport annotation nullable text segment security message digest security no such algorithm text decimal format comparator stack several tool depend on j d k only matthieu casanova standard utility 24072 2015 09 16 19 52 05 kerik sf since 4 3pre5 standard utility escape escape newline tab backslash quote specify str since j edit 4 3pre15 escape str escape str \\\ escape specify character specify str escape character require escape since j edit 4 3pre15 escape str escape builder buf builder i 0 i str length i++ str at i escape index 1 buf append \ buf append \ buf append \\ buf append buf append buf get prev indent style str leading whitespace indent subsequent line since j edit 4 3pre10 get indent str builder indent builder i 0 i str length i++ ch str at i character whitespace ch indent append ch indent get leading white space number leading white space character specify str get leading white space str get leading white space sequence str number leading white space character specify str since j edit 4 3pre15 get leading white space sequence str whitespace 0 loop whitespace str length str at whitespace whitespace++ loop whitespace get trailing white space number trailing whitespace character specify str get trailing white space str whitespace 0 loop i str length 1 i 0 i str at i whitespace++ loop whitespace get leading white space width width leading white space specify str tab size tab size get leading white space width str tab size get leading white space width sequence str tab size width leading white space specify str tab size tab size since j edit 4 3pre15 get leading white space width sequence str tab size whitespace 0 loop i 0 i str length i++ str at i whitespace++ whitespace + tab size whitespace % tab size loop whitespace create white space create white space specify length p get whitespace tune current buffer s setting call follow pre my whitespace misc utility create white space my length buffer get property no tab ? 0 buffer get tab size pre len length tab size tab size 0 tab are use create white space len tab size create white space len tab size 0 truncate white space truncate white space len tab size indent str builder buf builder indent 0 i 0 indent len i indent str length i++ indent str at i indent++ buf append tab indent + tab size indent % tab size tab len indent len indent++ buf append indent tab buf append buf create white space create white space specify length p get whitespace tune current buffer s setting call follow pre my whitespace misc utility create white space my length buffer get property no tab ? 0 buffer get tab size pre len length tab size tab size 0 tab are use start start offset tab alignment create white space len tab size start builder buf builder tab size 0 len 0 buf append len 1 buf append count len + start % tab size tab size count 0 len + start count 0 buf append count len % tab size count 0 buf append buf get virtual width virtual column number taking tab into account specify offset segment seg segment tab size tab size get virtual width segment seg tab size virtual position 0 i 0 i seg count i++ ch seg seg offset + i ch virtual position + tab size virtual position % tab size ++virtual position virtual position get offset virtual column offset virtual column number taking tab into account segment seg segment tab size tab size column virtual column number total virtual width non total virtual width store it first location 1 1 column out bound get offset virtual column segment seg tab size column total virtual width virtual position 0 i 0 i seg count i++ ch seg seg offset + i ch tab width tab size virtual position % tab size virtual position column i virtual position + tab width virtual position column i ++virtual position total virtual width total virtual width 0 virtual position 1 compare compare two p unlike compare correctly recogniz handle embed number example place my 2 before my 10 p str1 first maybe str2 second maybe ignore ignore negative str1 lt str2 0 both are same positive str1 str2 lt non since j edit 4 3pre5 compare str1 str2 ignore str1 str2 0 str1 1 str2 1 char1 str1 char2 str2 len math min char1 length char2 length i 0 j 0 i len j len i++ j++ ch1 char1 i ch2 char2 j character digit ch1 character digit ch2 ch1 0 ch2 0 i i + 1 j j + 1 i char1 length i++ character digit char1 i i j char2 length j++ character digit char2 j j len1 i i len2 j j len1 len2 1 len1 len2 1 k 0 k len1 k++ ch1 char1 i + k ch2 char2 j + k ch1 ch2 ch1 ch2 i i 1 j j 1 ignore ch1 character lower ch1 ch2 character lower ch2 ch1 ch2 ch1 ch2 char1 length char2 length compare compare compare e comparator e icase compare icase icase icase compare override compare e obj1 e obj2 compare obj1 obj2 icase equal two are equal correctly handle pointer oppose calling o1 equal o2 since j edit 4 3pre6 deprecate use equal deprecate equal nullable o1 nullable o2 o1 o2 o2 o1 equal o2 glob r e convert unix style glob regular expression p ? become become aa bb become aa|bb glob glob pattern since j edit 4 3pre7 glob r e glob glob start re glob substring 4 n e g g r o u p stack state stack builder buf builder backslash i 0 i glob length i++ glob at i backslash buf append \\ buf append backslash \\ backslash ? buf append + buf append \\ buf append buf append | backslash buf append \\| buf append | buf append i + 1 glob length glob at i + 1 buf append ? state push n e g state push g r o u p state empty state peek g r o u p buf append | buf append state empty buf append state pop n e g buf append buf append buf append buf region match region match sequence seq test sequence toff offset test sequence other sequence compare ooff offset comparison sequence len how many character compare wheth two subsequence are equal region match since j edit 4 3pre15 region match sequence seq toff sequence other ooff len toff 0 || ooff 0 || len 0 ret i 0 i len i++ c1 i + toff seq length c1 seq at i + toff ret c2 i + ooff other length c2 other at i + ooff ret c1 c2 ret ret start start sequence seq sequence str test wheth sequence start test since j edit 4 3pre15 start sequence seq str ret i 0 i str length i++ i seq length || seq at i str at i ret ret get from given obj def value value obj value yes on value no off def value anyth since j edit 4 3pre17 get obj def obj def obj obj value equal obj || yes equal obj || on equal obj equal obj || no equal obj || off equal obj def format size decimal format k b f o r m t decimal format k b decimal format m b f o r m t decimal format m b format given size into nice 123 10 6 k b 1 2 m b length size since j edit 4 4pre1 format size length length 1024 length + length 1024 10 k b f o r m t format length 1024 m b f o r m t format length 1024 1024 standard utility m d5 sum md5sum given dummy on suppres no such algorithm because m d5 algorithm alway present j r e sequence given md5 sum given md5 sequence sequence message digest digest message digest get instance m d5 ba 2 i 0 n sequence length i n i++ cp sequence at i ba 0 cp 0xff ba 1 cp 8 0xff digest update ba digest digest no such algorithm e log log log e r r o r standard utility t calculate m d5 hash e 1 