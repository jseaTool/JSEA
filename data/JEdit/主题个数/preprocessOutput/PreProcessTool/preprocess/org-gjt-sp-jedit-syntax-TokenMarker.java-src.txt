token marker tokeniz line text tab size 4 indent size 4 no tab collapse fold 1 1998 2003 1999 2000 g n u 2 w i t h o u t n y w r r n t y m e r h n t b i l i t y f i t n e s s f o r p r t i u l r p u r p o s e g n u g n u 59 330 m 02111 1307 u s syntax importsimport text segment ref weak reference regex matcher regex pattern text utility segment sequence token marker split line text into token each token carry length field an identification tag map color font style painting token token marker 23381 2013 12 09 12 43 14 kpou syntax token syntax token handler token marker token marker constructor token marker add rule set add rule set parser rule set rule rule set put rule get set name rule m i n equal rule get set name rule set rule get rule set parser rule set get rule set rule set get rule set parser rule set get rule set set name rule set get set name get rule set since j edit 4 2pre3 parser rule set get rule set rule set value parser rule set rule set size mark token call directly call buffer mark token instead prev context context previou line token handler token handler line segment contain content line line context mark token line context prev context token handler token handler segment line set up some instance variable avoid have pas around lot lot token handler token handler line line last offset line offset line length line count + line offset context line context prev context context rule get rule set context escape rule context rule get escape rule context parent prev context parent context set rule prev context rule context rule prev context rule context span end subst prev context span end subst context span end subst regex prev context span end subst regex keyword context rule get keyword see whitespace end whitespace end line offset parser loop terminate context rule get terminate terminate loop po line offset po line length pos++ check we stop parse happen terminate ha be exceed terminate 0 po line offset terminate terminate terminate context line context parser rule set get standard rule set context rule get context keyword context rule get keyword check escape rule before anyth context escape rule handle rule start context escape rule loop check end delegate context parent context parent rule check delegate end context parent rule see whitespace end loop check every rule character ch character value line po list parser rule rule context rule get rule ch parser rule rule rule stop check rule there wa match handle rule start rule see whitespace end loop check current character word separator character whitespace ch see whitespace end whitespace end po + 1 context rule handle rule end context rule handle no word mark keyword last offset po token handler handle token line context rule get last offset line offset po last offset context token handler handle token line context rule get po line offset 1 context last offset po + 1 keyword || context rule get rule count 0 no word sep context rule get no word sep character letter digit ch no word sep index ch 1 context rule handle rule end context rule handle no word mark keyword token handler handle token line context rule get last offset line offset 1 context last offset po + 1 see whitespace end mark all remain character po line length context rule handle rule end context rule handle no word mark keyword unwind n o l i n e b r e k parent delegatesunwind context parent parser rule rule context parent rule rule rule action parser rule n o l i n e b r e k parser rule n o l i n e b r e k || terminate context context parent keyword context rule get keyword context set rule unwind token handler handle token line token e n d po line offset 0 context context context intern token handler set line context context g token handler line context member instance variable map parser rule set rule set hashtable parser rule set 64 parser rule set rule set instead passing these around each we just store them instance variable note thread safe token handler token handler line from which we mark token segment line context current line line context context keyword map keyword segment pattern segment last offset line length po whitespace end see whitespace end check delegate end check delegate end parser rule rule rule end rule end regexp line context temp context context context context parent keyword context rule get keyword handle handle rule end rule context temp context keyword context rule get keyword handle context rule handle rule end context rule mark keyword context line context context parent clone token handler handle token line match token context rule context rule context po line offset pattern count context keyword context rule get keyword context set rule last offset po + pattern count move po last character match sequence po + pattern count 1 offset match check offset match given position match hint parser rule offset match offset po match po match parser rule t l i n e s t r t parser rule t l i n e s t r t offset line offset po match parser rule t w h i t e s p e e n d parser rule t w h i t e s p e e n d offset whitespace end po match parser rule t w o r d s t r t parser rule t w o r d s t r t offset last offset handle rule start check rule match line at current position it start handle rule doe match handle rule start parser rule check rule some rule only match certain location check rule up hash check rule up hash po + check rule up hash length line length check hash check rule 1 binary search check rule up hash character upper line po offset check rule action parser rule m r k p r e v i o u s 0 ? last offset po offset match offset check rule start po match match matcher match rule s start sequence match here check rule action parser rule r e g e x p 0 pattern check rule start pattern offset 0 pattern count pattern length match pattern count syntax utility region match context rule get ignore line po pattern note all regexp start \ so they only match start match start po line offset sequence seq segment sequence line po line offset line count po line offset match check rule start regexp matcher seq match looking at match start 0 internal t happen match match end workaround hang match wa zero width sure there better way handle match 0 match 1 check rule action parser rule i s e s p e parser rule i s e s p e po + pattern count context rule handle rule end context rule mark keyword check rule action parser rule m r k p r e v i o u s parser rule m r k p r e v i o u s check rule action parser rule m j o r t i o n s s e q parser rule s e q context span end subst context span end subst regex check rule action parser rule r e g e x p 0 handle token space token handler check rule token po line offset match context token handler handle token line check rule token po line offset match context d e l e g t e attribute on s e q change ruleset from end s e q onward check rule delegate context line context check rule delegate context parent keyword context rule get keyword s p n e o l s p n parser rule s p n parser rule e o l s p n context set rule check rule token type match token check rule context rule context check rule action parser rule r e g e x p 0 handle token space token handler token type po line offset match context token handler handle token line token type po line offset match context span end subst pattern span end subst regex substitute result match rule start into end eg shell script mode \ \w+ match into \ $1\ construct rule highlighting read in like e o f e o f match match group count 0 check rule end span end subst substitute match check rule end check rule end regexp pattern check rule end regexp pattern pattern substitute match pattern span end subst regex pattern compile pattern context span end subst span end subst context span end subst regex span end subst regex context line context check rule delegate context keyword context rule get keyword m r k f o l l o w i n g parser rule m r k f o l l o w i n g token handler handle token line match token check rule check rule context po line offset pattern count context context span end subst context span end subst regex context set rule check rule m r k p r e v i o u s parser rule m r k p r e v i o u s context span end subst context span end subst regex po last offset token handler handle token line check rule token last offset line offset po last offset context token handler handle token line match token check rule check rule context po line offset pattern count context internal unhandl major action move po last character match sequence po + match 1 last offset po + 1 out inner loop check next handle rule end check rule match line at current position it end handle rule doe match handle rule end parser rule check rule some rule only match certain location offset check rule action parser rule m r k p r e v i o u s 0 ? last offset po offset match offset check rule end po match rule s end sequence match here check rule action parser rule m r k f o l l o w i n g 0 check rule action parser rule e n d r e g e x p 0 context span end subst pattern context span end subst pattern check rule end pattern offset 0 pattern count pattern length syntax utility region match context rule get ignore line po pattern sequence seq segment sequence line po line offset line count po line offset pattern regex context span end subst regex regex context span end subst regex regex check rule end regexp matcher match regex matcher seq match looking at use check delegate end pattern count match end escape rule are handle handle rule start check rule action parser rule i s e s p e 0 handle end m r k f o l l o w i n g context rule action parser rule m r k f o l l o w i n g 0 po last offset token handler handle token line context rule token last offset line offset po last offset context last offset po context set rule handle no word handle no word context parent parser rule rule context parent rule rule context parent rule action parser rule n o w o r d b r e k 0 po last offset token handler handle token line rule token last offset line offset po last offset context last offset po context context parent keyword context rule get keyword context set rule handle token space handle token space token handler token handler token type start len line context context last start end start + len i start i end i++ character whitespace line i + line offset last i token handler handle token line token type last i last context token handler handle token line token type i 1 context last i + 1 last end token handler handle token line token type last end last context mark keyword mark keyword add remain len po last offset len 0 digit context rule get highlight digit digit mix i last offset i po i++ ch line i character digit ch digit mix mix pattern digit r e context rule get digit regexp only match against regexp it all digit all digit no point match digit digit r e mix digit alpha keyword no regexp t highlight d i g i t digit old count line count old offset line offset line offset last offset line count len sequence seq segment sequence line digit digit r e matcher seq match line offset old offset line count old count digit token handler handle token line token d i g i t last offset line offset len context last offset po keyword keyword keyword lookup line last offset len token n u l l token handler handle token line last offset line offset len context last offset po handle remain crud add remain token handler handle token line context rule get last offset line offset len context last offset po substitute perform substitution reference end match group match $1 replace first match group match $2 replace second all way up $9 moreov group i match single bracket character then i replace complementary bracket match matcher produce match start regex end pattern substitute escape then escape match text before insert into end so result interpret regex pattern substitute pattern substitute matcher match end escape builder buf builder i 0 i end length i++ ch end i ch || ch i end length 1 buf append ch digit end i + 1 character digit digit buf append ch ch text match group digit 0 escape text text utility escape text text buf append text i++ s match group digit 0 s length 1 b text utility get complementary bracket s at 0 b \0 b s at 0 buf append b buf append ch i++ buf append ch value buf length buf get 0 buf length value 0 value match token match token parser rule rule parser rule base line context ctx rule match type parser rule m t h t y p e r u l e base token parser rule m t h t y p e o n t e x t context rule get rule match type check hash check hash parser rule rule i 0 i rule up hash length i++ character upper line pos+i rule up hash i line context store persistent p line syntax parser state line context weak hash map line context weak reference line context intern weak hash map line context weak reference line context line context parent parser rule rule parser rule set rule use s p n r e g e x p rule otherwise span end subst pattern span end subst regex parser rule escape rule line context constructor line context parser rule set r line context lc rule r parent lc ? line context lc clone s p n no delegate need propagate escape rule child context so need r get mode name escape rule rule get escape rule escape rule lc escape rule line context constructor line context intern line context intern weak reference line context ref intern get ref line context obj ref get obj obj intern put weak reference line context hash hash 0 + parent ? parent hash 0 + rule ? rule hash 0 + rule ? rule hash 0 + span end subst ? span end subst hash 0 + span end subst regex ? span end subst regex hash 0 equal equal obj obj line context line context lc line context obj lc rule rule lc rule rule equal parent lc parent equal span end subst lc span end subst equal span end subst regex lc span end subst regex clone override clone line context lc line context lc rule rule lc rule rule lc parent parent ? line context parent clone lc span end subst span end subst lc span end subst regex span end subst regex lc escape rule escape rule lc equal equal c1 c2 c1 c2 c1 c2 c1 length c2 length i 0 i c1 length i++ c1 i c2 i set rule set current rule being process adjust escape rule context base on rule set rule parser rule rule rule rule rule rule escape rule escape rule rule escape rule rule rule get mode name escape rule rule get escape rule parent escape rule parent escape rule escape rule 