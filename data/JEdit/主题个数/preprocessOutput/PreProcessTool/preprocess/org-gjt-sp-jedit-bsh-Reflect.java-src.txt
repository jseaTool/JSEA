part bean shell script distribution documentation update may found at http www beanshell sun notice content are subject sun 1 0 may use except compliance available at http www sun com original bean shell initial developer original pat niemey create pat niemey are 2000 all right reserve g n u notice alternatively content may use g n u less l g p l which provision l g p l are applicable instead those above wish allow use your only l g p l allow other use your s p l indicate your decision delete provision above replace them notice other provision require l g p l delete provision above recipient may use your s p l l g p l patrick niemey pat pat net learning o reilly associate http www pat net pat bsh reflect vector all reflection p i lie here form utility maybe belong l h s generic wrapper note messy field resolution need rewrite variou here no such no such field dur their search these rewrite avoid have lookup are now cache at high level so they are les important howev logic messy suppres warning uncheck reflect on arbitrary instance invocation may through instance dynamic may bsh script bsh type result call name interpreter interpreter call stack callstack simple node caller info reflect eval invocation target bsh script expose name name interpreter callstack caller info delcar only plain find bsh bcm interpreter ? interpreter get cla get resolve expect bcm cla name eval e e eval caller info callstack know no instance need there no possibility being bsh script bsh bcm cla name reflect eval invocation target interpreter debug resolve expect bcm cla name on specify performing need type mapping on argument value may reflect invocation target 0 log entry map type assignable form need keep fast tmp length type get parameter type i 0 i length i++ tmp i type cast i rh type i lh type type s s i g n m e n t eval e interpreter illegal argument type invocation +e unwrap primitive tmp primitive unwrap tmp log after massage value tmp value tmp value value primitive n u l l type get type primitive wrap value type illegal access e reflect cannot access + get name get parameter type + + get declare + + e get index index reflect target interpreter d e b u g interpreter debug get index +array+ index +index val get index primitive wrap val get get component type index out bound e1 target e1 e reflect access + e set index index val reflect target val primitive unwrap val set index val store e2 target e2 illegal argument e1 target store e1 e reflect access + e get field value cla field name eval reflect get field value cla field name onlystatic get field value field name eval reflect namespace get variable field name get field value get field name onlystatic reflect e no field property acce ha property gett get field name get property field name e l h s get l h s field cla field name eval reflect field f resolve expect field cla field name onlystatic l h s f get an l h s reference an field also deal field style property access field doe we check property setter l h s get l h s field field name eval reflect i guess when we pas an argument? setting locally recurse l h s namespace field name recurse field f resolve expect field get field name only l h s f reflect e field property access ha property setter get field name l h s field name e get field value cla field name only eval reflect field f resolve expect field cla field name only value f get type f get type primitive wrap value type pointer e shouldn t happen reflect ??? + field name + field illegal access e reflect t access field + field name note resolve expect field rewrite invert logic so no need unecessarily just temporary impl field found field resolve field cla field name only eval resolve expect field cla field name only reflect e reflect field found note really just no such field need change relate signature field resolve expect field cla field name only eval reflect field field capability accessibility field find accessible field cla field name get field find only etc field cla get field field name no such field e reflect no such field + field name security e target security search field +cla e only modifier field get modifier eval t reach instance field +field name + from context +cla get name field use when accessibility capability available locate an occurrance field most derive superclass set it accessibility flag note need simple non accessible because we t hunt field note may declare overlapping field so distinction about most derive important doesn t normally allow kind access won t show variable so there no real syntax specify which scope use field no such field no such field field found rewrite use get field avoid catching dur search field find accessible field cla field name eval no such field field field quick check field include those field cla get field field name reflect r m set accessible field field no such field e now on hunt cla field cla get declare field field name reflect r m set accessible field field found fall through next no such field e cla cla get superclass no such field field name wrap resolve expect non result found descriptive reflect resolve expect bsh bcm cla name only reflect eval primitive n u l l target pointer attempt +name+ on value type type get type resolve bcm cla name type only reflect only ? + name type + found + cla get name + full blow resolv all other invocation delegate may dynamic unles only set which may only set then only locate p perform cache cache discover through utiliz cache p determine wheth attempt use non base on capability accessibility set accessibilty flag on necessary p when direct find locate specific match instance descriptive analogou compiler would produce note 2 0 x problem because there no way work around cast p only locate must may no match wa found resolve bsh bcm cla name type only eval cla interpreter lookup previously cache bcm interpreter debug resolve u n o p t i m i e d lookup bcm get resolve cla name type only only capability accessibility search may itself priviledg action find overload cla name type only security e target security search +cla e check found only cla first time we ve see set accessibility note s we may found non only reflect r m set accessible eval e ignore succeed cache resolve bcm bcm cache resolve cla type get candidate search graph base resolve most specific found find overload base name type only interpreter d e b u g interpreter debug search + name type + + base get name + get candidate base name type length only interpreter d e b u g interpreter debug looking most specific +method name find most specific type climb inheritence graph type collect all match specify name criterion only then only normal non accessible address problem aris when inner derive from type p primarily just delegate gather recursive gather recursive vector get candidate base name num only vector candidate gather recursive base name num only candidate an candidate size candidate into accumulate all optionally include non inheritence tree base analogou get which all inheritence tree normal non accessible also address problem aris when inner derive from type other word sometime we ll find we t use directly we find same parent candidate vector vector gather recursive base name num only vector candidate candidate candidate vector add current vector careful only add from use get instead get declare address secure environment only base add candidate base get name num only candidate add candidate base get declare name num only candidate doe implement interfaces? intf base get i 0 i intf length i++ gather recursive intf i name num only candidate we superclass? t etc superclass base get superclass superclass gather recursive superclass name num only candidate candidate vector add candidate name num only vector candidate i 0 i length i++ m i m get name equal name m get parameter type length num only || m candidate add m candidate primary constructor simple than those must resolve invocation because constructor are inherit p determine wheth attempt use non constructor base on capability accessibility set accessibilty flag on necessary p construct cla reflect invocation target cla reflect t create instance an +cla obj type type get type constructor con find constructor there are no inherit constructor worry about constructor constructor capability accessibility ? cla get declare constructor cla get constructor interpreter d e b u g interpreter debug looking most specific constructor +cla con find most specific constructor type constructor con cant find constructor cla type con reflect r m set accessible con eval e ignore primitive unwrap obj con instance instantiation e reflect +clas+ illegal access e reflect we t permission create an instance + use set accessibility enable access illegal argument e reflect number argument wa wrong obj reflect couldn t construct obj parallel find most specific only reason t combine constructor t common their signature constructor find most specific constructor ideal match constructor constructor match find most specific constructor index ideal match constructor match 1 ? constructor match find most specific constructor index ideal match constructor constructor candidate constructor length i 0 i candidate length i++ candidate i constructor i get parameter type find most specific signature ideal match candidate find best match signature ideal match assume hold only valid candidate e g name number already match currently doe take into account 5 covariant type which i think require we find most derive type otherwise identical best match find most specific signature set candidate which differ only type their argument find most specific ideal match signature into find most specific candidate sig length i 0 i length i++ candidate sig i i get parameter type match find most specific signature ideal match candidate sig match 1 ? match implement j l s 15 11 2 index most specific argument match 1 no match found use both constructor which unfortunately t share common signature info index most specific candidate note two which are equally specific allow compiler bean shell currently choos first one find we could add test here i believe add another signature assignable other direction between target best match assignment work both way then neither specific they are ambiguou i ll leave test out now because i m sure how much another test would impact performance selection now cache at high level so few friendly extraneou test shouldn t problem find most specific signature ideal match candidate round type f i r s t r o u n d s s i g n b l e round type l s t r o u n d s s i g n b l e round++ best match best match index 1 i 0 i candidate length i++ target match candidate i ideal match fit target match first match target match specific than best match make best match type signature assignable ideal match target match round best match || type signature assignable target match best match type j v b s e s s i g n b l e best match target match best match index i best match best match index 1 accessor name getorset prop name getorset + value character upper prop name at 0 + prop name substring 1 ha property gett cla prop name gett name accessor name get prop name cla get gett name 0 no such e fall through gett name accessor name prop name m cla get gett name 0 m get type t y p e no such e ha property setter cla prop name setter name accessor name set prop name cla get we t know right hand side assignment yet ha at least one setter right name? i 0 i length i++ i get name equal setter name get property obj prop name eval reflect interpreter debug property access e1 e2 accessor name accessor name get prop name resolve expect bcm obj get obj accessor name e e1 e accessor name accessor name prop name resolve expect bcm obj get obj accessor name get type t y p e e e2 e reflect property gett +e1 + e2 null? +e2 obj invocation target e eval property accessor +e get target set property obj prop name value reflect eval accessor name accessor name set prop name value interpreter debug property access resolve expect bcm obj get obj accessor name obj invocation target e eval property accessor +e get target human readable type name specifically type are postfix dimension e g instead i would get name normalize name type type type get name builder name builder name append get base type type get name + i 0 i get dimension type i++ name append reflect e shouldn t happen name dimensionality 0 an get dimension 0 get name last index + 1 why so cute? base type an reflect an get base type reflect reflect an get component type command may compile contain one correct signature must accept two additional leading argument interpreter callstack respectively e g interpreter callstack add argument result compile command command interpreter interpreter call stack callstack eval add interperet namespace list length + 2 0 interpreter 1 callstack arraycopy 0 2 length bsh bcm interpreter get reflect bcm command invocation target e eval compile command +e get target reflect e eval compile command +e log msg interpreter d e b u g interpreter debug msg +method+ i 0 i length i++ interpreter debug +i+ +arg i + type +arg i get check found only cla eval we re looking found an instance only eval cannot reach instance + get name get parameter type + from context + cla get name reflect cant find constructor cla type type length 0 reflect t find constructor +cla reflect t find constructor + cla get name type + + cla get name modifier get modifier m modifier m get modifier constructor modifier get modifier m modifier m get modifier 