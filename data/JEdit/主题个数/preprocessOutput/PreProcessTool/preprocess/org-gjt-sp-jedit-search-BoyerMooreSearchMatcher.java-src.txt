boy moore search matcher literal pattern matcher utilize boy moore algorithm tab size 4 indent size 4 no tab collapse fold 1 1999 2000 2001 tom locke 2001 2002 g n u 2 w i t h o u t n y w r r n t y m e r h n t b i l i t y f i t n e s s f o r p r t i u l r p u r p o s e g n u g n u 59 330 m 02111 1307 u s search literal search using boy moore algorithm boy moore search matcher 23332 2013 11 13 14 24 31 kpou boy moore search matcher search matcher boy moore search matcher constructor create literal matcher pattern search pattern ignore want ignore boy moore search matcher pattern ignore pattern ignore create literal matcher pattern search pattern ignore want ignore whole word search whole word only since 4 5pre1 boy moore search matcher pattern ignore whole word pattern pattern ignore i 0 i pattern length i++ pattern i character upper pattern i ignore ignore pattern end pattern length 1 whole word whole word next match override search matcher match next match sequence text start end first time reverse interrupt po match text reverse po 1 value start po value end po + pattern length end value end whole word sequence sub text whole word text value start value end sub text text sub sequence value end text length match match next match sub text start end first time reverse match value match match start + end end + match end match end match start + pattern length value match good introduction boy moore fast match algorithm may found on moore s website at http www c utexa edu user moore best idea search interrupt since j edit 4 3pre5 match sequence text reverse interrupt thread interrupt interrupt lazily create skip suffix search pattern reverse search pattern skip suffix reverse back skip back skip generate skip back suffix generate suffix skip back skip suffix back suffix fwd skip fwd skip generate skip fwd suffix generate suffix skip fwd skip suffix fwd suffix position variable pattern test position po position variable pattern start anchor 0 last possible start position match pattern negative pattern longer than text causing search loop below immediately fail last anchor reverse search ? offset + pattern length 1 length pattern length ch 0 bad good suffix search work starting anchor first character pattern at initial offset anchor far enough from enough text pattern match until pattern match we compare pattern text from last character first character reverse order where character pattern mismatch we use two heuristic base on mismatch character it position pattern determine furthest we move anchor miss potential pattern match s e r h anchor + pattern end text length thread interrupt interrupt po pattern end po 0 po ch text at po + anchor ignore ch character upper ch pattern test reverse ? ch pattern pattern end po ch pattern po character mismatch determine how many character skip heuristic 1 bad po skip get skip index ch heuristic 2 good suffix suffix po skip great two distance provide heuristic skip index bad good suffix ? bad good suffix anchor + skip index go back loop s e r h m t h position it first character anchor m i s m t h 1 define p i 1 boy moore search matcher + pattern + + ignore + member pattern pattern end ignore boy moore member field fwd skip fwd suffix back skip back suffix boy moore helper generate skip skip use determine each index hash alphabet how many character skip mismatch occur on characat hash index generate skip reverse initialize skip all zero skip 256 leave table cleanly initialize an empty pattern pattern length 0 skip po 0 skip get skip index pattern reverse ? pattern end po po po ++po pattern length skip get skip index avoid our skip table have length 2 ^ 16 we hash each character input into character alphabet \x00 \x f f using lower 8 bit character s value result reasonable skip table length 2 ^ 8 result than one character hash same index since skip table encode position occurence character furthest into index wheth only character index an index collision only mean heuristic give sub optimal skip i e complete skip table could use difference between collide character maximal effect at expense building table over 2 order magnitude large very sparse get skip index ch ch 0x000000 f f generate suffix x x x hairy basically just functional ? port some other i barely understand generate suffix reverse m pattern length j m + 1 suffix j tmp j tmp m j i m i 0 i j m pattern reverse ? pattern end i + 1 i 1 pattern reverse ? pattern end j + 1 j 1 suffix j 0 suffix j j i j tmp j tmp i 1 j k tmp 0 j 0 j m j++ above build 1 index suffix we shift 0 index ignore original 0 th element j 0 suffix j 1 suffix j 0 ? k suffix j j k k tmp k suffix 