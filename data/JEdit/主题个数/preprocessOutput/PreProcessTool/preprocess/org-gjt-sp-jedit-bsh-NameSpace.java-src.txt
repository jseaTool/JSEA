part bean shell script distribution documentation update may found at http www beanshell sun notice content are subject sun 1 0 may use except compliance available at http www sun com original bean shell initial developer original pat niemey create pat niemey are 2000 all right reserve g n u notice alternatively content may use g n u less l g p l which provision l g p l are applicable instead those above wish allow use your only l g p l allow other use your s p l indicate your decision delete provision above replace them notice other provision require l g p l delete provision above recipient may use your s p l l g p l patrick niemey pat pat net learning o reilly associate http www pat net pat bsh io input stream io input stream reader io i o reflect reflect field namespace which variable name live because use some bsh command howev normal use using on bsh interpreter interact your script p bsh thin layer over name space associate an interpreter instance together they comprise bsh script context p note i d really like use collection here we keep compatible j d k1 1 thanks j edit fame cache enhancement note ha get too big down bit suppres warning uncheck name space io serializable bsh listener name source name space j v o d e name space bsh call from compile j v o d e begin instance data note we add someth here we reset clear name namespace namespace body namespace then name s instance then s name n name name space parent hashtable variable hashtable hashtable vector vector command vector vector name bsh note get reference name resolv hashtable name node associate creation namespace use support get invocation line get invocation text simple node caller info node note namespace body namespace use printing stack trace note namespace body instance namespace use control precedence etc note we ll move behavior out subclass name space we ll start here instance set cla cla cla set instance instance instance instance instance get instance eval instance instance || get parent get parent eval t refer instance from context interpreter t resolve instance +thi local cache resolve through namespace using get taking into account only unqualifi name are cache here those which might qualify name are alway absolute are cache bsh hashtable cache end instance data begin constructor parent parent namespace namespace child namespace inherit all variable their parent course override shadow them name name name space name space parent name note parent must parent name name space bsh name name name space name space parent bsh name we might want here rath than explicitly interpreter global also prune parent create our own manager? set name name set parent parent set register notification classload change add listener end constructor set name name n name name name namespace namespace body namespace then name s instance then s name get name n name set node associate creation namespace use debug support get invocation line get invocation text set node simple node node caller info node node simple node get node caller info node caller info node parent parent get node resolve name an through namespace get name interpreter interpreter eval call stack callstack call stack get name resolv name callstack interpreter set variable through namespace obey l o l s o p i n g property determine how variable are set p note primarily intend use internally use outside bsh wish set variable primitive value wrap them using bsh primitive bsh primitive p setting variable which didn t before remove variable cause namespace change strict specifie wheth strict rule are apply set variable name value strict eval localscop follow strict recurse recurse interpreter l o l s o p i n g ? strict set variable name value strict recurse set variable explicitly local scope set local variable name value strict eval set variable name value strict recurse set value variable name through namespace variable may an non variable may live namespace parent namespace recurse p note doe know about l o l s o p i n g it caller must set recurse intelligently all situation perhap base on l o l s o p i n g p note primarily intend use internally use outside bsh wish set variable primitive value wrap them using bsh primitive bsh primitive p setting variable which didn t before remove variable cause namespace change strict specifie wheth strict rule are apply recurse determine wheth we search variable our parent s scope before assigning locally set variable name value strict recurse eval variable variable hashtable primitive be wrap j edit change value interpreter variable value value t j edit core plugin unset variable name locate variable definition variable get variable impl name recurse found an variable here above recurse allow set value value variable s s i g n m e n t eval e eval variable assignment + name + + e get message no previou variable definition found here above recurse strict eval strict mode assignment undeclar variable +name recurse set global untyp var set here name space var scope recurse ? get global modification make allocation local name space var scope var scope variable put name variable name value modifier name space change on variable addition name space change remove variable from namespace unset variable name variable variable remove name name space change get name variable define namespace doe show variable parent namespace get variable name variable 0 enumeration variable key get name declare namespace doe include parent namespace get name 0 enumeration key get define namespace doe show parent namespace note probably rename get declare bsh get bsh 0 flatten collection element enumeration enumeration e vector v vector e ha element v add element e next element sa v size v into sa sa flatten vector overload single get bsh flatten collection enumeration e vector v vector e ha element o e next element o bsh v add element o vector ov vector o i 0 i ov size i++ v add element ov element at i bsh bma bsh v size v into bma bma get parent namespace note isn t quite same get get we are at root namespace name space get parent parent get parent namespace reference namespace reference we are top get interpreter declare interpreter parent parent get declare interpreter get declare interpreter get top level namespace namespace we are top note probably type bsh consistent get get global interpreter declare interpreter parent parent get global declare interpreter get declare interpreter thin layer over namespace comprise bsh context handle thing like type bsh support aspect invocation on p declare interpreter here support callback from through generate proxy script remember who create thing like printing message other p interpreter phenomenon when call externally from note we need singleton here so thing like work probably good idea speed cache single instance here seem technically incorrect consider declare interpreter could different some circumstance child interpreter running source eval command howev effect just interpreter execute your script one involve call back from i know there are corner where child interpreter would first use reference namespace would cause problem we could some experiment find out necessary we could cache on p interpreter basis we have weak reference we might also look at skip over child interpreter going parent declare interpreter so we d sure get top interpreter get interpreter declare interpreter reference reference get declare interpreter reference bsh get parent parent j v o d e parent get out experiment create bsh create interp interpreter debug no namespace +thi set bsh use serialization prune cut off from parent we must our own t run command need resolve stuff we when we create namespace no parent manager? x x x we keep create get then we axe this? set bsh create interp set parent set parent name space parent parent parent we are disconnect from root we need handle def parent load get specify variable namespace parent namespace p note primarily intend use internally use outside bsh use primitive unwrap get primitive value primitive unwrap variable value primitive v o define get variable name eval get variable name get specify variable namespace recurse recurse then we recursively search through parent namespace variable p note primarily intend use internally use outside bsh use primitive unwrap get primitive value primitive unwrap variable value primitive v o define get variable name recurse eval variable var get variable impl name recurse unwrap variable var locate variable variable optional recursion through parent name space p namespace only variable variable value define variable get variable impl name recurse eval variable var change precedence we are body instance get first var var get var name var variable var variable variable get name change precedence we are body instance var var get var name parent recurse var parent var parent get variable impl name recurse var get variable declare namespace variable get declare variable variable variable 0 variable var variable variable size i 0 enumeration e variable element e ha element var i++ variable e next element var unwrap variable it value variable value var map primitive v o unwrap variable variable var eval var ? primitive v o var get value deprecate set type variable modifier set type variable name type value eval modifier modifier modifier modifier add modifier modifier f i e l d set type variable name type value modifier declare variable local scope set it initial value value may indicate we would like value variable type e g 0 type type an type variable may only set same type an untyp variable same name override type var set perform type get assignable form on value necessary p note primarily intend use internally use outside bsh wish set variable primitive value wrap them using bsh primitive bsh primitive value value ll get value type modifier may set type variable name type value modifier modifier eval check variable modifier name modifier variable variable hashtable setting type variable alway local operation variable get variable impl name recurse value just declaration note we might want keep value here instead reset move variable value value primitive get value type doe variable already exist? typed? get type have different type allow declare same var again different assignable type get type type eval type variable +name + wa previously declare type + get type set set value value variable d e l r t i o n careful here fall through override install type add type var variable put name variable name type value modifier dissallow var outside name here just allow message use check variable modifier name modifier modifier eval modifier modifier ha modifier eval t declare variable outside +name note primarily internal use interpreter source interpreter eval set name bsh eval check modifier hashtable m get name j edit properly handle same signature m put name m bsh override old method? equal bsh m get parameter type get parameter type put name vector v vector v add element m v add element put name v vector vector m i 0 i size i++ check wheth some old list bsh old m bsh get i equal old m get parameter type get parameter type remove i add element original bean shell m put name m bsh vector v vector v add element m v add element put name v vector vector m add element get get bsh get name sig eval get name sig declare only get bsh match specify signature declare name space parent p note primarily intend use internally use outside bsh familiar bean shell s use primitive wrapper bsh primitive bsh found declare only then only declare directly namespace found no inherit visible bsh get name sig declare only eval bsh change precedence we are body instance get first declare only get name sig m m get name m contain bsh vector bsh m unwrap bsh m vector vector vm vector m bsh vm size vm into bsh bsh m apply most specific signature match candidate length i 0 i length i++ candidate i i get parameter type match reflect find most specific signature sig candidate match 1 match declare only get name sig parent declare only parent parent get name sig name subsequent override earlier one name hashtable put name suffix name 1 name name space change subsequent override earlier one name vector remove add at end avoid memory leak contain name remove name add element name name space change script compile bean shell command following classpath may use path notation e g command bsh command command bsh command are equivalent relative path style specifier use then make into an absolute path prepend command name command command vector dot slash name name replace absolute name start name +name remove trailing preserve simple name length 1 name end name name substring 0 name length 1 remove add at end avoid memory leak command contain name command remove name command add element name name space change command script compile command implement specify signature command are load from classpath may using command p search command script command correspond name script script source into namespace bsh request signature compile compile command implement p are search reverse order so take priority currently only first script appropriate name check another overload form locate another currently found could fix p bsh no such command found name name desire command type signature desire command eval load script command eval i e on loading script wa found j edit s get command get command name type interpreter interpreter eval interpreter d e b u g interpreter debug get command +name bsh bcm interpreter get input stream get command name load script command name type name interpreter chop leading change name path equal name name name path substring 1 replace + +name cla bcm name name cla cla parent parent get command name type interpreter get command name type interpreter interpreter eval interpreter d e b u g interpreter debug get command +name bsh bcm interpreter get command loop backward precedence i command size 1 i 0 i path command element at i script path path equal script path path + name + bsh script path path + + name + bsh interpreter debug search script +script path input stream bcm get resource stream script path load script command name type script path interpreter chop leading change name path equal name name name path substring 1 replace + +name interpreter debug search +clas name cla bcm name name cla cla parent parent get command name type interpreter bsh get name sig eval i 0 i size i++ element at i cla get reflect resolve get cla name sig only bsh i 0 i size i++ cla element at i reflect resolve get cla name sig only bsh variable get var name eval i 0 i size i++ element at i cla get field field reflect resolve field cla name only field variable name field get type l h s field i 0 i size i++ cla element at i field field reflect resolve field cla name only field variable name field get type l h s field load command script from input stream find bsh target namespace eval on parse script found after parse script we want support multiple command command path we need change bsh load script command input stream name type resource path interpreter interpreter eval interpreter eval input stream reader resource path eval e here we eval from interpreter because we are using tool load command part execution path interpreter debug e eval loading script + e get message look load command bsh meth get name type meth eval load resource + resource path + have an contain correct meth helper cache cache name cache cache hashtable cache count++ debug cache put name load through namespace taking into account search proceed through parent namespace necessary found get name eval get impl name implement recursion get impl parent parent get name get load through namespace taking into account p check cache first an unqualifi name look load absolute name p cache unqualifi name normally qualify name are cache bsh unqualifi absolute name e g unpackag foo are cache too so we t go search through them each time found get impl name eval check cache cache cache get name unqualifi simple non compound name unqualifi name name compound name unqualifi name check unqualifi name get impl name found also cache cache name absolute name name cache unqualifi name prevent check again unqualifi name cache name found interpreter d e b u g interpreter debug get + name + found +thi make name into an take into account only found directly name space no parent chain get impl name eval explicitly e g foo bar fullname fullname get name sure we really recurse here explicitly parent fullname found full name make full name cla name fullname handle inner cla full name wasn t found an absolute compound resolve an inner maybe happen bsh manager? name compound fullname cla get name resolv fullname found e interpreter d e b u g interpreter debug unpackag name found +fullname found cache full name bsh cla we cache info too? get cache info fullname cla cla cla wa explicitly we t know what we an here?? e g foo bar reverse order give precedence i size 1 i 0 i s element at i + + name name s bsh bcm get available note we last allow explicitly take priority also an indicate ambiguity bcm ha s bcm get name unq name name s name s name name get name name name source all variable name all parent namespace get all name vector vec vector get all name aux vec name vec size vec into name name helper implement name source get all name aux vector vec enumeration var name variable key var name ha element vec add element var name next element enumeration name key name ha element vec add element name next element parent parent get all name aux vec vector name source listener name source add listener who notify upon change name space add name source listener name source listener listener name source listener name source listener vector name source listener add element listener perform causing entire classpath map take eval get name space + n name ? n name + + + + ? + ? + ? + instance ? instance serialization t serialize non serializable io output stream s i o clear name resolver t know necessary name s namespace specify interpreter reference no caller information call stack require appear call externally from p bsh name interpreter interpreter call stack callstack simple node caller info name interpreter interpreter eval name interpreter simply delegate p bsh name interpreter interpreter call stack callstack simple node caller info declare only name interpreter interpreter call stack callstack simple node caller info eval get interpreter name interpreter callstack caller info declare only clear all cache name loader change name space change clear all cache name name space change cache name standard currently pre bsh eval bsh interpreter event event net io add command path bsh command get pre load note resolv look through these reverse order p precedence rule so max efficiency put most common one bsh eval bsh interpreter event event net io add command path bsh command get factory name which resolve name within namespace e g l h s p wa intend support name resolv cache allow name cache info about resolution name performance reason howev prove yet p we ll leave cache at least minimize name creation p would call get name weren t already use simple name name space p wa time which wa mistake use get instead name get name resolv ambigname name name hashtable name name name name get ambigname name name name ambigname name put ambigname name name get invocation line simple node node get node node node get line number 1 get invocation text simple node node get node node node get text from helper working inside bsh script command context impossible identifier what attempt access on identifier look like invocation name space convenience t bsh identifier use identifier identifier ci ci get target clear all variable from namespace namespace root reset load clear variable command parent load cache name compile s variable into namespace when no script command variable found locally namespace field check are check order taking precedence p note impor pattern become common could factor out into an vector obj vector remove add at end avoid memory leak contain obj remove obj add element obj name space change cla vector remove add at end avoid memory leak contain cla remove cla add element cla name space change set name define namespace subsequent set override set name name name get name name parent parent get j edit addition set variable name value eval set variable name value add u r l command path add command path path cla command command vector path end path + command add element command path entry path cla remove u r lfrom command path remove command path path cla command i 0 i command size i++ command path entry entry command path entry command element at i entry path equal path entry cla cla command remove element at i look up command input stream get command name command ext name name + bsh i command size 1 i 0 i command path entry entry command path entry command element at i input stream entry cla get resource stream entry path + ext name parent parent get command name command path entry path cla command path entry path cla path path cla cla 