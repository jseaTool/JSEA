part bean shell script distribution documentation update may found at http www beanshell sun notice content are subject sun 1 0 may use except compliance available at http www sun com original bean shell initial developer original pat niemey create pat niemey are 2000 all right reserve g n u notice alternatively content may use g n u less l g p l which provision l g p l are applicable instead those above wish allow use your only l g p l allow other use your s p l indicate your decision delete provision above replace them notice other provision require l g p l delete provision above recipient may use your s p l l g p l patrick niemey pat pat net learning o reilly associate http www pat net pat bsh reflect reflect invocation target inner style allocation body b s h allocation expression simple node b s h allocation expression inner count 0 eval call stack callstack interpreter interpreter eval type name primitive type simple node type simple node jjt get child 0 constructor argument dimension simple node simple node jjt get child 1 type b s h ambiguou name b s h ambiguou name name b s h ambiguou name type b s h argument allocation name b s h argument callstack interpreter allocation name b s h dimension callstack interpreter primitive allocation b s h primitive type type b s h dimension callstack interpreter allocation b s h ambiguou name name node b s h argument argument node call stack callstack interpreter interpreter eval name space namespace callstack top argument node get argument callstack interpreter eval callstack look script obj name node callstack interpreter force regular obj name node callstack interpreter force type obj identifier type identifier obj get target eval unknown +name node text callstack an inner style allocation ha body jjt get num child 2 ha body b s h block body b s h block jjt get child 2 type construct body type body callstack interpreter construct body type body callstack interpreter construct type callstack construct type call stack callstack eval obj obj reflect construct type reflect e eval constructor + e get message callstack invocation target e no need wrap debug interpreter debug constructor an + e get target target constructor e get target callstack name type get name an inner class? name index 1 obj temporary hack support inner obj non inner then context sufficient emulation inner replace work through th callstack top get name space instance name space name get name space th get name space change parent which wa instance we really need check we re inner here first some reason won t show modifier on our fake inner could generate flag field instance name space name start instance name space get name + generator get generator set instance name space parent obj name instance name space eval e e eval callstack obj construct body type b s h block block call stack callstack interpreter interpreter eval name callstack top get name + + ++inn count modifier modifier modifier modifier add modifier modifier l s s cla cla generator get generator generate name modifier type block callstack interpreter eval e e eval callstack reflect construct cla e e invocation target e invocation target e get target eval construct inner instance +e callstack construct body type b s h block body call stack callstack interpreter interpreter eval name space namespace callstack top name space local name space namespace anonymou block callstack push local body eval callstack interpreter override namespace callstack pop statical field from so inside refer field directly e g h e i g h t local type local get interpreter get type eval e e eval callstack allocation b s h ambiguou name name node b s h dimension dimension node call stack callstack interpreter interpreter eval name space namespace callstack top type name node callstack interpreter type eval + name node get name namespace + found callstack allocation dimension node type callstack interpreter primitive allocation b s h primitive type type node b s h dimension dimension node call stack callstack interpreter interpreter eval type type node get type allocation dimension node type callstack interpreter allocation b s h dimension dimension node type call stack callstack interpreter interpreter eval dimension node fully intializ v o when v o prescribe dimension define undefin are contain node result dimension node eval type callstack interpreter result primitive v o result instance type dimension node callstack create an dimension specify dimension node dimension node may contain number undefin well define dimension p background are style where example two dimensional an some base type each dimension type ha type associate so foo 5 5 then type foo type foo 0 etc may also specify undefin trailing dimension meaning lower order are allocate e g foo 5 then foo 0 assign appropriate type e g foo 0 5 learning o reilly associate background p create an undefin trailing dimension using reflection p i we must use an type represent lower order undefin dimension base type creation then create correct type add dimension base type specify allocate dimension yielding an dimensionality base + specify base dimenson unallocat create base type we simply create prototype zero length each dimension use get it actually i think there way we could name i t trust simple than explanation below instance type b s h dimension dimension node call stack callstack eval dimension node num undefin dim 0 proto instance type dimension node num undefin dim zero type proto get instance type dimension node define dimension negative size e1 target e1 callstack e eval t construct primitive + e get message callstack 