part bean shell script distribution documentation update may found at http www beanshell sun notice content are subject sun 1 0 may use except compliance available at http www sun com original bean shell initial developer original pat niemey create pat niemey are 2000 all right reserve g n u notice alternatively content may use g n u less l g p l which provision l g p l are applicable instead those above wish allow use your only l g p l allow other use your s p l indicate your decision delete provision above replace them notice other provision require l g p l delete provision above recipient may use your s p l l g p l patrick niemey pat pat net learning o reilly associate http www pat net pat bsh net io i o io reflect reflect modifier bsh manage all classload bean shell also support dynamically load extension bsh classpath which allow classpath extension reload currently extension relie on 1 2 bsh loader weak reference http www beanshell manual classload html on bsh classload architecture p bsh ha multi tier loading architecture no loader use unles until classpath modify reload p note note we may need some synchronization here note on dependency base j d k 1 1 compatible howev we are force use weak reference full feature optional bsh classpath accomodate all fleet namespace listener they fall out scope name space must inform space change so they un cache name p perhap simple idea would entity reference cache type alway perform light weight check counter reference value use detect change namespace put burden on consumer check at appropriate time could eliminate need listener many place necessity weak reference p suppres warning uncheck bsh identifier no value item use hashtable set n o v l u e interpreter which create use load script from source interpreter declare interpreter an external classload supply set loader command loader external loader global cache thing we know are note these probably re soft reference oppose strong weak hashtable absolute cache hashtable global cache thing we know are note these probably re soft reference oppose strong weak hashtable absolute non hashtable cache resolve we keep these map separate support fast lookup where may hashtable resolve hashtable hashtable resolve hashtable hashtable defining hashtable hashtable defining base name hashtable create instance instnace are now associate interpreter bsh interpreter get get bsh interpreter set loader loader set loader bsh create interpreter interpreter bsh we necessary jdk1 2 optional package? capability ref weak reference capability hash map capability bsh classpath impl load module t refer directly here we re dependent upon cla name bsh classpath impl bsh cla instance e interpreter loading classmanag +e bsh interpreter interpreter interpreter declare interpreter interpreter name name name load specify name taking into account add classpath reload etc note again just trivial bsh classpath impl fully functional management name name being define name interpreter attempt load process being define +name cla cla plain name name found e ignore script cla cla load source name cla move me classpath impl??? load source name name +name replace + input stream get resource stream name out loading from source +file name declare interpreter eval input stream reader eval e ignore err e plain name name found e err found source +name perform plain name call externally provide classload bsh load call delegate allow additional hook p simply wrap bottom level lookup call provide central point monitoring handling certain dependent bug etc name plain name name found external loader external loader load name name name cache info name original note jdk win these warn about lower upper possible mismatch e g bsh console bsh console update prior 1 3 we be squeltch no def found which wa very annoying i cannot reproduce original problem wa nev valid solution there are legacy v m problem we include specific test them here no def found e no def found name e get resource u r l using bean shell classpath path an absolute path u r l get resource path u r l url external loader classload want no leading slash url external loader get resource path substring 1 url url interpreter get resource path url get resource stream using bean shell classpath path an absolute path input stream get resource stream path input stream external loader classload want no leading slash external loader get resource stream path substring 1 interpreter get resource stream path cache info about wheth name value value non cache value set flag speed resolution cache info name value value absolute cache put name value absolute non put name n o v l u e cache resolve possibly overload base on argument type use subject classload change are cache separately support fast lookup where cache resolve cla type interpreter d e b u g interpreter debug cache resolve putting + cla + + signature key sk signature key cla get name type modifier get modifier resolve put sk resolve put sk previously cache resolve only specifie only may get resolve cla name type only signature key sk signature key cla name type then allow note compiler allow both resolve get sk only resolve get sk interpreter d e b u g interpreter debug get resolve cache m i s s + cla + +method name interpreter debug get resolve cache h i t + cla + +method clear cache bsh clear cache absolute non hashtable absolute cache hashtable resolve hashtable resolve hashtable set an external loader bean shell use at same point would otherwise use plain name i e no classpath management from script add path set path reload then bean shell only use supply classload additional classpath management then bean shell perform addition supply external classload howev bean shell currently able reload supply through external classload set loader loader external l external loader external l loader change add path u r l path i o clear all loader start over no loading reset clear cache set base classpath create base classload mean all type change set path u r l cp eval cm unavailable overlay entire path loader set base path user path + base path no point include boot path t reload tho reload all eval cm unavailable reload mean create classload using whenev we are ask appropriate space we use discrete loader reload name eval cm unavailable reload all specify e g com sun tool special name lt unpackag use refer unpackag reload pack eval cm unavailable ha be remove from shield core from rest classpath need classpath cast classmanag it impl bsh path get path path support hide here oppose name space eval cm unavailable operation ha be perform ha name none found an path contain detail name ambigou get name unq name name eval cm unavailable add listener listener l remove listener listener l dump print writer pw pw bsh no flag name being process being define attempt load note temporary we currently keep flat namespace base name i e bean shell cannot process defining two different same base name remove limitation require we work through namespace an analogou using same path regular resolution workaround handle most so we ll now defining name base name name suffix name 1 i base name index i 1 base name base name substring i+1 cur defining base name get base name cur interpreter defining problem +clas name + bean shell cannot yet simultaneously define two + dependant same name attempt define + name + defining +cur defining put name n o v l u e defining base name put base name name being define name defining get name temporary workaround use defining remove at some point get being define name base name name suffix name 1 defining base name get base name indicate specify name ha be define may load normally defining name base name name suffix name 1 defining remove name defining base name remove base name real classpath impl handle reload generate define name interpreter t create +name + old inject into parent classload wa incorrect behavior several reason big problem could therefore only define once acros all execution script loader cl get get loader cla cla reflect cl define name primitive 0 offset primitive length len interpreter call stack simple node e e print stack trace interpreter unable define + e absolute non remove name may be ax previously cla loader change annotate no def found some info about we be load no def found name e no def found require +clas name + could load +e eval cm unavailable capability unavailable loading feature unavailable listener loader change signature key serve hash signature on fast lookup overload resolve p note using signature key way dangerous? pathological user could eat up memory cache every possible combination argument type an untyp maybe we could smart about ignore type untyp parameter positions? resolv could set hint signature key caching? there also overhead create one these every dispatch what alternative? signature key cla type name hash 0 signature key cla name type cla cla name name type type hash hash 0 hash cla hash name hash type no hash i 0 i type length i++ hc type i ? 21 type i hash hash hash i+1 + hc hash equal o signature key target signature key o type target type cla target cla name equal target name type length target type length i 0 i type length i++ type i target type i type i equal target type i 