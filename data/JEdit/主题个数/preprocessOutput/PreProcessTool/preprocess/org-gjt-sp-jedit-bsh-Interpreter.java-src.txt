part bean shell script distribution documentation update may found at http www beanshell sun notice content are subject sun 1 0 may use except compliance available at http www sun com original bean shell initial developer original pat niemey create pat niemey are 2000 all right reserve g n u notice alternatively content may use g n u less l g p l which provision l g p l are applicable instead those above wish allow use your only l g p l allow other use your s p l indicate your decision delete provision above replace them notice other provision require l g p l delete provision above recipient may use your s p l l g p l patrick niemey pat pat net learning o reilly associate http www pat net pat bsh io reflect reflect invocation target bean shell script interpreter an instance interpreter use source script evaluate statement expression p here are some example p blockquote pre interpet bsh interpreter evaluate statement expression bsh eval foo math sin 0 5 bsh eval bar foo 5 bar math co bar bsh eval i 0 i lt 10 i++ print \ hello\ same above using syntax apis only bsh eval i 0 i lt 10 i++ out \ hello\ source from stream bsh source myscript bsh bsh eval source \ myscript bsh\ use set get pas out variable bsh set date date date date date bsh get date would also work date date date bsh eval date bsh eval year date get year year bsh get year primitive use wrapper java1 3+ script implement arbitrary script an event handler source from likely bsh eval action perform e print e get reference script implement action listener script handler action listener bsh eval action listener use script event handler normally j button add action listener script pre blockquote p above example we show single interpreter instance howev may wish use many instance depend on application how structure your script interpreter instance are very light weight create howev are going execute same script repeatedly require maximum performance consider script script each time on same interpreter instance using eval p bean shell user s manual information interpreter runnable console serializable begin member v e r s i o n 2 0b4 debug util are so they are reachable doesn t necessarily an interpreter reference e g tracing util future we may want allow debug trace turn on on p interpreter basis which we ll need use parent reference some way determine scope command turn on off d e b u g t r e l o l s o p i n g p instance print stream debug line separator init share visible bsh share strict mode set strict strict end member instance data parser parser name space global name space reader print stream out print stream err console console interpet child another parent interpreter parent name other source interpreter reading source info interactive mode exit on e o f exit on e o f eval only interpreter ha no input stream use eval only interactive interpreter ha user print prompt etc control verbose printing result show command show result end instance data constructor all constructor now pas through here namespace namespace non then interpreter s root namespace set one provide one create parent parent interpreter interpreter child another may child share bsh their parent instance source info an informative holding filename other description source from which interpreter reading use debug may interpreter reader print stream out print stream err interactive name space namespace interpreter parent source info out interpreter +thi + sourcefile +source info parser parser t1 current time milli out out err err interactive interactive debug err parent parent parent set strict parent get strict source info source info bsh bcm bsh create namespace global name space name space bcm global global name space namespace now name space automatically when root which are global name space load create root bsh doesn t getu bsh bsh init root interactive load r t2 current time milli interpreter d e b u g interpreter debug time initialize interpreter + t2 t1 interpreter reader print stream out print stream err interactive name space namespace out err interactive namespace interpreter reader print stream out print stream err interactive out err interactive construct interactive interpreter attach specify console using specify parent namespace interpreter console console name space global name space console get console get out console get err global name space set console console construct interactive interpreter attach specify console interpreter console console console create an interpreter evaluation only interpreter reader out err eval only setu bsh eval only primitive end constructor attach console note incomplete set console console console console console setu bsh console console redundant constructor set out console get out set err console get err need set input stream reinit parser? init root bsh bcm get bsh setu bsh name space bcm bsh get init share share s there yet share share name space bcm bsh share get bsh setu bsh share setu bsh share share alias bsh help help text name space bcm bsh command help text get setu bsh help help text bsh cwd setu bsh cwd get property user dir security e applet t sy prop setu bsh cwd bsh interactive setu bsh interactive primitive interactive bsh eval only setu bsh eval only primitive eval only set global namespace interpreter p note here completeness re using lot may an indication are work than example cache interpreter instance rath than namespace add significant overhead no state other than debug status store interpreter p all feature namespace also access using interpreter via eval script variable namespace global namespace necessary set name space name space global name space global name space global name space get global namespace interpreter p note here completeness re using lot may an indication are work than example cache interpreter instance rath than namespace add significant overhead no state other than debug status store interpreter p all feature namespace also access using interpreter via eval script variable namespace global namespace necessary name space get name space global name space run text only interpreter on command line specify length 0 filename 0 bsh length 1 bsh length 1 arraycopy 1 bsh 0 length 1 bsh 0 interpreter interpreter interpreter out run i +interpret interpreter setu bsh bsh result interpreter source filename interpreter global name space result result bsh e o e e invocation target o invocation target e get target err +result+ +o found e out found +e target e out script +e e e print stack trace d e b u g err eval e out evaluation +e i o e out i o +e workaround j d k bug 4071281 where available too large value bug ha be fix j d k 1 2 input stream src get property o name start window get property start 1 1 src filter input stream available i o 0 src reader command line reader input stream reader src interpreter interpreter interpreter out err interpreter run cla reflect resolve bsh cla only run interactively printing prompt etc run eval only runtime bsh interpreter no stream we ll print our banner using eval order exercise parser get basic expression load ameliorate delay after typing first statement interactive eval print banner eval e bean shell + v e r s i o n+ pat niemey pat pat net init callstack call stack callstack call stack global name space eof eof sync up console out flush err flush thread yield help little interactive print get bsh prompt eof line get jjtree node arity 0 number child node simple node node simple node get jjtree root node d e b u g node dump ret node eval callstack sanity check dur development callstack depth 1 interpreter callstack growing +callstack ret control ret control ret value ret primitive v o setu ret show result + ret + parse e parser + e get message d e b u g d e b u g e print stack trace interactive eof parser re init input interpreter e internal + e get message e print stack trace interactive eof target e uncaught + e e e print stack trace d e b u g err interactive eof setu e e get target eval e interactive eval +e eval +e get message d e b u g e print stack trace interactive eof e unknown + e d e b u g e print stack trace interactive eof token mgr e parse input + e we get stick infinite loop here when unicode escape fail must re init stream reader s i i u e s stream parser re init token input interactive eof get jjtree reset reinit callstack callstack depth 1 callstack clear callstack push global name space interactive exit on e o f exit 0 begin source eval read text from name eval source filename name space name space found i o eval path filename interpreter d e b u g debug source +file reader source buffer reader reader eval source name space filename source close read text from name eval convenience use global namespace source filename found i o eval source filename global name space spawn non interactive local interpreter evaluate text specify namespace value evaluate correspond primitive wrapper source info information purpose only use display message future may make available script eval on script problem target on unhandl from script note we need form eval pass callstack through t combine run ? run seem stuff interactive v non interactive compare them side side what they differently aside from handling eval reader name space name space source info call stack callstack eval ret val interpreter d e b u g debug eval name space +name space create non interactive local interpreter namespace source from input stream out err same interpreter interpreter local interpreter interpreter out err name space source info call stack callstack call stack name space eof eof simple node node eof local interpreter line local interpreter get jjtree node arity 0 node simple node local interpreter get jjtree root node node remember from where they be source node set source source info t r e +node get text ret val node eval callstack local interpreter sanity check dur development callstack depth 1 interpreter callstack growing +callstack ret val control ret val control ret val value non interactive control now local interpreter show result ret val primitive v o + ret val + parse e eval source +source info+ parser + e get message d e b u g node callstack d e b u g show extra expect info e get message d e b u g add source info again e set source source info e interpreter e e print stack trace eval source +source info+ internal + e get message node callstack target e failsafe set line origin e get node e set node node e re source +source info eval e d e b u g e print stack trace failsafe set line origin e get node e set node node e re source +source info e d e b u g e print stack trace eval source +source info+ unknown + e get message node callstack token mgr e eval source +source info+ token parse + e get message node callstack local interpreter get jjtree reset reinit callstack callstack depth 1 callstack clear callstack push name space primitive unwrap ret val evaluate inputstream interpreter s global namespace eval reader eval eval global name space eval stream evaluate interpreter s global namespace eval statement eval interpreter d e b u g debug eval +statement eval statement global name space evaluate specify namespace eval statement name space name space eval s statement end ? statement statements+ eval reader s name space inline evaluation `` + show eval s + show eval s s s replace s s replace \r s length 80 s s substring 0 80 + s end source eval print an message standard format on output stream associate interpreter on g u i console appear red etc o console console + o + err + o err flush console interpreter reflexively console us clean up using an inner implement console u get input stream associate interpreter may stdin g u i console reader get get outptut stream associate interpreter may stdout g u i console print stream get out out get output stream associate interpreter may stderr g u i console print stream get err err o print value o + line separator print o console console print o out print o out flush end console print debug message on debug stream associate interpreter only debug turn on debug s d e b u g debug debug + s primary interpreter set get variable note these are squeltch they? get value name name may value e g variable field get name eval ret global name space get name primitive unwrap ret eval e e eval simple node j v o d e call stack uncheck get internal use getu name get name eval e interpreter set +e assign value name name may evaluate anyth assignable e g variable field set name value eval map primtive n u l l coming value value primitive n u l l call stack callstack call stack name compound name l h s lh global name space get name resolv name l h s callstack lh assign value optimization common global name space set variable name value eval e e eval simple node j v o d e callstack uncheck set internal use setu name value set name value eval e interpreter set +e set name value eval set name primitive value set name value eval set name primitive value set name value eval set name primitive value set name value eval set name primitive value set name value eval set name primitive value unassign variable name name evaluate variable unset name eval we jump through some hoop here handle arbitrary like unset bsh foo call stack callstack call stack l h s lh global name space get name resolv name l h s callstack lh type l h s v r i b l e eval t unset variable +name simple node j v o d e call stack lh assign lh name space unset variable name eval e eval e get message simple node j v o d e call stack end primary set get get reference interpreter global namespace cast specify type assume appropriate are define interpreter then may use from just like other p example pre interpreter interpreter interpreter define call run interpreter eval run fetch reference interpreter runnable runnable runnable runnable interpreter get runnable pre p note interpreter doe require all define at time generate howev attempt one define get runtime p note also convenience ha exactly same effect evaluate script pre type pre p example following identical previou example p pre fetch reference interpreter runnable runnable runnable runnable interpreter eval runnable pre p em requirement em although standard type are alway available use arbitrary feature require are using 1 3 great p eval cannot generate because doe support proxy mechanism get interf eval global name space get get interf eval e e eval simple node j v o d e call stack interact parser j j t parser state get jjtree parser jjtree stream get jj input stream parser jj input stream line parse parser line end interact parser load r rcfile \window win98 h o m e unix get property user home + separator + bshrc source rcfile global name space e squeltch security filenotfoundexception interpreter d e b u g debug could find rc +e localize path name base on bsh cwd interpreter working directory path name i o name relative fix up bsh cwd absolute cwd getu bsh cwd cwd + separator + name canonical name also absolute no need get absolute path here get canonical path redirect output filename print stream pout print stream output stream filename set out pout set err pout i o e err t redirect output +filename set an external loader use base classload bean shell base classload use all classload unles until add classpath set classpath reload command are call interpreter s classpath at time path update path are add on top base classload p bean shell use at same point would otherwise use plain name i e no classpath management from script add path set path reload then bean shell only use supply classload additional classpath management then bean shell perform addition supply external classload howev bean shell currently able reload supply through external classload p bsh set loader loader set loader loader external l get set loader external l get associate interpreter bsh interpreter s global namespace primarily convenience bsh get get name space get set strict mode on off mode attempt make bean shell syntax behave syntax eliminate convenience like loose variable etc when enable variable are require declare initialize before use argument are reqir type p mode become strict future release when are interpret there an alternative script closure set strict b strict b set strict get strict strict init apparently some environment t security at all e g an applet i e probably work around line separator get property line separator debug err d e b u g get debug t r e get trace l o l s o p i n g get localscop outfilename get property outfile outfilename redirect output outfilename security e err could init +e e err could init 2 +e throwable e err could init 3 +e specify source text from which interpreter reading note there difference between what interrpet source from what wa originally parse one may call source from another simple node origination info bsh simple node get source get source info source info source info unknown source get parent interpreter interpreter currently relationship implie following 1 parent child share bsh 2 child indicate parent s source information reporting when create part source eval child also share parent s namespace necessary interpreter get parent parent set out print stream out out out set err print stream err err err de serialization setup out err stream stdout stderr they are read input stream stream io i o found stream read set field console set out console get out set err console get err set out out set err err get prompt define get bsh prompt global namespace may from get bsh prompt command may define user other bsh % define there an get bsh prompt eval get bsh prompt e bsh % specify wheth interactive mode interpreter exit upon end input when interactive mode interpreter issue exit 0 upon eof interpreter no exit p note wish cause an e o f externally closing input stream guarantee work old due limitation work j d k j r e wa motivation n i o set exit on e o f value exit on e o f value ug turn on off verbose printing result show command interpreter ha parent call delegate bean shell show command set show result show result show result show result show on off verbose printing status show command bean shell show command interpreter ha parent call delegate get show result show result 