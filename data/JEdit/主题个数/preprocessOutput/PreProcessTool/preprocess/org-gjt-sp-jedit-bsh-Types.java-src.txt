part bean shell script distribution documentation update may found at http www beanshell sun notice content are subject sun 1 0 may use except compliance available at http www sun com original bean shell initial developer original pat niemey create pat niemey are 2000 all right reserve g n u notice alternatively content may use g n u less l g p l which provision l g p l are applicable instead those above wish allow use your only l g p l allow other use your s p l indicate your decision delete provision above replace them notice other provision require l g p l delete provision above recipient may use your s p l l g p l patrick niemey pat pat net learning o reilly associate http www pat net pat bsh routine suppor type comparison conversion bean shell following are note on type comparison conversion bean shell suppres warning uncheck type type conversion identifier an s s i g n m e n t allow conversion would normally happen on assignment s t perform numeric conversion small type an cast thing allow only variable declaration e g b 42 s t 0 s s i g n m e n t 1 j v b s e s s i g n b l e 1 j v b o x t y p e s s s i g b l e 2 j v v r r g s s s i g n b l e 3 b s h s s i g n b l e 4 f i r s t r o u n d s s i g n b l e j v b s e s s i g n b l e l s t r o u n d s s i g n b l e b s h s s i g n b l e special value indicate identity result cast operation wa valid cast use cast cast primitive check only mode operation value primitive type so cast primitive primitive v l s t primitive 1 primitive i n v l s t primitive 1 get type argument get type 0 type length i 0 i length i++ i type i i primitive type i primitive i get type type i i get type from signature argument type assignable signature candidate type handle special value type indicate loose type match anyth check strict here limit assignable signature assignable from round round j v v r r g s s s i g n b l e from length length round j v b s e s s i g n b l e i 0 i from length i++ base assignable i from i j v b o x t y p e s s s i g b l e i 0 i from length i++ box type assignable i from i j v v r r g s s s i g n b l e signature vararg assignable from b s h s s i g n b l e i 0 i from length i++ bsh assignable i from i interpreter bad signature vararg assignable from test conversion rh type type lh type type legal via standard assignment conversion rule i e cast rule include 5 autobox unbox p primitive t y p e take primitive promotion into account ordinary assignable from doe take primitive promotion conversion into account note allow additional assignment cast combination variable declaration allocation those are handle elsewhere maybe here flag? p accept rh type type indicate rh type wa value primitive n u l l allow assign reference lh type type non primitive p note get assignable form primary bsh check assignability add additional bsh conversion etc bsh assignable lh type assigning from rh type lh type rh type assigning from rh type lh type assignable lh type rh type base assignable lh type rh type || box type assignable lh type rh type assignment legal via original up 1 4 assignment rule include auto boxing unbox rh type may indicate primitive value base assignable lh type rh type assignment loose type defer bsh extension note we could shortcut here lh type rath than force another round s strictly issue so doe belong here? lh type rh type correspond type primitive n u l l assignable type rh type lh type primitive lh type primitive rh type primitive lh type rh type handle primitive widening conversion j l s 5 1 2 rh type t y p e lh type t y p e || lh type t y p e || lh type t y p e || lh type t y p e || lh type t y p e rh type t y p e lh type t y p e || lh type t y p e || lh type t y p e || lh type t y p e rh type character t y p e lh type t y p e || lh type t y p e || lh type t y p e || lh type t y p e rh type t y p e lh type t y p e || lh type t y p e || lh type t y p e rh type t y p e lh type t y p e || lh type t y p e rh type t y p e lh type t y p e lh type assignable from rh type determine type assignable via boxing unbox rule box type assignable lh type rh type assignment loose type defer bsh extension lh type prim box assign lh type prim numeric type box assign number lh type number rh type character t y p e rh type t y p e prim type wrapper vice versa i t know fast than flat list s like above wrapper map map both prim wrapper wrapper prim type so test symmetric primitive wrapper map get lh type rh type test type convert another type via bean shell extend syntax rule superset conversion rule bsh assignable type from type cast type from type from value s s i g n m e n t check only v l s t eval e happen check only interpreter err cast check +e attempt cast an instance type possible via bean shell extend syntax rule these rule are alway superset conversion rule wish impose context sensitive conversion rule then must test before calling p handle from value primitive type represent primitive cast well from value cast require generation etc type type cast result which may include primitive type e g t y p e from value an bsh primitive primitive value include primitive n u l l primitive v o bsh assignable cast from value type operation eval from value interpreter from value from type from value primitive ? primitive from value get type from value get cast type from type from value operation checkonly perform type conversion test type conversion possible respect bean shell extend rule these rule are alway superset language rule so also perform test language assignment cast conversion p perform functionality testing an assignment cast ultimately possible respect bean shell well functionality performing necessary conversion value base on specify target type combine functionality expediency could separate p other such assignable use determine suitability an assignment fine grain restrictive way base on context before calling p s t strong than an s s i g n m e n t operation attempt perform primtive operation cast small type e g my these are use primitive cast primitive delclaration declaration i t believe there are conversion which are different between s s i g n m e n t s t e g script proxy bsh on assignment well cast p doe obey strict must test first before using care assignable p type type cast result which may include primitive type e g t y p e type may indicate loose type assignment which match from type from type type value cast include primitive t y p e primitive from value would primitive n u l l then from type from value an bsh primitive primitive value include primitive n u l l primitive v o check only check only then from value must from type check cast type check only then from value must non primitive n u l l ok actual cast perform eval on invalid assignment when operation assignment target wrapping cast on cast when operation cast operation type s t type s s i g n m e n t bsh primitive get type note currently responsible auto boxing unbox conversion where doe need go? cast type from type from value operation check only eval lot precondition check here once thing are running smoothly we might comment these out s what assertion are check only from value interpreter bad cast 1 check only from value interpreter bad cast 2 from type primitive interpreter bad from type need unwrap from value primitive n u l l from type interpreter inconsistent 1 from value primitive v o from type t y p e interpreter inconsistent 2 type t y p e interpreter loose type assignment loose type type exactly same type type || type from type check only ? v l s t from value casting primitive type type primitive from type t y p e || from type || from type primitive both primitive primitive cast primitive cast primitive type from type primitive from value check only operation primitive wrapper type from type wrapper primitive convert value primitive check cast r check only ? v l s t unbox from type primitive unbox type from type primitive prim from value check only prim from value must check only prim from value primitive primitive wrap from value unbox from type primitive cast primitive type unbox from type prim from value check only operation cannot cast from arbitrary primitive check only i n v l s t cast type from type operation casting reference type casting from primitive reference type from type t y p e || from type || from type primitive cast from primitive wrapper type primitive wrapper type type from type t y p e from type primitive wrapper type check only ? v l s t primitive cast wrapper primitive unbox type type primitive from value get value primitive type type from type t y p e from type box check only ? v l s t primitive from value get value primitive arbitrary type allow primitive cast type handle well primitive n u l l primitive v o primitive cast primitive type from type primitive from value check only operation type already assignable no cast necessary we last allow variou above e g cast primitive would pas type assignable from from type check only ? v l s t from value we use proxy mechanism cast bsh correct interface? type bsh assignable from from type capability generate check only ? v l s t bsh from value get type both numeric wrapper types? numeric style promotion wrapper cast primitive wrapper type type primitive wrapper type from type check only ? v l s t primitive cast wrapper type from value check only i n v l s t cast type from type operation eval target wrapping cast describe an illegal assignment illegal cast respectively eval cast lh type rh type operation cast reflect normalize name lh type reflect normalize name rh type operation eval cast lh rh operation operation s s i g n m e n t eval t assign + rh + + lh cce cast cannot cast + rh + + lh target cce 