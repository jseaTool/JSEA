part bean shell script distribution documentation update may found at http www beanshell sun notice content are subject sun 1 0 may use except compliance available at http www sun com original bean shell initial developer original pat niemey create pat niemey are 2000 all right reserve g n u notice alternatively content may use g n u less l g p l which provision l g p l are applicable instead those above wish allow use your only l g p l allow other use your s p l indicate your decision delete provision above replace them notice other provision require l g p l delete provision above recipient may use your s p l l g p l patrick niemey pat pat net learning o reilly associate http www pat net pat bsh reflect reflect invocation target what s name? i ll tell name somewhat ambiguou thing grammar so p name resolv hold possibly ambiguou dot separate name reference namespace which allegedly life provide attempt resolve name variou type entity e g an declare script bean shell p name are create factory name space get name resolv which cache them subject namespace change mean we cache information about variou type resolution here currently very little information cache howev future optimize setting defeat certain dynamic behavior we might able cache quite bit strong note strong pre thread safety all work must because they share internal intermediate evaluation state note about we could simply use resolve invok bsh howev there no easy way s t b s h mehod invocation use doesn t type information about target resolve overload overload are resolve at compile time here they are necessity dynamic so would what we here cache signature we now client reflect note on caller resolution although reference like these work caller caller caller work equivalent using successive call doe work caller caller caller caller caller caller prohibit restriction only call caller on literal caller reference effect magic caller reference only work through current reference real explanation referernce really know anyth about their depth on call stack might hard define such thing those purpose we provide callstack pre name io serializable these change dur evaluation name space namespace value following instance variable mutate dur evaluation reset reset where necessary evaluation remain text evaluate eval name last part name evaluate really only use caller resolution last eval name f i n i s h e d evalname we re finish eval base base current eval callstack depth number time eval hit caller end mutable instance variable begin cache result structure these are optimization note s ok cache resolution here because when space change namespace discard cache name result result call on following end cache result structure reset eval name value eval base callstack depth 0 constructor use use name space get name resolv which support cache name space get name resolv i wish i could make friendly only name space name name space namespace s namespace namespace value s resolve possibly complex name an value eval on variou failure value indicate primitive n u l l type primitive v o come from attempt access an undefin variable some my variable my variable foo my variable foo bar grid bag constraint b o t h my stuff my some field some field interpreter reference necessary allow resolution interpreter magic field call stack reference necessary allow resolution caller magic field callstack magic field call stack callstack interpreter interpreter eval callstack interpreter force then resolution only produce necessary disambiguate where grammar know we want where var path may take call stack callstack interpreter interpreter force eval reset obj eval name obj consume next field callstack interpreter force autoalloc obj interpreter value obj complete round last eval name next eval name interpreter last eval name +last eval name last eval name last eval name eval name next eval name eval base get next consume one component eval name often consume just one component name classname consume all component necessary make identifier consume next field call stack callstack interpreter interpreter force auto allocate eval simple variable name? first give correct precedence var v name at least simple test precedence1 bsh also speed thing up bit eval base compound eval name force obj resolve field reference callstack namespace interpreter eval name obj primitive v o complete round eval name f i n i s h e d obj bsh script variable reference? we re just starting eval name no base we re evaluate relative type reference check var name prefix eval name 1 eval base || eval base force interpreter d e b u g interpreter debug resolve variable + var name obj namespace special var visibility eval base obj resolve field reference callstack namespace interpreter var name obj resolve field reference callstack eval base namespace interpreter var name obj primitive v o resolve variable interpreter d e b u g interpreter debug resolve variable + var name + namespace +namespace complete round var name suffix eval name obj name? we re just starting eval name make fail eval base interpreter d e b u g interpreter debug + eval name keep add part until we cla i 1 name i count part eval name i++ name prefix eval name i cla namespace get name cla complete round name suffix eval name count part eval name i identifier cla variable p above interpreter d e b u g interpreter debug var prefix +eval name no variable found type ref auto allocate then create one child eval base || eval base force auto allocate name space target name space eval base ? namespace eval base namespace obj name space target name space auto +var name get interpreter target name space set variable var name obj complete round var name suffix eval name obj we didn t find variable name prefix above there are two possibility we are simple name then we pas variable reference we are compound then we must fail at point eval base compound eval name complete round eval name f i n i s h e d primitive v o eval variable found + eval name after point we re definitely evaluate relative base some basic validity check eval base primitive n u l l previou round produce target pointer pointer evaluate +value eval base primitive v o previou round produce eval undefin variable name evaluate +value eval base primitive eval t treat primitive like an + evaluate +value resolve relative type field inner ? eval base identifier cla identifier eval base get target field prefix eval name 1 qualify reference from inner e g my out field equal find enclosing instance space name name space n namespace n get instance there n instance n instance get cla complete round field suffix eval name n instance n n get parent eval t find enclosing instance +cla obj field? interpreter d e b u g interpreter debug name call get field value +clas+ field +field obj reflect get field value cla field reflect e interpreter d e b u g interpreter debug field reflect +e inner class? obj iclas cla get name + +field namespace get iclas obj identifier obj eval no field inner + field + + cla complete round field suffix eval name obj we ve fall through here we are no longer resolving type force eval value + doe resolve name some kind field access? field prefix eval name 1 length access on array? field equal length eval base get obj primitive get length eval base complete round field suffix eval name obj check field on note could eliminate somehow obj reflect get field value eval base field complete round field suffix eval name obj reflect e field we get here we fail eval cannot access field + field + on + eval base resolve variable relative reference variable resolution accomodat special field from context together namespace interpreter comprise context callstack available allow caller construct optionally interpret special magic field name e g interpreter p callstack may only legitimate special where we are sure resolution involve caller namespace namespace reference same top stack? resolve field reference call stack callstack name space name space interpreter interpreter var name special field visible eval var name equal somewhat hack special field are visible we re operate relative type already dissallow further reference prevent user from skip thing like caller special field visible eval redundant call on type allow get work through block name space namespace x x x re eval we need it? th name space get interpreter name space th get name space result th name space name space get name space name space name space compound eval name result name space get interpreter result name space get instance result some duplication note above we re an encls instance superclass instance our superclass instance var name equal special field visible eval redundant call on type allow get through block name space s th name space get interpreter name space th get name space now closure s instance x x x x re evaluate get work itself now? we re instance parent also instance then mean our parent name space get parent name space get parent th name space get parent get interpreter th obj var name equal global obj name space get global interpreter obj special field visible var name equal namespace obj name space var name equal variable obj name space get variable name var name equal obj name space get name var name equal interpreter last eval name equal obj interpreter eval only call interpreter on literal obj special field visible var name equal caller last eval name equal || last eval name equal caller get previou context note callstack interpreter no callstack obj callstack get ++callstack depth get interpreter eval only call caller on literal literal caller early obj obj special field visible var name equal callstack last eval name equal get previou context note callstack interpreter no callstack obj callstack eval only call callstack on literal obj obj name space get variable var name obj interpreter field ref +var name obj enclosing body namespace name space get name space name space name space instance name space instance name space name space name space name space get parent name space get parent instance name space get parent name space get parent check cache use resolve identifier found on found path type eval on special ambiguou unqualifi name after found eval reset var mean untyp eval name equal var straightforward name first cla namespace get eval name cla which know how work through inner what we end up obj interpreter callstack reference only resolution require them obj eval e couldn t resolve obj identifier cla identifier obj get target cla found + value+ found namespace cla l h s l h s call stack callstack interpreter interpreter eval clean up single statement reset l h s lh simple non compound variable assignment e g x 5 compound eval name eval name equal eval t assign interpreter debug simple var l h s lh l h s namespace eval name bubble up allow lh field e g foo bar 5 obj eval name compound eval name obj consume next field callstack interpreter forcclas autoallocthi eval e eval l h s evaluation + e get message finish eval it eval name obj identifier eval t assign + value obj eval l h s + value e g x 5 some type x 5 obj dissallow assignment magic field eval name equal namespace || eval name equal variable || eval name equal || eval name equal caller eval t assign special variable +eval name interpreter debug found reference evaluate l h s wa literal reference then we allow recursion setting variable get normal effect finding near definition starting at scope on other resolution qualify type reference we want set variable directly scope e g x 5 some type x 5 old scop rule didn t local var last eval name equal l h s obj namespace eval name local var eval name obj identifier cla identifier obj get target lh reflect get l h s field cla eval name lh lh reflect get l h s field obj eval name lh reflect e eval field access +e interpreter internal lh identify name perform cache resolution using signature key p name contain wholely unqualfi messy name resolve | prefix + name p interpreter necessary support interpreter reference call e g debug p pre some dynamic local my variable foo my variable bar blah foo get foo pre interpreter interpreter call stack callstack simple node caller info eval eval reflect invocation target name name suffix value 1 bsh bcm interpreter get name space namespace callstack top optimization set then we already be here determine invocation note maybe factor out path below clean up reflect bcm name name compound value local interpreter callstack caller info note we want declare inside block accessible via inside block we could handle here special also resolve field reference special handling block name space they currently work via direct name e g name prefix name prefix value superclass invocation? e g foo prefix equal name count part value 2 allow get work through block namespace first th namespace get interpreter name space name space th get name space name space name space get name space name space name space instance name space get instance generator get generator superclass bcm instance name find target identifier name target name namespace get name resolv prefix obj target name callstack interpreter obj primitive v o eval attempt resolve +method name + on undefin variable name +target name we ve get an resolve obj identifier obj primitive obj primitive n u l l target pointer pointer invocation some other primitive avoid calling on primitive we name t treat primitive like an message hole right now interpreter d e b u g interpreter debug attempt access on primitive + allow bsh primitive peek through debug found an s an undefin variable reflect obj name interpreter callstack caller info s interpreter d e b u g interpreter debug + target name cla identifier obj get target cache fact invocation on cla cla reflect bcm cla name ??? eval unknown target + target name locally declare bsh command already declare namespace then load resource from command path e g bsh command note bsh command probably here we need scope namespace command so probably need integrate into name space local interpreter interpreter call stack callstack simple node caller info eval reflect invocation target interpreter d e b u g interpreter debug local + value interpreter interpreter local interpreter command name value type type get type check bsh meth meth namespace get command name type eval e e eval local invocation caller info callstack define meth meth interpreter callstack caller info bsh bcm interpreter get look bean shell command command command namespace get command command name type interpreter eval e e eval loading command caller info callstack print usage here nothing found command look handler namespace note duplicate it? call on nev command bsh namespace get eval e e eval local invocation caller info callstack command name interpreter callstack caller info eval command found + command name type caller info callstack command bsh bsh command interpreter callstack caller info command reflect compile command command interpreter callstack eval e e eval compile command caller info callstack interpreter invalid command type get help name eval check namespace here get bsh help +name interpreter e usage +name get help command eval reflect bcm command usage e usage +name operate on compound separate name i guess we could move these someday compound value value index 1 count part value 1 count part value value 0 count 0 index 1 index value index index + 1 1 count++ count + 1 prefix value compound value prefix value count part value 1 prefix value part part 1 count 0 index 1 index value index index + 1 1 ++count part index 1 ? value value substring 0 index suffix name compound name suffix name count part name 1 suffix value part part 1 count 0 index value length + 1 index value last index index 1 1 ++count part index 1 ? value value substring index + 1 end compound name routine value 