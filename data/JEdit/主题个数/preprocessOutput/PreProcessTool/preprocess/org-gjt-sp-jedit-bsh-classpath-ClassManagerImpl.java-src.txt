part bean shell script distribution documentation update may found at http www beanshell sun notice content are subject sun 1 0 may use except compliance available at http www sun com original bean shell initial developer original pat niemey create pat niemey are 2000 all right reserve g n u notice alternatively content may use g n u less l g p l which provision l g p l are applicable instead those above wish allow use your only l g p l allow other use your s p l indicate your decision delete provision above replace them notice other provision require l g p l delete provision above recipient may use your s p l l g p l patrick niemey pat pat net learning o reilly associate http www pat net pat bsh classpath net ref io i o io bsh classpath bsh path source bsh classpath bsh path jar source bsh classpath bsh path generate source bsh bsh bsh path bsh interpreter debug bsh eval pre manage all classload bean shell allow classpath extension reload hold bsh so separate from core currently relie on 1 2 bsh loader weak reference there workaround weak refs? so we could make work 1 1 supplying our own classload http www beanshell manual classload html on bsh classload architecture bsh ha multi tier loading architecture no loader create unles until generate classpath modify reload note we may need some synchronization here note on jdk1 2 dependency we are force use weak reference here accomodate all fleet namespace listener name space must inform space change so they un cache name i have interest thought way around would implement bean shell s own garbage collector then i come my sens say screw re loading require 1 2 classload precedence script evaluate script script add modify classpath optionally external classload optionally thread context classload plain name source classpath pre suppres warning uncheck impl bsh b s h p k g e bsh classpath base loader initially upon reset an empty instance bsh path grow path are add reset when classpath explicitly set could also call extension path strictly confine add path could set arbitrarily set path bsh path base path full blow classpath include base path extension user path bootstrap path rt jar lazily construct further importantly lazily intializ component because mapping full path could expensive full path composite base path user extension user path boot path order bsh path full path path change listener vector listener vector reference queue ref queue reference queue handle extension modification base classpath loader use where no mapping reload base loader initially meaning no loader use bsh loader base loader map classname loader use reload map loader map use bsh singleton constructor impl reset name name check positive cache absolute cache get name check negative cache absolute non get name interpreter d e b u g interpreter debug absolute non list hit +name interpreter d e b u g interpreter debug load +name check explicitly map reload loader overlay loader get loader name overlay loader overlay loader load name e use squeltch change 1 3 bsh no def found e2 no def found name e2 there since wa explicitly map an error? insure core are load from same loader name start b s h p k g e interpreter get loader load name found e check classpath extension reload base loader base loader load name found e optionally external classload external loader external loader load name found e optionally context classload note might security violation catching security sufficient all environments? we need way turn off completely? loader context loader thread current thread get context loader context loader name name context loader found e fall through security e fall through plain name plain name name found e script load source name cache result found note plain name already cache so redundant howev process only happen once cache info name get resource u r l using bean shell classpath path an absolute path u r l get resource path u r l url base loader classload want no leading slash url base loader get resource path substring 1 url url get resource path url get resource stream using bean shell classpath path an absolute path input stream get resource stream path input stream base loader classload want no leading slash base loader get resource stream path substring 1 get resource stream path loader get loader name loader loader map get name classpath mutator add path u r l path i o base loader set path u r l path opportunity here listener classpath base loader add u r l path base path add path loader change clear all classload behavior cache reset initial state reset base path bsh path base path base loader loader map hash map loader change call clear cache u set base classpath create base classload mean all type change set path u r l cp base path set path cp init base loader loader map hash map loader change overlay entire path loader set base path user path + base path no point include boot path t reload tho reload all path bsh path bcp bsh path temp bcp add component base path bcp add component bsh path get user path set path bcp get path component init base loader from base path init base loader base loader bsh loader base path reload reload mean create classload using whenev we are ask appropriate space we use discrete loader reload name path validate here? init base loader there none base loader init base loader discrete loader source map map discrete loader source map i 0 i name length i++ name name i look base loader path source source base path get source name look user path source bsh path get user path insure initialize source bsh path get user path get source name no point check boot path t reload those we could use full path above source path nothing know about +name jar source working just need implement s get we decide allow bsh handle since u r l loader handle j r source jar source path cannot reload +name+ from source + source map put name source create classload set loader cl discrete loader map map those loader overlay map iterator map key set iterator ha next loader map put next cl loader change reload all specify e g com sun tool special name lt unpackag use refer unpackag reload pack path collection base path get pack bsh path get user path get pack no point check boot path t reload those path no found +pack reload 0 unimplement we d store map location well name reload path component u r l pc path path unimplement end reload get full blow classpath bsh path get path path full path full path full path bsh path bean shell full path full path add component bsh path get user path full path add component bsh path get boot path path e err warning t get boot path full path add component base path full path support hide here oppose name space eval we prevent from happening twice? get path insure initialize prime lookup table get name unq name alway now get path set name completion include unq name path e eval importing classpath + e ha name none found an path contain detail name ambigou get name unq name name path get path get name unq name name add listener listener l listener add element weak reference l ref queue clean up old listener reference deadref deadref ref queue poll ok listener remove element deadref ok err clean up weak ref +deadref interpreter d e b u g interpreter debug remove non existent weak ref +deadref remove listener listener l unimplement loader get base loader base loader get bean shell classload loader get loader impl note we add bytecode source reload which cause bsh loader initialize create discrete loader bytecode path reload define name base path set source name generate source reload name path e bsh interpreter define +e name name clear global cache notify namespace clear their cache listener list weak reference so we keep every namespace existence forev loader change clear cache bsh clear cache vector remove vector safely remove enumeration e listener element e ha element weak reference wr weak reference e next element listener l listener wr get l garbage collect remove add wr l loader change enumeration e remove element e ha element listener remove element e next element dump print writer i i bsh dump i i base loader +base loader i loader map +load map i i base path +base path 