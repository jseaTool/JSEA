part bean shell script distribution documentation update may found at http www beanshell sun notice content are subject sun 1 0 may use except compliance available at http www sun com original bean shell initial developer original pat niemey create pat niemey are 2000 all right reserve g n u notice alternatively content may use g n u less l g p l which provision l g p l are applicable instead those above wish allow use your only l g p l allow other use your s p l indicate your decision delete provision above replace them notice other provision require l g p l delete provision above recipient may use your s p l l g p l patrick niemey pat pat net learning o reilly associate http www pat net pat bsh bsh objectweb asm bsh objectweb asm type reflect list list generator utiliz s m www objectweb bytecode generator eric bruneton order generate stub bean shell at runtime p stub contain all field bean shell script well two callback reference bean shell namespace one one instance are delegator which correspond on instance bsh then unpack result namespace utiliz delegate variable access field instance namespace utiliz dynamic i e mixin delegate variable access instance variable p constructor delegate init instance generator initialize instance init instance instance intializ init var instance block then delegate correspond script constructor instance namespace constructor contain special logic which allow bean shell control calling alternate constructor reference at runtime p specially name superclass delegator are also generate order allow bean shell access override superclass which reflection doe normally allow p pat niemey note would hard eliminate use objectweb asm type from making distribution tiny bit small suppres warning uncheck generator constant name field holding reference bsh callback namespace b s h s t t i bsh name instance field holding reference bsh instance callback namespace instance b s h t h i s bsh prefix name delegate e g bsh superfoo equivalent foo b s h s u p e r bsh bsh namespace variable name instance initializ b s h i n i t bsh instance initializ bsh namespace variable hold constructor b s h o n s t r u t o r s bsh constructor branch number constructor value 1 cause branch take d e f u l t o n s t r u t o r 1 o b j e t ljava name fully qualify name e g foo bar blah fq name name variable var constructor constructor delay eval bsh constructor delay eval bsh name space name space modifier modifier name e g com foo bar generator modifier modifier name name variable var delay eval bsh bshmethod name space name space modifier modifier name name name fq name name replace + + name fq name name name type get internal name 0 var var name space name space constructor get declare constructor split into constructor regular list list consl list list methodsl list base name get base name name inner i 0 i bshmethod length i++ bshmethod i get name equal base name consl add bshmethod i methodsl add bshmethod i constructor delay eval bsh consl delay eval bsh 0 delay eval bsh methodsl delay eval bsh 0 name space set local variable b s h o n s t r u t o r s constructor strict eval e interpreter t set con var generate bytecode generate force now mod get s m modifier modifier | p u b l i mod | i n t e r f e name length i 0 i length i++ name i type get internal name i source bean shell generate via s m www objectweb writer cw writer cw visit mod fq name name name source generate bsh instance reference holder field generate field b s h t h i s+clas name lorg bsh p u b l i cw generate bsh reference holder field generate field b s h s t t i c+clas name lorg bsh p u b l i c+ s t t i cw generate field i 0 i var length i++ type var i get type descriptor t generate loosely type field note loose type aren t currently parse anyway var i ha modifier || type modifier modifier p u b l i | s t t i | f i n l modifier get s m modifier var i get modifier generate field var i get name type modifier cw generate constructor ha constructor i 0 i constructor length i++ t generate constructor constructor i ha modifier modifier get s m modifier constructor i get modifier generate constructor i constructor i get type descriptor modifier cw ha constructor no other constructor generate constructor ha constructor generate constructor d e f u l t o n s t r u t o r index 0 p u b l i cw generate delegate i 0 i length i++ type i get type descriptor t generate loosely type i ha modifier || type modifier get s m modifier i get modifier modifier | p u b l i | b s t r t generate name fq name i get name type i get type descriptor modifier cw modifier s t t i 0 override contain i get name i get type descriptor override generate delegate name i get name type i get type descriptor modifier cw cw translate bsh modifier into s m modifier bitflag get s m modifier modifier modifier mod 0 modifier mod modifier ha modifier mod + p u b l i modifier ha modifier mod + p r o t e t e d modifier ha modifier mod + s t t i modifier ha modifier mod + s y n h r o n i e d modifier ha modifier mod + b s t r t mod generate field instance generate field field name type modifier writer cw cw visit field modifier field name type value generate delegate instance generate pack argument into an wrapping primitive type bsh primitive instance namespace then unwrap result generate name fq name name type type modifier writer cw modifier s t t i 0 type map loose type type o b j e t descriptor get descriptor type type generate body visitor cv cw visit modifier name descriptor modifier b s t r t 0 generate push b s h t h i s b s h s t t i field cv visit field insn g e t s t t i fq name b s h s t t i c+clas name lorg bsh push cv visit var insn l o d 0 get instance field cv visit field insn g e t f i e l d fq name b s h t h i s+clas name lorg bsh push name constant cv visit ldc insn name generate push argument an generate parameter reifi type cv push variou cv visit insn o n s t n u l l interpreter cv visit insn o n s t n u l l callstack cv visit insn o n s t n u l l callerinfo push constant declare only cv visit insn i o n s t 1 name sig cv visit insn i n v o k e v i r t u l bsh type get descriptor type get type type type get type type get type type get type interpreter type get type call stack type get type simple node type get type t y p e generate unwrap bsh primitive type cv visit insn i n v o k e s t t i bsh primitive unwrap ljava ljava generate value generate type cv need calculate just fudge here now cv visit max 20 20 generate constructor generate constructor index type modifier writer cw offset after var var type length+1 offset after constructor var con var type length+2 descriptor get descriptor v type create constructor visitor cv cw visit modifier init descriptor generate push argument an generate parameter reifi type cv cv visit var insn s t o r e var generate implement alternate constructor generate constructor index var con var cv generate generator init instance push cv visit var insn l o d 0 push constructor name constant cv visit ldc insn name push argument an cv visit var insn l o d var init instance cv visit insn i n v o k e s t t i bsh generator init instance ljava ljava ljava v cv visit insn r e t u r n need calculate just fudge here now cv visit max 20 20 generate branch each possible alternate constructor include all superclass constructor all constructor branch superclass constructor p also generate call generator get constructor which inspect script constructor find alternate constructor signature evalute argument at runtime get constructor actual argument well index constructor call generate constructor con index var con var visitor cv label label label label end label label constructor length + constructor length label label label i 0 i i++ label i label generate call generator get our index give u push name cv visit ldc insn get name use name var? push cv visit field insn g e t s t t i fq name b s h s t t i c+clas name lorg bsh push cv visit var insn l o d var push constructor index number onto stack cv visit insn b i p u s h con index generator get constructor cv visit insn i n v o k e s t t i bsh generator get constructor ljava lorg bsh ljava i + lorg bsh generator util$ constructor store constructor con var cv visit var insn s t o r e con var get constructor selector field from constructor push constructor cv visit var insn l o d con var cv visit field insn g e t f i e l d bsh generator util$ constructor selector i start cv visit table insn 0 min 1 max label label generate body index 0 i 0 i constructor length i++ index++ branch index name get type descriptor constructor i get parameter type end label label con var cv i 0 i constructor length i++ index++ branch index fq name constructor i get type descriptor end label label con var cv generate branch cv visit label label branch alway no cv visit var insn l o d 0 push cv visit insn i n v o k e s p e i l name init v cv visit label end label generate branch constructor call generate constructor generate assume argument on stack branch index target name type label end label label label con var visitor cv cv visit label label index cv visit line number index label index cv visit var insn l o d 0 push before unload argument from constructor i 0 i type length i++ type type i type equal get type equal b get type equal get type equal s get type equal i get type equal j get type equal d get type equal f get get iterator on constructor cv visit var insn l o d con var push constructor name bsh generator util$ constructor ret type equal get ret type o b j e t ret type type cv visit insn i n v o k e v i r t u l name +ret type s an type we must check cast equal get cv visit type insn h e k s t descriptor name type constructor branch descriptor get descriptor v type cv visit insn i n v o k e s p e i l target name init descriptor cv visit jump insn g o t o end label get descriptor type type builder sb builder i 0 i type length i++ sb append type i sb append +return type sb generate superclass delegate accessor these are specially name which allow access override superclass which reflection p i normally doe allow maybe combine generate generate delegate name name type type modifier writer cw type map loose type o b j e t descriptor get descriptor type type add body visitor cv cw visit modifier bsh +method name descriptor cv visit var insn l o d 0 push var local var index 1 i 0 i type length ++i primitive type i cv visit var insn i l o d local var index cv visit var insn l o d local var index local var index + type i equal d || type i equal j ? 2 1 cv visit insn i n v o k e s p e i l name name descriptor generate plain type cv need calculate just fudge here now cv visit max 20 20 contain cla name type cla cla get declare i 0 i length i++ i get name equal name type get type descriptor i get parameter type found j 0 j type length j++ type j equal type j found found cla cla get superclass generate normal bytecode generate plain type visitor cv type equal v cv visit insn r e t u r n primitive type opcode i r e t u r n type equal d opcode d r e t u r n type equal f opcode f r e t u r n type equal j opcode l r e t u r n cv visit insn opcode cv visit type insn h e k s t descriptor name type cv visit insn r e t u r n generate reify argument given m i s bytecode correspond bsh primitive i s expression eric bruneton pat niemey cv visitor use generate bytecode enclosing generate parameter reifi type visitor cv cv visit insn s i p u s h type length cv visit type insn n e w r r y local var index ? 0 1 i 0 i type length ++i type i cv visit insn d u p cv visit insn s i p u s h i primitive opcode equal f opcode f l o d equal d opcode d l o d equal j opcode l l o d opcode i l o d type bsh primitive cv visit type insn n e w type cv visit insn d u p cv visit var insn opcode local var index desc ok? cv visit insn i n v o k e s p e i l type init + desc + v technically incorrect here we need wrap value bsh primitive n u l l howev much u we need generate conditional here test primitive n u l l cv visit var insn l o d local var index cv visit insn s t o r e local var index + equal d || equal j ? 2 1 generate unreify result given m i s bytecode correspond value expression cv visitor use generate bytecode eric bruneton pat niemey generate type visitor cv type equal v cv visit insn p o p cv visit insn r e t u r n primitive type opcode i r e t u r n type meth type equal b type meth value type equal i type meth value type equal type meth value type equal d opcode d r e t u r n type meth value type equal f opcode f r e t u r n type meth value type equal j opcode l r e t u r n type meth value type equal type character meth value type equal s type meth value desc type cv visit type insn h e k s t type type correct here cv visit insn i n v o k e v i r t u l type meth + desc cv visit insn opcode cv visit type insn h e k s t descriptor name type cv visit insn r e t u r n evaluate argument constructor specify constructor index constructor which contain actual argument alternate constructor also index constructor constructor con argument constructor these are necessary evaluation alt constructor e g foo constructor contain constructor selector evaluate argument alternate constructor constructor get constructor name con index delay eval bsh constructor constructor delay eval bsh get name space get variable b s h o n s t r u t o r s e interpreter unable get instance initializ +e index d e f u l t o n s t r u t o r auto gen constructor constructor d e f u l t use constructor delay eval bsh constructor constructor index constructor body jjt get num child 0 constructor d e f u l t use constructor determine constructor call alt constructor b s h argument node simple node first statement simple node constructor body jjt get child 0 first statement b s h primary expression first statement simple node first statement jjt get child 0 first statement b s h invocation b s h invocation node b s h invocation first statement b s h ambiguou name name node get name node name text equal || name text equal alt constructor name text node node get node alt constructor constructor d e f u l t use constructor make tmp namespace hold original constructor use eval node name space con name space name space get name space con con name constructor get parameter name con type constructor get parameter type i 0 i con length i++ con name space set type variable con name i con type i con i modifier eval e interpreter err setting local con +e evaluate call stack callstack call stack callstack push con name space interpreter interpreter declare interpreter node get argument callstack interpreter eval e interpreter evaluate constructor +e type type get type primitive unwrap interpreter get name name interpreter t find superclass +sup name constructor con get declare constructor find match constructor alt constructor equal i reflect find most specific constructor index type con i 1 interpreter t find constructor constructor i find match constructor candidate constructor length i 0 i candidate length i++ candidate i constructor i get parameter type i reflect find most specific signature type candidate i 1 interpreter t find constructor 2 constructor come after constructor table selector i+sup con length our selector index+sup con length are we choose ourselve recursively through reference? selector our selector interpreter recusive constructor call constructor selector initialize an instance call from generate constructor evaluate instance initializ script constructor instance namespace init instance instance name sig type get type call stack callstack call stack interpreter interpreter name space instance name space check instance ha already be initialize using alternate constuctor instance get instance instance name x x x clean up conditional instance create instance namespace set on instance instance initializ get reference from proto instance get instance get name interpreter declare interpreter get instance initializ block from b s h block instance init block instance init block b s h block get name space get variable b s h i n i t e interpreter unable get instance initializ +e create instance namespace instance name space name space get name space name instance name space set instance reference on instance instance instance name space get interpreter l h s lh reflect get l h s field instance b s h t h i s+clas name lh assign instance strict e interpreter gen setup +e give instance space it instance name space set instance instance use here pop n callstack push instance name space evaluate instance portion block evaluate initializ block instance init block eval block callstack interpreter override generator impl node filter l s s i n s t n e e interpreter initialization +e callstack pop instance ha already be initialz another constructor fall through constructor body below interpreter instance declare interpreter instance name space instance get name space constructor from instance constructor name get base name name find constructor now instance namespace bsh constructor instance name space get constructor name sig declare only we must constructor length 0 constructor interpreter t find constructor + name evaluate constructor constructor constructor interpreter callstack caller info override name space e e target e target e get target e invocation target e invocation target e get target e print stack trace err interpreter initialization +e get bsh namespace field from name may name cla itself superclass cla get cla name reflect get field value cla b s h s t t i + name e interpreter unable get space +e get instance bsh namespace field from instance instance ha be initialize get instance instance name o reflect get field value instance b s h t h i s+clas name primitive unwrap o unwrap primitive e interpreter generate getting +e doe type descriptor describe primitive type? primitive type descriptor type descriptor length 1 right? get type descriptor cparam sa cparam length i 0 i sa length i++ sa i b s h type get type descriptor cparam i sa non type remove prefix l suffix factor out ? add l here instead? descriptor name s s start || s start l s s substring 1 s length 1 get base name name i name index i 1 name name substring i+1 constructor hold evaluate argument constructor call well index possible alternate selector use constructor generate constructor writer constructor constructor which call constructor constructor d e f u l t constructor selector d e f u l t o n s t r u t o r 0 index constructor call constructor constructor selector selector selector next arg++ get next value get next value get character next value get next value get next value get next value get next value get next value get next 