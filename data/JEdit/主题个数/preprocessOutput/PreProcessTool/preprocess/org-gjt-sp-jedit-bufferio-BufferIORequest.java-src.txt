buffer i o request i o request tab size 4 indent size 4 no tab collapse fold 1 2000 2004 g n u 2 w i t h o u t n y w r r n t y m e r h n t b i l i t y f i t n e s s f o r p r t i u l r p u r p o s e g n u g n u 59 330 m 02111 1307 u s bufferio importsimport io buffer output stream io conversion io i o io input stream io output stream io reader io writer charset character coding text segment buffer misc utility view j edit buffer j edit buffer io v f s io v f s io encoding io encoding server segment buffer log buffer i o request buffer i o request 24414 2016 06 19 11 07 43 kerik sf buffer i o request io task constant size i o buffer i o b u f s i e 32768 number line p progress increment p r o g r e s s i n t e r v l 300 l o d d t buffer i o request load data e n d o f f s e t s buffer i o request end offset n e w p t h buffer i o request path buffer property set when an occur e r r o r o u r r e d buffer i o request instance variable view view buffer buffer session v f s vf path marker path buffer i o request constructor create buffer i o request view view buffer buffer session v f s session vf v f s path path buffer i o request view view buffer buffer session v f s vf path view view buffer buffer session session vf vf path path marker path buffer get marker path vf path buffer set io task get get name + + buffer + get i o buffer size size character i o buffer get i o buffer size i o b u f s i e get i o buffer size size i o buffer get i o buffer size 2 sizeof i o b u f s i e 2 autodetect detect stream gzipp ha an encoding specify an xml p i reader autodetect input stream i o misc utility autodetect buffer read segment buffer read reader length insert i o interrupt we guess an initial size end offset math max 1 length 50 only size know track progress buffer temporary length 0 track progress set maximum length set value 0 size know start resonable buffer size length 0 length i o b u f s i e segment buffer seg segment buffer length + 1 buf i o b u f s i e number character buf input stream read doesn t alway fill eg size multiple i o b u f s i e g zip etc len wa read after \r usually mean d o s window r l f \r wa read hence mac o s r only wa previou read character \r? we read we assume we d o s window last wa r number line read every 100 line we update progress bar line count 0 len read buf 0 buf length 1 thread interrupt interrupt offset previou line relative start i o buffer n o t relative start document last line 0 i 0 i len i++ look line ending buf i \r we read \r last wa r also probably mac \r\r stream last wa r r only r l f otherwise set flag so know last wa \r last wa r insert line seg append buf last line i last line seg append end offset add seg count track progress line count++ % p r o g r e s s i n t e r v l 0 set value seg count i+1 take trailing into account last line i + 1 last wa r we just read \r follow we specify window take no further action just ignore \r last wa r r only r l f last wa r bump last line so next line doesn t erronously pick up \r last line i + 1 otherwise we found follow some other character hence we unix r only r l f seg append buf last line i last line seg append end offset add seg count track progress line count++ % p r o g r e s s i n t e r v l 0 set value seg count last line i + 1 we find some other character follow \r so window probably mac last wa r r only r l f last wa r track progress set value seg count add remain stuff from buffer seg append buf last line len last line set cancellable line separator seg count 0 fix 865589 0 open using line seperator line separator j edit get property buffer line separator get property line separator r l f line separator r only line separator \r line separator chop trailing newline ^ buffer length seg count buffer length 0 ch seg buffer length 1 ch 0x1a d o s ^ seg count buffer set property buffer t r i l i n g e o l buffer length 0 j edit get property strip trailing e o l ch seg buffer length 1 ch buffer set property buffer t r i l i n g e o l seg count end offset set size end offset get size 1 add line marker at end proper offset operation end offset add seg count + 1 avoid have deal read lock such we insert load data into buffer post load cleanup runnable which run w t thread insert buffer set property l o d d t seg buffer set property e n d o f f s e t s end offset buffer set property n e w p t h path line separator buffer set property j edit buffer l i n e s e p line separator use insert seg buffer buffer output stream out i o interrupt encoding name buffer get property j edit buffer e n o d i n g encoding encoding encoding server get encoding encoding name writer writer encoding get text writer buffer output stream out get i o buffer size segment line segment segment newline buffer get property j edit buffer l i n e s e p newline newline get property line separator buffer line count buffer get line count set maximum buffer line count p r o g r e s s i n t e r v l set value 0 i 0 i buffer line count thread interrupt interrupt buffer get line text i line segment writer line segment line segment offset line segment count i buffer line count 1 || j edit get property strip trailing e o l buffer get property buffer t r i l i n g e o l writer newline character coding e message get encoding message encoding name encoding line segment i i o wrapping conversion message wrapping init cause e wrapping ++i % p r o g r e s s i n t e r v l 0 set value i p r o g r e s s i n t e r v l writer flush end session quietly end session quietly vf end v f s session session view e log log log e r r o r e pp e v f s view path ioerror read pp buffer set property e r r o r o u r r e d member create encoding message get encoding message encoding name encoding encoding segment line line index encoding name line index + 1 u n k n o w n column u n k n o w n character index get first guilty character index encoding line 0 index index line count line line offset + index 2 index + 1 3 + + u+ + hex upper + e ignore j edit get property ioerror encoding get first guilty character index look first character which cause encoding get first guilty character index encoding encoding segment line i o line count 1 1 line count 1 0 writer tester encoding get text writer output stream b i 0 i line count ++i tester line line offset + i character coding e i 1 