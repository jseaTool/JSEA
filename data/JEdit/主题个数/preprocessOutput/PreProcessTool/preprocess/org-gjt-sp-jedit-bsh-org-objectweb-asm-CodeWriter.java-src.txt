s m very small fast bytecode manipulation framework 2000 i n r i france telecom 2002 france telecom library g n u less 2 at your option library w i t h o u t n y w r r n t y m e r h n t b i l i t y f i t n e s s f o r p r t i u l r p u r p o s e g n u less g n u less library 59 330 m 02111 1307 u s contact eric bruneton rd francetelecom com eric bruneton bsh objectweb asm link visitor visitor generate bytecode instruction each visit append bytecode correspond visit instruction vector order these are call writer visitor tt tt precondition must check at runtime h e k next writer link writer first first writer next writer which must add writer cw constant pool item contain name item name constant pool item contain descriptor item desc access flag access maximum stack size max stack maximum number local variable max local bytecode vector vector number entry table count table vector table number count precisely contain index constant pool item contain internal name these number entry local variable table attribute local var count local variable table attribute vector local var number entry line number table attribute line number count line number table attribute vector line number indicate some jump instruction are too small need resize resize field control flow graph analysis algorithm use compute maximum stack size control flow graph contain one node p basic block one edge p jump from one basic block another each node i e each basic block represent label correspond first instruction basic block each node also store list it successor graph link list edge tt tt maximum stack size number local variable must automatically compute compute max relative stack size after last visit instruction size relative beginning current basic block i e stack size after last visit instruction equal link label begin stack size begin stack size current basic block plus tt stack size tt stack size relative maximum stack size after last visit instruction size relative beginning current basic block i e maximum stack size after last visit instruction equal link label begin stack size begin stack size current basic block plus tt stack size tt max stack size current basic block block basic block which next instruction visit must add label current block basic block stack use control flow analysis algorithm stack represent link list link label label link each other their link label next field stack must confuse j v m stack use execute j v m instruction label block stack stack size variation correspond each j v m instruction stack variation equal size value produce an instruction minus size value consume instruction s i e field optimize creation link edge edge using pool reusable share pool link list edge link each other their link edge pool next field each time writer need allocate an edge remove first edge pool add list edge after end control flow analysis algorithm edge list writer are add back pool append list pool list order constant time both head tail list are store writer head list link edge edge use link writer writer these link each other their link edge pool next field are add back share pool at end control flow analysis algorithm edge head tail list link edge edge use link writer writer these link each other their link edge pool next field are add back share pool at end control flow analysis algorithm edge tail share pool link edge edge pool link list edge link each other their link edge pool next field edge pool initializ compute stack size variation correspond each j v m instruction i b 202 s e f f f f f f f f g g f f f g g f f f e e f g f g f e e e e e e e e e e e e e e e e e e e e d e d e d d d d d d d e e e e e e e e e + e e e e e e e e e e e b b b b b b d f f f g g g e d d d d d d d d d d e e e e d d d d d d d d d e f e f + d d e e f f d e d e e e b d d b b d d d d d d e f e d d d d d e e e e e e e e e e f e e e e e e d d e e d d e e i 0 i b length ++i b i s at i e s i e b generate above n 0 applicable unus opcode variable size opcode b 0 n o p visit insn 1 o n s t n u l l 1 i o n s t m1 1 i o n s t 0 1 i o n s t 1 1 i o n s t 2 1 i o n s t 3 1 i o n s t 4 1 i o n s t 5 2 l o n s t 0 2 l o n s t 1 1 f o n s t 0 1 f o n s t 1 1 f o n s t 2 2 d o n s t 0 2 d o n s t 1 1 b i p u s h visit insn 1 s i p u s h 1 l d visit ldc insn n l d w n l d c2 w 1 i l o d visit var insn 2 l l o d 1 f l o d 2 d l o d 1 l o d n i l o d 0 n i l o d 1 n i l o d 2 n i l o d 3 n l l o d 0 n l l o d 1 n l l o d 2 n l l o d 3 n f l o d 0 n f l o d 1 n f l o d 2 n f l o d 3 n d l o d 0 n d l o d 1 n d l o d 2 n d l o d 3 n l o d 0 n l o d 1 n l o d 2 n l o d 3 1 i l o d visit insn 0 l l o d 1 f l o d 0 d l o d 1 l o d 1 b l o d 1 l o d 1 s l o d 1 i s t o r e visit var insn 2 l s t o r e 1 f s t o r e 2 d s t o r e 1 s t o r e n i s t o r e 0 n i s t o r e 1 n i s t o r e 2 n i s t o r e 3 n l s t o r e 0 n l s t o r e 1 n l s t o r e 2 n l s t o r e 3 n f s t o r e 0 n f s t o r e 1 n f s t o r e 2 n f s t o r e 3 n d s t o r e 0 n d s t o r e 1 n d s t o r e 2 n d s t o r e 3 n s t o r e 0 n s t o r e 1 n s t o r e 2 n s t o r e 3 3 i s t o r e visit insn 4 l s t o r e 3 f s t o r e 4 d s t o r e 3 s t o r e 3 b s t o r e 3 s t o r e 3 s s t o r e 1 p o p 2 p o p2 1 d u p 1 d u p x1 1 d u p x2 2 d u p2 2 d u p2 x1 2 d u p2 x2 0 s w p 1 i d d 2 l d d 1 f d d 2 d d d 1 i s u b 2 l s u b 1 f s u b 2 d s u b 1 i m u l 2 l m u l 1 f m u l 2 d m u l 1 i v 2 l d i v 1 f d i v 2 d d i v 1 i r e m 2 l r e m 1 f r e m 2 d r e m 0 i n e g 0 l n e g 0 f n e g 0 d n e g 1 i s h l 1 l s h l 1 i s h r 1 l s h r 1 i u s h r 1 l u s h r 1 i n d 2 l n d 1 i o r 2 l o r 1 i x o r 2 l x o r 0 i i n visit iinc insn 1 i2 l visit insn 0 i2 f 1 i2 d 1 l2 i 1 l2 f 0 l2 d 0 f2 i 1 f2 l 1 f2 d 1 d2 i 0 d2 l 1 d2 f 0 i2 b 0 i2 0 i2 s 3 l m p 1 f m p l 1 f m p g 3 d m p l 3 d m p g 1 i f e q visit jump insn 1 i f n e 1 i f l t 1 i f g e 1 i f g t 1 i f l e 2 i f i m p e q 2 i f i m p n e 2 i f i m p l t 2 i f i m p g e 2 i f i m p g t 2 i f i m p l e 2 i f m p e q 2 i f m p n e 0 g o t o 1 j s r 0 r e t visit var insn 1 t b l e s w i t h visi table insn 1 l o o k u p s w i t h visit lookup 1 i r e t u r n visit insn 2 l r e t u r n 1 f r e t u r n 2 d r e t u r n 1 r e t u r n 0 r e t u r n n g e t s t t i visit field insn n p u t s t t i n g e t f i e l d n p u t f i e l d n i n v o k e v i r t u l visit insn n i n v o k e s p e i l n i n v o k e s t t i n i n v o k e i n t e r f e n u n u s e d n o t v i s i t e d 1 n e w visit type insn 0 n e w r r y visit insn 0 n e w r r y visit type insn 0 r r y l e n g t h visit insn n t h r o w 0 h e k s t visit type insn 0 i n s t n e o f 1 m o n i t o r e n t e r visit insn 1 m o n i t o r e x i t n w e n o t v i s i t e d n m u l t i n e w r r y visit multi insn 1 i f n u l l visit jump insn 1 i f n o n n u l l n g o t o w n j s r w i 0 i b length ++i err print e + b i err constructor construct writer cw writer which must add compute max tt tt maximum stack size number local variable must automatically compute writer writer cw compute max cw first cw first cw last cw last next cw last cw cw compute max compute max compute max push first block onto stack block visit current block label current block push block stack current block initializ writer define bytecode specify access s access flag link constant name s name desc s descriptor link type type internal name s may tt tt init access name desc access access name cw u t f8 name desc cw u t f8 desc length 0 count length count i 0 i count ++i i cw i index compute max update max local size get argument size desc 2 access constant s t t i 0 size size max local max local size visitor visit insn opcode compute max update current max stack size size stack size + s i e opcode size max stack size max stack size size stack size size opcode t h r o w x r e t u r n end current block no successor opcode constant i r e t u r n opcode constant r e t u r n || opcode constant t h r o w current block current block max stack size max stack size current block add instruction bytecode put1 opcode visit insn opcode operand compute max opcode constant n e w r r y update current max stack size only opcode n e w r r y stack size variation 0 b i p u s h s i p u s h size stack size + 1 size max stack size max stack size size stack size size add instruction bytecode opcode constant s i p u s h put12 opcode operand b i p u s h n e w r r y put11 opcode operand visit var insn opcode var compute max update current max stack size opcode constant r e t no stack change end current block no successor current block current block max stack size max stack size current block x l o d x s t o r e size stack size + s i e opcode size max stack size max stack size size stack size size update max local n opcode constant l l o d || opcode constant d l o d || opcode constant l s t o r e || opcode constant d s t o r e n var + 2 n var + 1 n max local max local n add instruction bytecode var 4 opcode constant r e t opt opcode constant i s t o r e opt 26 i l o d 0 + opcode constant i l o d 2 + var opt 59 i s t o r e 0 + opcode constant i s t o r e 2 + var put1 opt var 256 put1 196 w e put12 opcode var put11 opcode var visit type insn opcode desc compute max opcode constant n e w update current max stack size only opcode n e w stack size variation 0 n e w r r y h e k s t i n s t n e o f size stack size + 1 size max stack size max stack size size stack size size add instruction bytecode put12 opcode cw desc index visit field insn opcode owner name desc compute max size compute stack size variation desc at 0 opcode constant g e t s t t i size stack size + d || j ? 2 1 constant p u t s t t i size stack size + d || j ? 2 1 constant g e t f i e l d size stack size + d || j ? 1 0 constant p u t f i e l d size stack size + d || j ? 3 2 update current max stack size size max stack size max stack size size stack size size add instruction bytecode put12 opcode cw field owner name desc index visit insn opcode owner name desc item i opcode constant i n v o k e i n t e r f e i cw itf owner name desc i cw owner name desc size i val compute max compute stack size variation order recompute several time variation same item we use val field item store variation once ha be compute precisely val field store size argument value correspond desc size 0 above size be compute yet so we compute them size get argument size desc we save them order recompute them future i val size size opcode constant i n v o k e s t t i size stack size size 2 + size 0x03 + 1 size stack size size 2 + size 0x03 update current max stack size size max stack size max stack size size stack size size add instruction bytecode opcode constant i n v o k e i n t e r f e compute max size 0 size get argument size desc i val size put12 constant i n v o k e i n t e r f e i index put11 size 2 0 put12 opcode i index visit jump insn opcode label label h e k label owner label owner label owner illegal argument compute max opcode constant g o t o no stack change end current block one successor current block current block max stack size max stack size add successor stack size label current block opcode constant j s r current block add successor stack size + 1 label update current stack size max stack size unchang because stack size variation alway negative stack size + s i e opcode current block add successor stack size label add instruction bytecode label resolve label position length m i n v l u e backward jump an offset 32768 we automatically replace g o t o g o t o w j s r j s r w i fxxx l i f n o txxx l g o t o w l where i f n o txxx opposite opcode i fxxx i e i f n e i f e q where l designate instruction just after g o t o w opcode constant g o t o put1 200 g o t o w opcode constant j s r put1 201 j s r w put1 opcode 166 ? opcode + 1 ^ 1 1 opcode ^ 1 put2 8 jump offset put1 200 g o t o w label put length 1 backward jump an offset 32768 forward jump course an unknown offset these we store offset 2 which increase resize instruction need put1 opcode label put length 1 visit label label label h e k label owner label owner label owner illegal argument compute max current block end current block one successor current block max stack size max stack size add successor stack size label begin current block reset relative current max stack size current block label stack size 0 max stack size 0 resolve previou forward reference label resize | label resolve length data visit ldc insn cst item i cw cst cst compute max size compute stack size variation i type writer l o n g || i type writer d o u b l e size stack size + 2 size stack size + 1 update current max stack size size max stack size max stack size size stack size size add instruction bytecode index i index i type writer l o n g || i type writer d o u b l e put12 20 l d c2 w index index 256 put12 19 l d w index put11 constant l d index visit iinc insn var increment compute max update max local only no stack change n var + 1 n max local max local n add instruction bytecode var 255 || increment 127 || increment 128 put1 196 w e put12 constant i i n var put2 increment put1 constant i i n put11 var increment visit table insn min max label dflt label label compute max update current stack size max stack size unchang stack size end current block many successor current block current block max stack size max stack size add successor stack size dflt i 0 i label length ++i add successor stack size label i current block add instruction bytecode source length put1 constant t b l e s w i t h length % 4 0 put1 0 dflt put source put4 min put4 max i 0 i label length ++i label i put source visit lookup insn label dflt key label label compute max update current stack size max stack size unchang stack size end current block many successor current block current block max stack size max stack size add successor stack size dflt i 0 i label length ++i add successor stack size label i current block add instruction bytecode source length put1 constant l o o k u p s w i t h length % 4 0 put1 0 dflt put source put4 label length i 0 i label length ++i put4 key i label i put source visit multi insn desc dim compute max update current stack size max stack size unchang because stack size variation alway negative stack size + 1 dim add instruction bytecode item item cw desc put12 constant m u l t i n e w r r y item index put1 dim visit block label start label end label handler type h e k start owner || end owner || handler owner illegal argument start resolve || end resolve || handler resolve illegal argument compute max push handler block onto stack block visit handler push handler begin stack size 1 handler push handler next block stack block stack handler ++catch count table table vector table put2 start position table put2 end position table put2 handler position table put2 type ? cw type index 0 visit max max stack max local compute max non relative max stack size max 0 control flow analysis algorithm block stack empty pop block from stack update max stack size compute non relative begin stack size successor block push these successor onto stack unles they already be push onto stack note hypothesis link label begin stack size block block stack are non relative beginning stack size these block label stack block stack stack pop block from stack label l stack stack stack next compute non relative max stack size block start l begin stack size block max start + l max stack size update global max stack size block max max max block max analysis successor block edge b l successor b l b successor successor ha already be push onto stack l push compute beginning stack size successor block l begin stack size start + b stack size push successor onto stack l push l next stack stack l b b next max stack max release all edge use writer s i e append head tail list at beginning pool list tail tail pool next pool pool head max stack max stack max local max local visit local variable name desc label start label end index h e k start owner || start resolve illegal argument end owner || end resolve illegal argument local var cw u t f8 local variable table local var vector ++local var count local var put2 start position local var put2 end position start position local var put2 cw u t f8 name index local var put2 cw u t f8 desc index local var put2 index visit line number line label start h e k start owner || start resolve illegal argument line number cw u t f8 line number table line number vector ++line number count line number put2 start position line number put2 line utility control flow analysis algorithm compute size argument value desc descriptor size argument plus one implicit argument size size it value ret size pack into single i tt size 2 | ret size tt size therefore equal tt i 2 tt ret size tt i 0x03 tt get argument size desc n 1 1 car desc at c++ car car desc at n 2 | car v ? 0 car d || car j ? 2 1 car l desc at c++ n + 1 car car desc at ++c car d || car j n 1 car d || car j n + 2 n + 1 add successor link current block current block block stack size current relative stack size current block successor successor block add current block add successor stack size label successor edge b create edge reus one from share pool s i e pool b edge b pool remove b from pool pool pool pool next add previou edge list edge use writer tail tail b b pool next head head b initializ previou edge b stack size stack size b successor successor add successor list current block block b next current block successor current block successor b utility dump bytecode size bytecode size bytecode get size resize replace temporary jump opcode introduce label resolve resize instruction 0 0 0 size 8 length 0 cw u t f8 size + 18 + length + 8 count local var size + 8 + local var length line number size + 8 + line number length count 0 cw u t f8 size + 8 + 2 count access constant s y n t h e t i 0 cw u t f8 synthetic size + 6 access constant d e p r e t e d 0 cw u t f8 deprecate size + 6 size put bytecode given vector out vector into which bytecode must copy put vector out out put2 access put2 name index put2 desc index attribute count 0 length 0 ++attribute count count 0 ++attribute count access constant s y n t h e t i 0 ++attribute count access constant d e p r e t e d 0 ++attribute count out put2 attribute count length 0 size 12 + length + 8 count local var size + 8 + local var length line number size + 8 + line number length out put2 cw u t f8 index put4 size out put2 max stack put2 max local out put4 length put data 0 length out put2 count count 0 out put table data 0 table length attribute count 0 local var ++attribute count line number ++attribute count out put2 attribute count local var out put2 cw u t f8 local variable table index out put4 local var length + 2 put2 local var count out put local var data 0 local var length line number out put2 cw u t f8 line number table index out put4 line number length + 2 put2 line number count out put line number data 0 line number length count 0 out put2 cw u t f8 index put4 2 count + 2 out put2 count i 0 i count ++i out put2 i access constant s y n t h e t i 0 out put2 cw u t f8 synthetic index put4 0 access constant d e p r e t e d 0 out put2 cw u t f8 deprecate index put4 0 utility instruction resize use handle g o t o w j s r w resiz designate instruction keeping jump offset instruction address consistent may require resize other instruction introduce instruction example increase size an instruction 2 at middle increase offset an i f e q instruction from 32766 32768 which i f e q 32766 must replace i f n e q 8 g o t o w 32765 turn may require increase size another jump instruction so on all these operation are handle automatically p i must call after all being build ha be visit i link label label use construct are no longer valid after ha be call index current position instruction resize each instruction must designate index it i last i plus one other word index i first i i next i instruction size number i add i above instruction precisely each i lt tt len tt tt size tt i add at end instruction designate tt index tt i tt size tt i negative i last i | tt size i tt | instruction remove instruction size i must i become negative gap introduce must fill manually link get get len number instruction resize must small than equal tt index tt length tt size tt length tt index tt which now contain position resize instruction designate above resize instruction index size len b data bytecode u v label index b i j loop index 1st step explain above resize an instruction may require resize another one which may require resize yet another one so on first step algorithm consist finding all instruction need resize modify following fix point algorithm parse find jump instruction whose offset need than 2 store future offset compute from current offset from number insert remove between source target instruction each such instruction add an entry index size ha already be previou iteration at least one entry ha be add dur previou step go back beginning otherwise stop fact real algorithm complicate fact size t b l e s w i t h l o o k u p s w i t h instruction depend on their position bytecode because padding order ensure convergence algorithm number add remove from these instruction over estimate dur previou loop compute exactly only after loop finish require another pas parse bytecode all index len index all size len size resize instruction resize offset future offset jump instruction arraycopy index 0 all index 0 len arraycopy size 0 all size 0 len resize length state 3 3 loop again 2 loop end 1 last pas 0 state 3 state 2 u 0 u b length opcode b u 0x f f opcode current instruction insert 0 add after instruction writer t y p e opcode writer n o r g i n s n writer i m p l v r i n s n u + 1 writer l b e l i n s n opcode 201 convert temporary opcode 202 217 inclusive 218 219 i f e q j s r inclusive i f n u l l i f n o n n u l l opcode opcode 218 ? opcode 49 opcode 20 label u + read unsign b u + 1 label u + read b u + 1 offset get offset all index all size u label offset m i n v l u e || offset m x v l u e resize u opcode constant g o t o || opcode constant j s r two additional require replace g o t o j s r instruction g o t o w j s r w insert 2 five additional require replace i fxxx l instruction i f n o txxx l g o t o w l where i f n o txxx opposite opcode i fxxx i e i f n e i f e q where l designate instruction just after g o t o w insert 5 resize u u + 3 writer l b e l w i n s n u + 5 writer t b l i n s n state 1 number add remove from instruction future number padding current number padding previously over estimate variation 3 offset%4 3 u%4 u%4 offset%4 + u%4 u%4 offset 3 offset get offset all index all size 0 u insert offset 3 resize u over estimation number add instruction 3 current number padding 3 3 u%4 u%4 u 3 insert u 3 resize u skip instruction u u + 4 u 3 u + 4 read b u + 8 read b u + 4 + 1 + 12 writer l o o k i n s n state 1 like t b l i n s n offset get offset all index all size 0 u insert offset 3 resize u like t b l i n s n insert u 3 resize u skip instruction u u + 4 u 3 u + 8 read b u + 4 + 8 writer w e i n s n opcode b u + 1 0x f f opcode constant i i n u + 6 u + 4 writer v r i n s n writer s b y t e i n s n writer l d i n s n u + 2 writer s h o r t i n s n writer l d w i n s n writer f i e l d o r m e t h i n s n writer t y p e i n s n writer i i n i n s n u + 3 writer i t f m e t h i n s n u + 5 writer m n i n s n u + 4 insert 0 add u insert entry all index all size index all index length + 1 size all size length + 1 arraycopy all index 0 index 0 all index length arraycopy all size 0 size 0 all size length index all index length u size all size length insert all index index all size size insert 0 state 3 state 3 state state 0 2nd step copy bytecode into bytevector update offset insert remove request vector vector length u 0 u length i all index length 1 i 0 i all index i u i len size i 0 put 0 size i length + size i index i length opcode b u 0x f f writer t y p e opcode writer n o r g i n s n writer i m p l v r i n s n put1 opcode u + 1 writer l b e l i n s n opcode 201 change temporary opcode 202 217 inclusive 218 219 i f e q j s r inclusive i f n u l l i f n o n n u l l opcode opcode 218 ? opcode 49 opcode 20 label u + read unsign b u + 1 label u + read b u + 1 offset get offset all index all size u label offset m i n v l u e || offset m x v l u e replace g o t o g o t o w j s r j s r w i fxxx l i f n o txxx l g o t o w l where i f n o txxx opposite opcode i fxxx i e i f n e i f e q where l designate instruction just after g o t o w opcode constant g o t o put1 200 g o t o w opcode constant j s r put1 201 j s r w put1 opcode 166 ? opcode + 1 ^ 1 1 opcode ^ 1 put2 8 jump offset put1 200 g o t o w offset 3 offset now compute from start g o t o w put4 offset put1 opcode put2 offset u + 3 writer l b e l w i n s n label u + read b u + 1 offset get offset all index all size u label put1 opcode put4 offset u + 5 writer t b l i n s n skip 0 3 padding v u u u + 4 v 3 read copy instruction source length put1 constant t b l e s w i t h length % 4 0 put1 0 label v + read b u u + 4 offset get offset all index all size v label put4 offset j read b u u + 4 put4 j j read b u j + 1 u + 4 put4 read b u 4 j 0 j label v + read b u u + 4 offset get offset all index all size v label put4 offset writer l o o k i n s n skip 0 3 padding v u u u + 4 v 3 read copy instruction source length put1 constant l o o k u p s w i t h length % 4 0 put1 0 label v + read b u u + 4 offset get offset all index all size v label put4 offset j read b u u + 4 put4 j j 0 j put4 read b u u + 4 label v + read b u u + 4 offset get offset all index all size v label put4 offset writer w e i n s n opcode b u + 1 0x f f opcode constant i i n put b u 6 u + 6 put b u 4 u + 4 writer v r i n s n writer s b y t e i n s n writer l d i n s n put b u 2 u + 2 writer s h o r t i n s n writer l d w i n s n writer f i e l d o r m e t h i n s n writer t y p e i n s n writer i i n i n s n put b u 3 u + 3 writer i t f m e t h i n s n put b u 5 u + 5 m n i n s n put b u 4 u + 4 update instruction address local var line number table table b table data u 0 u table length b u get offset all index all size 0 read unsign b u b u + 2 get offset all index all size 0 read unsign b u + 2 b u + 4 get offset all index all size 0 read unsign b u + 4 u + 8 local var b local var data u 0 u local var length label read unsign b u offset get offset all index all size 0 label b u offset label + read unsign b u + 2 offset get offset all index all size 0 label offset b u offset u + 10 line number b line number data u 0 u line number length b u get offset all index all size 0 read unsign b u u + 4 replace old bytecode one position resize instruction index read an unsign value given b index start index value read read value read unsign b index b index 0x f f 8 | b index + 1 0x f f read sign value given b index start index value read read value read b index b index 0x f f 8 | b index + 1 0x f f read sign value given b index start index value read read value read b index b index 0x f f 24 | b index + 1 0x f f 16 | b index + 2 0x f f 8 | b index + 3 0x f f write value given b index where first value must write s value write given b index s b index s 8 b index + 1 s compute future value bytecode offset p note possible several entry same instruction tt index tt tt size tt two entry index size b index size b are equivalent single entry index size b+b index current position instruction resize each instruction must designate index it i last i plus one other word index i first i i next i instruction size number i add i above instruction precisely each i tt len tt tt size tt i add at end instruction designate tt index tt i tt size tt i negative i last i | tt size i tt | instruction remove instruction size i must i become negative begin index first source instruction end index first target instruction future value given bytecode offset get offset index size begin end offset end begin i 0 i index length ++i begin index i index i end forward jump offset + size i end index i index i begin backward jump offset size i offset current size bytecode size just include size bytecode instruction doe include size local variable table line number table synthetic deprecate attribute present current size bytecode get size length current bytecode bytecode only contain instruction doe include local variable table line number table synthetic deprecate attribute present current bytecode bytecode contain between index 0 inclusive index link get size get size exclusive get data 