display token handler convert token chunk tab size 4 indent size 4 no tab collapse fold 1 encoding utf 8 2003 g n u 2 w i t h o u t n y w r r n t y m e r h n t b i l i t y f i t n e s s f o r p r t i u l r p u r p o s e g n u g n u 59 330 m 02111 1307 u s syntax importsimport text font list text iterator text character iterator create link chunk paint on screen display token handler 23912 2015 05 17 19 44 33 ezust display token handler token handler init init some variable use when marking token call before link buffer j edit buffer mark token token handler store some data require we t want put style font render context expand out wrap margin physical line offset offset physical line which these chunk belong require implement elastic tabstop init syntax style style font render context font render context tab expand expand list chunk out wrap margin physical line offset init style style font render context font render context expand expand out out wrap margin wrap margin physical line offset physical line offset get chunk list list chunk each element head link chunk represent screen line since j edit 4 1pre7 list chunk get chunk list out handle token call token marker when syntax token ha be parse seg segment contain text token type one constant link token offset start offset token length number character token context line context since j edit 4 2pre3 override handle token segment seg offset length token marker line context context token e n d make screen line seg first branch avoid unnecessary instansiation iterator length m x h u n k l e n chunk chunk create chunk offset length context add token chunk context split token at character affect result painting iterator breaker iterator get character instance breaker set text seg token bein index seg offset + offset token end index token bein index + length split offset 0 begin index token bein index + split offset index breaker precede begin index + m x h u n k l e n + 1 care unrealistic complete there must at beginning token index iterator d o n e index begin index split after limit make chunk anyway index breaker following begin index + m x h u n k l e n there must at end token index iterator d o n e index token end index t split split length index begin index chunk chunk create chunk offset + split offset split length context add token chunk context split offset + split length split offset + m x h u n k l e n length chunk chunk create chunk offset + split offset length split offset context add token chunk context member t chunk longer than limit avoid slowing thing down example too chunk are hardly clip out at rendering m x h u n k l e n 100 instance variable syntax style style font render context font render context tab expand expand list chunk out wrap margin physical line offset create chunk chunk create chunk offset length token marker line context context chunk offset length get parser rule set context style context rule get init chunk init chunk chunk chunk x segment line text chunk init line text expand x font render context physical line offset init chunk init chunk chunk line head segment line text x 0 0f chunk chunk line head chunk chunk chunk chunk next init chunk chunk x line text x + chunk width x merge adjucent chunk merge each adjucent chunk possible reduce number chunk rendering performance merge adjucent chunk chunk line head segment line text chunk chunk line head chunk next chunk next chunk chunk next merge chunk next line text chunk length + next length chunk next next next chunk next merge merge chunk c1 chunk c2 segment line text c1 style c2 style c1 accessible c1 tab line text c2 accessible c2 tab line text c1 length + c2 length m x h u n k l e n make wrap line chunk make wrap line chunk line head virtual indent width segment line text virtual indent width 0 chunk virtual indent chunk virtual indent width line head offset line head rule init chunk virtual indent 0 line text virtual indent next line head virtual indent line head recalculate tab width all chunk are recaluculat total width fit wrap margin recalculate tab width wrap margin chunk line head segment line text x 0 0f chunk chunk line head chunk chunk chunk chunk next chunk tab line text init chunk chunk x line text x + chunk width x wrap margin end offset whitespace end offset whitespace segment line text origin offset origin offset line text count character whitespace line text line text offset + offset ++offset offset make screen line wrap margin job soft wrap feature make screen line wrap margin chunk line head segment line text end whitespace end offset whitespace line text 0 virtual indent width chunk offset x line head end whitespace line breaker line breaker line breaker line text end whitespace line breaker current line breaker d o n e there no line t wrap out add line head offset margin chunk x offset line head wrap margin offset margin 1 line breaker skip near end offset whitespace line text offset margin line line breaker current line line breaker d o n e there no line t wrap out add line head line breaker advance chunk line pre end chunk line end line head end x 0 0f line end offset + line end length line end x + line end width line pre end line end line end chunk line end next line end offset + line end length line token next head line end next line end next out add line head next head line head chunk next head chunk shorten line end snippet before line offset line init chunk shorten end x line text line pre end line pre end next shorten line head shorten out add line head chunk remain line end snippet after shorten length remain chunk may split again avoid quadratic repeatation init chunk which happen when wrap margin too small virtual space too wide split using an assumption split at line doesn t change width part before after remain room wrap margin virtual indent width process width shorten width line end width process width remain room line breaker current line breaker d o n e line breaker current remain offset + remain length offset room line end x offset process width + remain room offset room 1 line breaker skip near end offset whitespace line text offset room line breaker current line breaker d o n e remain offset + remain length happen remain end whitespace line breaker advance chunk shorten remain snippet before line offset init chunk shorten virtual indent width line text out add make wrap line shorten virtual indent width line text remain remain snippet after shorten length process width + shorten width init chunk remain virtual indent width line text remain next line end next line head remain line head make wrap line line head virtual indent width line text recalculate tab width wrap margin line head line text fit margin no need wrap out add line head make screen line make screen line segment line text first token out empty chunk line head chunk first token merge adjucent chunk line head line text end x init chunk line head line text wrap margin 0 0f end x wrap margin make screen line wrap margin line head line text out add line head line breaker line breaker d o n e 1 line breaker segment line text start offset iterator line iterator iterator set text line text offset origin line text offset current start offset line text count ? iterator following offset origin + start offset iterator d o n e next current iterator d o n e ? iterator next iterator d o n e current out offset current advance current next next iterator next skip near offset next iterator d o n e next offset origin offset advance member iterator iterator offset origin current next out offset iterator offset iterator offset iterator d o n e ? iterator offset offset origin d o n e line iterator custom iterator unify j edit s line breaking rule natural language rule line iterator iterator line iterator base iterator get line instance line iterator line iterator other base iterator other base clone override clone line iterator override current base base current acceptable base base reach end text dur base next base previou which d o n e here current last first base on which wa last direction base next d o n e ? last first override first base next base first override following offset base next base following offset override character iterator get text base get text override last base previou base last override next base next base next override next n n 1 next d o n e d o n e n next override previou base previou base previou override set text character iterator text base set text text base next base first iterator base base next base acceptable base base base next base base previou base acceptable base base base previou base acceptable base base d o n e character iterator text get text base text get begin index || base text get end index get character surround altering current index underlie text original index text get index next text set index base prev text previou text set index original index when breaking at whitespace j edit treat whitespace belonging previou line make them editable character whitespace next assume breaking white space are want only some natural language which us non s i i character otherwise keep traditional j edit behavior only at whitespace character whitespace prev || prev 0x7f || next 0x7f workaround problem report at s f net bug 3497312 unexpect softwrap contract word ??? apostrophe s f net bug 3488310 unexpect soft wrap happen at closing ldquo probably cause iterator line some simil problem are also report bug sun com http www google co jp search?q site%3 abug sun com+ iterator+get line instance there seem some problem handling quotation mark prev ??? test exclude j k character which may come after closing quote character lower next || character upper next unacceptable inside quote base text prev next retrieve at specify index altering current index character iterator at character iterator text index original index text get index text set index index text set index original index unacceptable inside quote base character iterator text prev next following quotation mark are accumulate exhibit problem local test on j r e 7u3 sample take from wikipedia http en wikipedia wiki non english usage quotation mark last check enclosing whitespace avoid unwant rejection line j k text which t such whitespace where behavior iterator reasonable ??????????? index prev 0 character whitespace next before quote base 2 begin index text get begin index before quote begin index at text before quote character whitespace character letter digit look farther where opening quote enclose someth like opening parenthesis before quote character whitespace prev ????????????????? index next 0 after quote base + 1 end index text get end index after quote end index at text after quote character whitespace character letter digit look farther where closing quote enclose someth like closing parenthesis ++aft quote 