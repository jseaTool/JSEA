s m very small fast bytecode manipulation framework 2000 i n r i france telecom 2002 france telecom library g n u less 2 at your option library w i t h o u t n y w r r n t y m e r h n t b i l i t y f i t n e s s f o r p r t i u l r p u r p o s e g n u less g n u less library 59 330 m 02111 1307 u s contact eric bruneton rd francetelecom com eric bruneton bsh objectweb asm label represent position bytecode label are use jump goto instruction block label writer which label belong tt tt unknown writer owner indicate position label know resolve position label know position number forward reference label time two reference count information about forward reference each forward reference describe two consecutive first one position first bytecode instruction contain forward reference second position first forward reference itself fact sign first indicate reference us 2 4 it absolute value give position bytecode instruction src ref position field control flow graph analysis algorithm use compute maximum stack size control flow graph contain one node p basic block one edge p jump from one basic block another each node i e each basic block represent label correspond first instruction basic block each node also store list successor graph link list edge stack size at beginning basic block size initially unknown compute control flow analysis algorithm link writer visit max visit max begin stack size relative maximum stack size correspond basic block size relative stack size at beginning basic block i e maximum stack size equal link begin stack size begin stack size + link max stack size max stack size max stack size successor node control flow graph these successor are store link list link edge edge link each other their link edge next field edge successor next basic block basic block stack link writer visit max visit max label next tt tt basic block ha be push basic block stack link writer visit max visit max push constructor construct label label compute offset manage forward reference put reference label bytecode position label know offset compute write directly otherwise offset write forward reference declare label owner writer call out bytecode source position first bytecode instruction contain label wide offset tt tt reference must store 4 tt tt must store 2 illegal argument label ha be create given writer put writer owner vector out source wide offset writer h e k owner owner owner owner owner illegal argument resolve wide offset out put4 position source out put2 position source wide offset add reference 1 source out length out put4 1 add reference source out length out put2 1 add forward reference label must call only forward reference i e only label resolve yet backward reference offset reference must compute store directly source position position reference instruction position use compute offset forward reference reference position position where offset forward reference must store add reference source position reference position src ref position src ref position 6 reference count src ref position length src ref position length + 6 arraycopy src ref position 0 0 src ref position length src ref position src ref position reference count++ source position src ref position reference count++ reference position resolve all forward reference label must call when label add bytecode i e when it position become know fill blank where left bytecode each forward reference previously add label owner writer call position position label bytecode data bytecode tt tt blank wa left label wa small store offset such correspond jump instruction replace pseudo instruction using unus opcode using an unsign two offset these pseudo instruction need replace instruction wide offset 4 instead 2 link writer resize instruction illegal argument label ha already be resolve ha be create given writer resolve writer owner position data writer h e k owner owner owner resolve || owner owner illegal argument need update resolve position position i 0 i reference count source src ref position i++ reference src ref position i++ offset source 0 offset position source offset m i n v l u e || offset m x v l u e change opcode jump instruction order able find resize instruction writer these temporary opcode are similar jump instruction opcode except 2 offset unsign therefore represent value from 0 65535 which sufficient since size limited 65535 opcode data reference 1 0x f f opcode constant j s r change i f e q j s r opcode 202 217 inclusive data reference 1 opcode + 49 change i f n u l l i f n o n n u l l opcode 218 219 inclusive data reference 1 opcode + 20 need update data reference++ offset 8 data reference offset offset position + source + 1 data reference++ offset 24 data reference++ offset 16 data reference++ offset 8 data reference offset need update 