2002 univ dept part m l l e t m achine learning languag e toolkit 1 0 information see ` l e n e mc callum test io io input stream io output stream io o io input stream io output stream io print writer io serializable io reader io writer random regex pattern junit framework test junit framework test junit framework test suite type alphabet type feature type feature vector type feature vector type instance type instance type matrix ops type type sparse vector type type pipe sequence2 pipe line group string2 pipe noop pipe pipe pipe print input target pipe serial pipe pipe target2 label pipe sequence2 feature vector pipe lowercase pipe match target pipe parse feature pipe iterator iterator pipe iterator line group iterator pipe tsf offset conjunction pipe tsf r f r f trainer label likelihood r f trainer stochastic gradient max lattice max lattice sum lattice sum lattice sum lattice scaling accuracy evaluator transducer optimize optimizable optimize test test optimizable util t o o gsc 08 25 08 some test fail because test r f trainer label likelihood instead r f optimizable label likelihood r f optimizable value gradient test r f training test r f test test r f name name matter freedom run study change improve precisely refer four kind freedom freedom run freedom study adapt need freedom redistribute you can help neighbor freedom improve release improvement whole community benefit these freedom thus you redistribute modification grati charge fee anywhere being these thing among thing you ask permission you also freedom modification them privately work play mention they you you freedom improve meaningful you access accessibility note criterion definition require careful thought interpretation decide specific qualifie we judge these criterion determine fit spirit well precise word unconscionable restriction we reject we anticipate issue these criterion sometime requirement raise issue call extensive thought discussion lawyer we can decide requirement acceptable we reach conclusion about issue we often update these criterion easy see why t these freedom real they irrevocable you nothing wrong developer power revoke anyth give kind rule about acceptable they t conflict central freedom copyleft very simply rule redistribute you cannot add restriction deny people central freedom rule conflict central freedom rath protect them thus you pay money get you obtain charge regardles you get you freedom change rule about acceptable they t block freedom release rule ``if you you also can acceptable too same note rule still leaf you choice also acceptable require you previou developer ask you send sometime government export regulation trade sanction can constrain freedom internationally developer power eliminate override these restriction what they can refuse impose them restriction activity people outside jurisdiction these government note criterion definition require careful thought interpretation decide specific qualifie we judge these criterion determine fit spirit well precise word unconscionable restriction we reject we anticipate issue these criterion sometime requirement raise issue call extensive thought discussion lawyer we can decide requirement acceptable we reach conclusion about issue we often update these criterion easy see why t g n u project launch 1984 develop complete unix operate g n u test get input vocab size 100 num 5 alphabet input alphabet alphabet 0 input vocab size i++ input alphabet lookup index feature + alphabet output alphabet alphabet r f crf r f input alphabet output alphabet name num 0 num i++ name + crf add fully connect name r f trainer label likelihood crft r f trainer label likelihood crf optimizable gradient value mcrf crft get optimizable r f instance test optimizable test get mcrf test sum log prob w1 math log 2 w2 math log 8 s1 math log 2 + 8 s2 transducer sum log prob w1 w2 equal s1 s2 0 00001 w1 math log 99999 w2 math log 0001 s1 math log 99999 0001 s2 transducer sum log prob w1 w2 equal s1 s2 0 00001 test sum lattice input vocab size 1 num 2 alphabet input alphabet alphabet 0 input vocab size i++ input alphabet lookup index feature + alphabet output alphabet alphabet r f crf r f input alphabet output alphabet name num 0 num i++ name + crf add fully connect name crf weight dimension densely crf get 0 weight 1 0 crf get 1 weight transducer m p o l e w e g h t crf get 0 weight 0 0 crf get 1 weight 0 0 crf parameter 0 0 0 transducer m p o l e w e g h t state0 self transition crf parameter 0 1 0 1 0 state0 state1 crf parameter 1 1 0 1 0 state1 self transition crf parameter 1 0 0 transducer m p o l e w e g h t state1 state0 feature vector fv feature vector feature vector feature vector alphabet crf get input alphabet 1 feature vector alphabet crf get input alphabet 1 feature vector alphabet crf get input alphabet 1 sum lattice lattice sum lattice crf fv we start state0 lattice get gamma probability 0 crf get 0 1 0 lattice get gamma probability 0 crf get 1 0 0 we go state1 lattice get gamma probability 1 crf get 0 0 0 lattice get gamma probability 1 crf get 1 1 0 self transition lattice get xi probability 1 crf get 1 crf get 1 1 0 lattice get xi probability 1 crf get 1 crf get 0 0 0 lattice weight + lattice get total weight lattice get total weight 4 0 gamma time sum 1 0 0 lattice length 1 time++ gammasum lattice get gamma probability crf get 0 + lattice get gamma probability crf get 1 equal gamma step + + sum + gammasum 1 0 gammasum 0 0001 xi time sum 1 0 0 lattice length 1 time++ xissum lattice get xi probability crf get 0 crf get 0 + lattice get xi probability crf get 0 crf get 1 + lattice get xi probability crf get 1 crf get 0 + lattice get xi probability crf get 1 crf get 1 equal xi step + + sum + xissum 1 0 xissum 0 0001 test max lattice input vocab size 1 num 2 alphabet input alphabet alphabet 0 input vocab size i++ input alphabet lookup index feature + alphabet output alphabet alphabet r f crf r f input alphabet output alphabet name num 0 num i++ name + crf add fully connect name crf weight dimension densely crf get 0 weight 1 0 crf get 1 weight transducer m p o l e w e g h t crf get 0 weight 0 0 crf get 1 weight 0 0 crf parameter 0 0 0 transducer m p o l e w e g h t state0 self transition crf parameter 0 1 0 1 0 state0 state1 crf parameter 1 1 0 1 0 state1 self transition crf parameter 1 0 0 transducer m p o l e w e g h t state1 state0 feature vector fv feature vector feature vector feature vector alphabet crf get input alphabet 1 feature vector alphabet crf get input alphabet 1 feature vector alphabet crf get input alphabet 1 max lattice lattice max lattice crf fv transducer viterbi path lattice best we start state0 viterbi path get 0 crf get 0 we go state1 viterbi path get 1 crf get 1 self transition state1 again viterbi path get 2 crf get 1 print 4 4 3 unconstrain weight 2912 0 constrain weight 428 0 max weight 35770 0 min grad 520 0 test cost save input vocab size 4 num 5 store r f f test obj f2 test object2 obj alphabet input alphabet alphabet 0 input vocab size i++ input alphabet lookup index feature + alphabet output alphabet alphabet name num 0 num i++ name + output alphabet lookup index name r f crf r f input alphabet output alphabet r f save r f crf input alphabet feature alphabet crf get input alphabet feature vector fv feature vector feature vector feature vector crf get input alphabet 1 2 3 feature vector crf get input alphabet 1 2 3 feature vector crf get input alphabet 1 2 3 feature vector crf get input alphabet 1 2 3 feature s feature crf get output alphabet 0 1 2 3 instance ilist instance noop input alphabet output alphabet ilist add fv s crf add fully connect name r f trainer label likelihood crft r f trainer label likelihood crf crft sparse weight save output stream oo output stream output stream f oo write crf oo close o e err + e err write r f err r f hyperbolic prior slope + crft get hyperbolic prior slope + hyperbolic prior sharpness + crft get hyperbolic prior sharpness + gaussian prior variance + crft get gaussian prior variance read back crf input stream ois input stream input stream f crf r f ois read ois close o e err reading + e found cnfe err cound find reading + cnfe err read r f err r f hyperbolic prior slope + crft get hyperbolic prior slope + hyperbolic prior sharpness + crft get hyperbolic prior sharpness + gaussian prior variance + crft get gaussian prior variance output stream oo output stream output stream f2 oo write crf oo close o e err + e err write r f crf save r f optimizable gradient value mcrf crft get optimizable r f ilist unconstrain weight sum lattice crf fv get total weight constrain weight sum lattice crf fv s get total weight optimizable value 0 gradient norm 0 gradient mcrf get num unconstrain cost +unconstrain cost+ constrain cost +constrain cost 0 num i++ j 0 j num j++ k 0 k input vocab size k++ crf parameter j k k + + j k + j unconstrain weight sum lattice crf fv get total weight constrain weight sum lattice crf fv s get total weight optimizable value mcrf get value mcrf get value gradient gradient gradient norm matrix ops norm gradient + + + j + + k + unconstrain weight + unconstrain weight + constrain weight + constrain weight + optimizable value + optimizable value + gradient norm + gradient norm value 35770 + optimizable value math ab optimizable value + 35770 0 001 math ab gradient norm 520 0 001 test cost test cost test cost serialize test cost test increment test r f space pipe serializable test r f space alphabet instance pipe instance carrier t carrier get t feature label seq feature get target alphabet last space buffer sb buffer 0 t size i++ t t get t get equal last space sb append t get t add t label seq add last space ? start notstart last space target processing carrier target label seq carrier t carrier sb carrier serial u 1 u r r e n t e r l v e r o n 0 write output stream o write u r r e n t e r l v e r o n read input stream o found read test r f2 pipe serializable test r f2 instance pipe instance carrier buffer sb buffer carrier get carrier get target start label index get alphabet lookup index start 0 length i++ target + + + get get equal start 0 sb append sb append carrier sb carrier get + carrier get carrier serial u 1 u r r e n t e r l v e r o n 0 write output stream o write u r r e n t e r l v e r o n read input stream o found read test value gradient test space prediction test train test space prediction test space prediction test value gradient pipe p space prediction pipe pipe p2 test r f2 instance instance instance p instance add thru pipe iterator instance list instance split random 1 5 5 r f crf r f p p2 crf add fully connect label r f trainer label likelihood crft r f trainer label likelihood crf test value gradient optimizable gradient value optable crft get optimizable r f list 0 test optimizable test value gradient minable gradient optable get num optable get value gradient gradient test optimizable test value gradient direction optable gradient test optimizable test value gradient current optable test optimizable test value gradient optable test current purturb toward gradient training accuracy training + crf average accuracy list 0 testing accuracy training + crf average accuracy list 1 training crft train incremental list 0 training accuracy training + crf average accuracy list 0 testing accuracy training + crf average accuracy list 1 training result 0 list 0 size i++ instance inst list 0 get input inst get output crf transduce input output testing result 0 list 1 size i++ instance inst list 1 get input inst get output crf transduce input output test space prediction test value gradient save sparse weight pipe p space prediction pipe r f save r f f test obj instance instance instance p instance add thru pipe iterator instance list instance split 5 5 r f crf r f p get alphabet p get target alphabet crf add fully connect label r f trainer label likelihood crft r f trainer label likelihood crf crft sparse weight sparse weight test value gradient optimizable gradient value minable crft get optimizable r f list 0 test optimizable test value gradient minable training accuracy training + crf average accuracy list 0 testing accuracy training + crf average accuracy list 1 save r f crf training serialize crf crft train incremental list 0 pre train acc crf average accuracy list 0 pre test acc crf average accuracy list 1 training accuracy training + pre train acc testing accuracy training + pre test acc output stream oo output stream output stream f oo write crf oo close o e err + e err write r f err r f hyperbolic prior slope + crft get hyperbolic prior slope + hyperbolic prior sharpness + crft get hyperbolic prior sharpness + gaussian prior variance + crft get gaussian prior variance read back save crf input stream ois input stream input stream f crf r f ois read ois close o e err reading + e found cnfe err cound find reading + cnfe err read r f crf save r f post train acc crf average accuracy list 0 post test acc crf average accuracy list 1 training accuracy saving + post train acc testing accuracy saving + post test acc equal post train acc pre train acc 0 0001 equal post test acc pre test acc 0 0001 pipe space prediction pipe pipe p serial pipe pipe sequence2 lowercase test r f space offset conjunction 0 1 1 0 original test have too 1 1 0 0 1 0 1 comment next line run fast we need adjust likelihood accuracy test value akm 12 2007 t o o uncomment line 2 1 0 0 1 2 3 2 1 1 2 3 these be comment 2 1 1 0 0 1 1 2 3 2 1 2 1 0 1 0 1 0 1 2 1 2 3 print input target sequence2 feature vector p test add n pipe p space prediction pipe instance instance instance p instance add thru pipe iterator instance list instance split random 678 5 5 compare 3 r f train add n sure have feature high likelihood r f crf1 r f p get alphabet p get target alphabet crf1 add n list 0 1 t r t r f trainer label likelihood crf1 train incremental list 0 r f crf2 r f p get alphabet p get target alphabet crf2 add n list 0 1 2 t r t r f trainer label likelihood crf2 train incremental list 0 r f crf3 r f p get alphabet p get target alphabet crf3 add n list 0 1 2 t r t r f trainer label likelihood crf3 train incremental list 0 prevent cache value lik1 get likelihood crf1 list 0 lik2 get likelihood crf2 list 0 lik3 get likelihood crf3 list 0 r f1 likelihood + lik1 zero likelihood + lik1 + great first + lik2 + lik1 lik2 likelihood + lik2 + great full first + lik3 + lik2 lik3 equal 167 2234457483949 lik1 0 0001 equal 165 81326484466342 lik2 0 0001 equal 90 37680146432787 lik3 0 0001 get likelihood r f crf instance r f trainer label likelihood crft r f trainer label likelihood crf optimizable gradient value mcrf crft get optimizable r f elaborate thing crf cache value stale force mcrf get num mcrf get mcrf mcrf get value test freeze weight pipe p space prediction pipe instance instance instance p instance add thru pipe iterator r f crf1 r f p get alphabet p get target alphabet crf1 add fully connect label r f trainer label likelihood crft1 r f trainer label likelihood crf1 crft1 train incremental instance r f crf2 r f p get alphabet p get target alphabet crf2 add fully connect label freeze some weight training 0 crf2 get weight length + 2 crf2 freeze weight r f trainer label likelihood crft2 r f trainer label likelihood crf2 crft2 train incremental instance sparse vector w crf2 get weight crf2 get weight 0 w length + 2 equal 0 0 1e 10 loc 0 loc w num location loc++ equal 0 0 w value location loc 1e 10 check freeze weight worse likelihood optimizable gradient value optable1 crft1 get optimizable r f instance optimizable gradient value optable2 crft2 get optimizable r f instance val1 optable1 get value val2 optable2 get value freezing weight harm log likelihood full + val1 + freeze + val2 val1 val2 test dense train test space prediction test train stochastic gradient pipe p space prediction pipe pipe p2 test r f2 instance instance instance p instance add thru pipe iterator instance list instance split 5 5 r f crf r f p p2 crf add fully connect label crf weight dimension list 0 r f trainer stochastic gradient crft r f trainer stochastic gradient crf 0 0001 training accuracy training + crf average accuracy list 0 testing accuracy training + crf average accuracy list 1 training fix learning rate select sample crft learning rate likelihood list 0 crft learning rate 0 01 crft train list 0 100 crf print training accuracy training + crf average accuracy list 0 testing accuracy training + crf average accuracy list 1 test sum lattice pipe p space prediction pipe pipe p2 test r f2 first normal training getting weight instance instance instance p instance add thru pipe iterator instance list instance split 5 5 r f crf r f p p2 crf add fully connect label crf weight dimension list 0 r f trainer stochastic gradient crft r f trainer stochastic gradient crf 0 0001 training accuracy training + crf average accuracy list 0 testing accuracy training + crf average accuracy list 1 training fix learning rate select sample crft learning rate likelihood list 0 crft learning rate 0 01 crft train list 0 100 crf print training accuracy training + crf average accuracy list 0 testing accuracy training + crf average accuracy list 1 now check speed sum lattice v sum lattice scaling total 0 total scaling 0 it 0 it 10000 iter++ 0 list 1 size ii++ feature vector input feature vector list 1 get get total current milli sum lattice lattice sum lattice crf input total + current milli total scaling current milli sum lattice scaling lattice sum lattice scaling crf input total scaling + current milli it 0 check total weight same equal lattice get total weight scaling lattice get total weight 0 0001 check gamma g1 lattice get gamma g2 scaling lattice get gamma 0 g1 length i++ j 0 j g1 length j++ equal g1 j g2 j 0 0001 check xi match x1 lattice get xi x2 scaling lattice get xi 0 x1 length i++ j 0 j x1 length j++ k 0 k x1 j length k++ equal x1 j k x2 j k 0 0001 it + 1 % 100 0 print it + 1 + flush it + 1 % 1000 0 m + total m scaling + total scaling total scaling total sum lattice f t w diff + total scaling total + m sum lattice scaling f t w diff + total total scaling + m test serialization test space prediction test dense serialization test space prediction test accuracy pipe p space prediction pipe instance instance instance p instance add thru pipe iterator instance list instance split random 777 5 5 r f crf r f p get alphabet p get target alphabet crf add fully connect label r f trainer label likelihood crft r f trainer label likelihood crf crft sparse weight crft train incremental list 0 accuracy evaluator eval accuracy evaluator list train test eval evaluate instance crft list 1 test equal 0 9409 eval get accuracy test 0 001 test print pipe p serial pipe pipe sequence2 test r f space sequence2 feature vector print input target instance instance p e add thru pipe iterator r f crf r f p crf add fully connect three quarter label r f trainer label likelihood crft r f trainer label likelihood crf crf weight dimension optimizable mcrf crft get optimizable r f mcrf get num 0 length i++ mcrf crf print test weight pipe p serial pipe pipe sequence2 test r f space sequence2 feature vector print input target instance instance p e add thru pipe iterator r f crf r f p crf add fully connect label r f trainer label likelihood crft r f trainer label likelihood crf crf weight dimension optimizable gradient value mcrf crft get optimizable r f mcrf get num 0 length i++ mcrf writer writer crf print print writer r f1 crf print r f r f crf2 r f crf writer out2 writer crf2 print print writer out2 r f2 crf2 print equal out2 val1 mcrf get value r f trainer label likelihood crft2 r f trainer label likelihood crf2 val2 crft2 get optimizable r f get value equal val1 val2 1e 5 toy test start pipe p serial pipe pipe line group string2 match target pattern compile ^ \\ s+ 2 1 parse feature sequence2 feature vector target2 label print input target instance instance p add thru pipe line group iterator reader toy pattern compile r f crf r f p crf print crf add label connect crf add start r f trainer label likelihood crft r f trainer label likelihood crf optimizable gradient value maxable crft get optimizable r f equal 1 3862 maxable get value 1e 4 crf r f p crf add n 1 crf print crft r f trainer label likelihood crf maxable crft get optimizable r f equal 3 09104245335831 maxable get value 1e 4 test weight dimension densely respect feature selection test dense feature selection pipe p space prediction pipe instance instance instance p instance add thru pipe iterator test dense observation wight aren t feature edge r f crf1 r f p crf1 add n instance 0 start r f trainer label likelihood crft1 r f trainer label likelihood crf1 crft1 sparse weight crft1 train instance 1 weight dimension n params1 crft1 get optimizable r f instance get num r f crf2 r f p crf2 add n instance 0 1 start r f trainer label likelihood crft2 r f trainer label likelihood crf2 crft2 sparse weight crft2 train instance 1 weight dimension n params2 crft2 get optimizable r f instance get num equal n params2 n params1 + 4 test xi pipe p space prediction pipe instance instance instance p instance add thru pipe iterator r f crf1 r f p crf1 add fully connect label r f trainer label likelihood crft1 r f trainer label likelihood crf1 crft1 train instance 10 let get some instance inst instance get 0 input inst get sum lattice lattice sum lattice crf1 input inst get target ip 0 ip lattice length 1 ip++ 0 crf1 num i++ transducer crf1 get transducer transition iterator transition iterator input ip gamma lattice get gamma probability ip xi sum 0 next transducer d next xi lattice get xi probability ip d xi sum + xi equal gamma xi sum 1e 5 test suite test suite test r f test add weight pipe p space prediction pipe m e m m space prediction pipe t know why akm 12 2007 instance training instance p training add thru pipe iterator m e m m t know why akm 12 2007 r f crf r f p crf add fully connect label r f trainer label likelihood crft r f trainer label likelihood crf crft train incremental training check notstart test input training get 0 get output max lattice crf input best output notstart found 0 output size i++ output get equal notstart notstart found err output notstart found now add infinite weight onto transition sure honor r f crf get notstart widx crf get weight index bad bad num feature crf get input alphabet size sparse vector w sparse vector num feature w n e g t v e n f n t y crf weight widx w add weight 0 bad bad add weight 1 bad bad verify prevent notstart being output max lattice crf input best output notstart found 0 output size 1 i++ output get equal notstart notstart found notstart found old crf test base crf cnl03 s gz test john n n p n p o doe n n p n p o say v z v p o hi n n n p o skipt old crf r f crf r f util read old crf instance inst crf get input pipe instance instance test output crf transduce inst get std output equal p e r p e r o o std test suite suite length 0 suite test suite 0 length i++ suite add test test r f suite test suite suite junit textui test runner run suite 