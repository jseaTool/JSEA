logging level logging logger sum lattice lattice node transducer transducer transition iterator type dense vector type label alphabet type label vector type matrix ops type logger sum lattice constrain sum lattice logger logger logger get logger sum lattice constrain get name sum lattice constrain transducer t input output segment segment constrain t input output transducer incrementor constraint t input output segment constrain constraint transducer t input output segment segment constrain constrain size input size illegal argument constrain size + constrain size + input size + input size + constraint tell lattice emit observation positive value say path pas index negative value say path pas index 0 we t care initialize 0 1 extra node start constraint constrain size + 1 0 constraint length c++ constraint 0 segment get start segment get i++ si t index constrain get si 1 logger warning could find + constrain get + check label match start tage tag label see training illegal argument could find + constrain get + check label match start tag tag constraint i+1 si + 1 additional negative constraint ensure segment tag xxx segment length 1 actually constrain tag tag instead constraint tag tag fix below unsafe now f e e l o w tag constrain get segment get segment get +2 constraint length segment get start segment get segment length 1 tag start tag + tag substring 1 tag length tag start || tag start 0 illegal argument constrain lattice tag o format statei index tag statei 1 tag tag statei index constrain get segment get start constraint segment get + 2 statei + 1 segment get + 2 constraint length tag segment get tag statei t index tag statei 1 illegal argument could find + tag + check label match start tag tag constraint segment get + 2 statei + 1 print logger fine segment + segment + constrain + constrain + constraint 0 constraint length i++ logger fine constraint + logger fine constraint culotta constructor constrain lattice lattice constrain transition position label pair constraint adhere constraint entry index label position entry 0 there constraint position label positive value path pas negative value path pas n o t e constraint length equal output size + 1 lattice extra position generally unconstrain since produce observation sum lattice constrain transducer tran input output transducer incrementor incrementor label alphabet output alphabet constraint logger loggable level f n e logger fine starting lattice logger fine input ip 0 ip input size ip++ logger fine + input get ip logger fine output output logger fine op 0 op output size op++ logger fine + output get op logger fine initialize some structure t tran input input output output xxx very efficient lattice actually sparse especially large lattice length input size +1 num t num node lattice node lattice length num xxx yipe could get big someth sparse better? gamma lattice length num xxx move ivar we can save it? what? comment because memory hog now uncomment conditionalize flag ev ca xi lattice length num num output count output alphabet output count lattice length output alphabet size 0 num i++ ip 0 ip lattice length ip++ gamma ip transducer m p o l e w e g h t comment xi ca j 0 j num j++ ip 0 ip lattice length ip++ xi ip j m p o l e w e g h t forward pas logger fine starting constrain foward pas ensure least weight great infinity we can start there least 0 num i++ weight t get get weight forward pas weight +initial weight weight transducer m p o l e w e g h t get lattice node 0 alpha weight node 0 alpha +node 0 alpha least least logger warning there starting ip 0 ip lattice length 1 ip++ 0 num i++ logger fine ip + ip+ + check node possible position label skip constraint ip 0 index constraint ip 1 constraint ip 1 logger fine current match positive constraint position +ip+ constraint + constraint ip 1 + curr +i constraint ip 0 index constraint ip constraint ip +1 logger fine current match negative constraint position +ip+ constraint + constraint ip +1 + curr +i node ip || node ip alpha transducer m p o l e w e g h t xxx we up lot we could save one node ip logger fine node ip n u l l node ip alpha transducer m p o l e w e g h t logger fine node ip alpha inf logger fine n f n t e weight n u l l skip t get transition iterator it transition iterator input ip output ip logger loggable level f n e logger fine starting forward transition iteration + get name + input + input get ip + output + output ? output get ip it next destination it next transition check constraint see node ip can transition destination ip+1 constraint length constraint ip+1 0 constraint ip+1 1 destination get index logger fine destination match positive constraint assigning infinite weight position + ip+1 + constraint + constraint ip+1 1 + +i+ destination +destination get index transition ip+1 constraint length constraint ip+1 0 constraint ip+1 +1 destination get index logger fine destination match negative constraint assigning infinite weight position + ip+1 + constraint + constraint ip+1 +1 + destination +destination get index transition logger loggable level f n e logger fine forward lattice input po +ip + + get name + d +destination get name + lattice node destination node get lattice node ip+1 destination get index destination node output it get output transition weight it get weight transition logger loggable level f n e logger fine transition weight +transition weight + node +ip+ +i+ alpha +node ip alpha + destination node alpha +destination node alpha destination node alpha transducer sum log prob destination node alpha node ip alpha + transition weight destination node alpha +destination node alpha logger fine alpha lattice node ip + ip+1 + index + destination get index + destination node alpha + destination node alpha illegal transition accord our constraint prob 0 n o alpha unnormaliz weight inf destination node alpha 0 0 destination node alpha m p o l e w e g h t logger fine illegal transition + + + destination get index + setting alpha inf calculate total weight lattice normalizer total weight transducer m p o l e w e g h t 0 num i++ node lattice length 1 note actually we could sum ip index choice lattice length 1 arbitrary ending alpha +i+ +node lattice length 1 alpha ending beta +i+ +get weight constraint lattice length 1 0 constraint lattice length 1 1 constraint lattice length 1 0 constraint lattice length 1 +1 logger fine sum lattice weight +i+ alpha +node lattice length 1 alpha + weight +t get get weight total weight transducer sum log prob total weight node lattice length 1 alpha + t get get weight weight now unnormaliz weight entire lattice weight 0 weight +weight infinite weight just usefully avoid calling increment also relie fact gamma alpha beta value already initialize value reflect infinite weight xxx perhap alpha beta exactly correctly reflecting? total weight transducer m p o l e w e g h t backward pas 0 num i++ node lattice length 1 t get node lattice length 1 beta get weight gamma lattice length 1 node lattice length 1 alpha + node lattice length 1 beta total weight incrementor p math gamma lattice length 1 p 0 0 p 1 0 na n p p +p+ gamma +gamma lattice length 1 incrementor increment p ip lattice length 2 ip 0 ip 0 num i++ node ip || node ip alpha transducer m p o l e w e g h t note skip here alpha beta value won t correct since alpha infinite anyway shouldn t matter t get transition iterator it transition iterator input ip output ip it next destination it next logger loggable level f n e logger fine backward lattice input po +ip + + get name + d +destination get name + j destination get index lattice node destination node node ip+1 j destination node transition weight it get weight na n transition weight transition weight 0 old beta node ip beta na n node ip beta node ip beta transducer sum log prob node ip beta destination node beta + transition weight na n node ip beta d beta +destination node beta+ tran +transition weight+ sum + destination node beta+transition weight + old beta +old beta xi ip j node ip alpha + transition weight + node ip+1 j beta weight na n node ip alpha na n transition weight na n node ip+1 j beta na n total weight incrementor || output alphabet xi node ip alpha + transition weight + node ip+1 j beta total weight p math xi p transducer m p o l e w e g h t na n p xi +ip+ +i+ +j+ +xi incrementor incrementor increment transition it p output alphabet output index output alphabet lookup index it get output output index 0 xxx ip op output count ip output index + p r f lattice output count +ip+ +output index+ + +p gamma ip node ip alpha + node ip beta total weight incrementor 0 num i++ p math gamma 0 p transducer m p o l e w e g h t na n p incrementor increment t get p output alphabet labeling label vector lattice length ip lattice length 2 ip 0 ip math ab 1 0 matrix ops sum output count ip 0 000001 labeling ip label vector output alphabet output count ip transducer still apply? still need addressing? akm culotta constrain lattice constrain lattice path pas label segment indicate constrain input input output output segment segment label constrain lattice label segment start segment correctly lattice forward backward input output segment segment constrain constrain size input size illegal argument constrain size + constrain size + input size + input size + constraint tell lattice emit observation positive value say path pas index negative value say path pas index 0 we t care initialize 0 1 extra node start constraint constrain size + 1 0 constraint length c++ constraint 0 segment get start segment get i++ si index constrain get si 1 logger warning could find + constrain get + check label match start tage tag label see training illegal argument could find + constrain get + check label match start tag tag constraint i+1 si + 1 additional negative constraint ensure segment tag xxx segment length 1 actually constrain tag tag instead constraint tag tag fix below unsafe now f e e l o w tag constrain get segment get segment get +2 constraint length segment get start segment get segment length 1 tag start tag + tag substring 1 tag length tag start || tag start 0 illegal argument constrain lattice tag o format statei index tag statei 1 tag tag statei index constrain get segment get start constraint segment get + 2 statei + 1 segment get + 2 constraint length tag segment get tag statei index tag statei 1 logger fine could find + tag + check label match start tag tag constraint segment get + 2 statei + 1 logger fine segment + segment + constrain + constrain + constraint 0 constraint length i++ logger fine constraint + logger fine forward backward input output constraint 