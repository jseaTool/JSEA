2002 univ dept part m l l e t m achine learning languag e toolkit 1 0 information see ` l e n e type io reflect reflect invocation target vector allocate memory zero value you sparse vector you pas index these element vector you allow change rest fix 0 sparse vector us concept location range 0 num location can map index value zero element vector sparse vector can sparse dense depend index specify construction sparse vector dense mapping location index identity mapping type value element sparse vector feature vector can binary 0 0 1 0 depend specify contruction mc callum sparse vector constant matrix vector serializable vector sparse both index value sparse index into these call ``location below index map location index virtual dense being represent value map location value index vector dense value vector binary infinite least value inf + inf index vector dense value vector binary capacity size argument augmentable feature vector sparse vector index value capacity size check index sort duplicate size pretty much ignored??? why? length length size capacity length capacity length size length value || index || index length value length illegal argument attempt sparse binary sparse vector mismatch value index + index length +indice length+ value length +value length || capacity length index index index capacity arraycopy index 0 index 0 length value value value capacity arraycopy value 0 value 0 length index index value value check index sort sort index also remove duplicate duplicate duplicate 0 dense vector sparse vector value value value length value length sparse vector value value sparse vector size fill value value size fill value sparse vector index value check index sort duplicate index value index ? index length value length index ? index length value length check index sort duplicate sparse vector index value index value sparse vector index value index value sparse vector index value check index sort index value check index sort vector possibly binary binary sparse vector index check index sort duplicate binary index binary ? value index length 1 0 index length index length check index sort duplicate binary vector sparse vector index capacity size check index sort duplicate index capacity size check index sort duplicate sparse vector index check index sort index check index sort sparse vector index index sparse vector index index empty vector zero value sparse vector 0 0 sparse vector alphabet dict pl binary grow alphabet pl xxx fix sparse vector can properly represent vector zero work? index 0 value iterator it binary binary feature binary binary sparse vector constructor argument binary significantly save space well multiplication late akm 12 2007 it pl numeric iterator it next it next it get numeric value 1 0 binary augmentable feature vector afv augmentable feature vector dict binary afv print sparse vector binary +binary pl print it pl numeric iterator it next it next sparse vector add +it get key + +it get numeric value index dict lookup index it get key grow alphabet index 0 afv add index it get numeric value sparse vector afv add +it get key + afv num location +afv num location afv print xxx efficient? sparse vector sv afv sparse vector sparse vector sv num location +sv num location index sv index value sv value sparse vector alphabet dict pl binary dict pl binary value length value ret length fill ret value ret binary value binary unsupport operation yet binary unsupport operation yet e o r get num dimension 1 xxx what we length? could high index get dimension size index size 0 value length xxx pretty unsatisfactory since there zero value location size 0 index index length 1 1 v m dmetzl careful allow ca get index index v m dmetzl careful allow ca get value value xxx just zero entry different behavior matrix2 num location value ? index ? 0 index length value length location index index index binary search index index value location location value ? 1 0 value location index location location index ? location index location value index index length 1 index value index 0 value location index 0 value index index value index index bound e 0 0 loc location index loc 0 0 0 value 1 0 value loc add accumulator scale index 0 value length i++ accumulator + value scale value 0 index length i++ accumulator index + scale 0 index length i++ accumulator index + value scale add accumulator add accumulator 1 0 single index index index length 1 index 0 single index index index 0 single value value single size index value length index length 0 0 just high index zero value full size dimension unknown index index length 1 line buffer sb buffer 0 value length i++ sb append index ? index sb append sb append value line sb append sb append sb l o n n g constant matrix clone matrix index sparse vector value sparse vector index value constant matrix clone matrix zero index sparse vector value length index index length arraycopy index 0 index 0 index length sparse vector index value length m u t t o r index present vector + v v index present these just ignore plus equal sparse sparse vector v plus equal sparse v 1 0 index present vector + factor v v index present these just ignore plus equal sparse sparse vector v factor dense sparse vector index dense plus equal sparse v factor loc1 0 loc2 0 num locations1 num location num locations2 v num location loc1 num locations1 loc2 num locations2 idx1 index location loc1 idx2 v index location loc2 idx1 idx2 value loc1 + v value location loc2 factor ++loc1 ++loc2 idx1 idx2 ++loc1 idx2 present ignore ++loc2 index present vector v v index present these just ignore time equal sparse sparse vector v time equal sparse v 1 0 index present vector factor v v index present these just ignore time equal sparse sparse vector v factor dense sparse vector index dense time equal sparse v factor loc1 0 loc2 0 loc1 num location loc2 v num location idx1 index location loc1 idx2 v index location loc2 idx1 idx2 value loc1 v value location loc2 factor ++loc1 ++loc2 idx1 idx2 ++loc1 idx2 present ignore ++loc2 index present vector factor v v index present these zero time equal sparse zero sparse vector v factor dense sparse vector index dense time equal sparse v factor loc1 0 loc2 0 loc1 num location loc2 v num location idx1 index location loc1 idx2 v index location loc2 idx1 idx2 value loc1 v value location loc2 factor ++loc1 ++loc2 idx1 idx2 idx1 present v zero value loc1 0 ++loc1 idx2 present ignore ++loc2 scale element same factor time equal factor 0 value length i++ value factor dense plus equal sparse sparse vector v factor maxloc v num location loc 0 loc maxloc loc++ idx v index location loc idx value length value idx + v value location loc factor dense time equal sparse sparse vector v factor maxloc v num location loc 0 loc maxloc loc++ idx v index location loc idx value length value idx v value location loc factor increment index value illegal argument index present increment value index value illegal argument loc location index loc 0 value loc + value illegal argument value isn t present sparse vector set present index vector v v 0 value length i++ value v set value index illegal argument index present value index value illegal argument index value index value loc location index loc 0 illegal argument can t insert value into sparse vector value loc value set value location value location location value value location value value into vector same size vector yank dense vector 0 value starting location into vector least many value beyond starting location there vector next uncopi location starting location arraycopy starting location value 0 value length starting location + value length applie argument value binary vector both argument illegal argument argument inappropriate signature unsupport operation vector binary illegal access inaccessible throwable relay map f illegal access throwable value unsupport operation binary value alter via map f get parameter type length 1 || f get parameter type 0 || f get type illegal argument signature \ f \ 0 value length i++ value f value value invocation target e e get target content vector into starting location next location into starting location arraycopy value 0 starting location value length starting location + value length v e t o r o p e r t o n dot v ret 0 value 0 index length i++ ret + v index 0 index length i++ ret + value v index ret dot constant matrix m m sparse vector dot sparse vector m m dense vector dot dense vector m illegal argument unrecogniz matrix type +m get dot dense vector v v infinite || infinite extend dot v ret 0 value 0 index length i++ ret + v value index 0 index length i++ ret + value v value index na n ret extend dot v ret set inf 0 0 inf 0 0 extend dot dense vector v ret 0 value 0 index length i++ ret + v value index 0 index length i++ infinite value v value index 0 0 infinite infinite v value index value 0 0 v infinite ret + value v value index ret dot sparse vector v v infinite || infinite extend dot v ret decide direction dot heuristic choice efficiency could certainly complicate v index sparse vector ret v dot num location v num location ret dot internal v ret dot internal v na n ret extend dot v ret dot internal sparse vector v sparse vector v ret 0 num loc v num location v binary 0 num loc i++ ret + v value v index location 0 num loc i++ v1 v value location v2 v value v index location ret + v1 v2 ret set inf 0 0 inf 0 0 extend dot sparse vector v ret 0 0 sparse vector v sparse vector v ensure minimal computational effort num location v num location v v v v v v 0 v num location i++ v1 v value location v2 v value v index location infinite v1 v2 0 0 v infinite infinite v2 v1 0 0 v infinite ret + v1 v2 ret sparse vector vector add sparse vector v scale index sparse sparse vector ind v get index val v get value index ind length+indice length val ind length+indice length 0 index length i++ index index val value 0 ind length i++ index i+indice length ind val i+indice length scale val sparse vector index val index value length val value length dense sparse vector cur po 0 0 value length i++ val value +scale v value val 0 0 index cur po val cur pos++ val sparse vector index val norm ret 0 value index length 0 value length i++ ret + value ret ab norm ret 0 value index length 0 value length i++ ret + math ab value ret two norm ret 0 value math sqrt index length 0 value length i++ ret + value value math sqrt ret infinity norm value 1 0 max n e g t v e n f n t y 0 value length i++ math ab value max max math ab value max print value binary sparsevector 0 index length i++ sparse vector +indice + 1 0 0 value length i++ idx index ? index sparse vector +idx+ +value na n value matrix ops na n value 0 value length i++ na n value gsc similar na n check infinite value infinite value matrix ops infinite value gsc value na n infinite na n infinite value matrix ops na n infinite value sort index sort index limin yao index dense thus definition sort value sort index just bubble sort efficient already mostly sort note we bubble sort forward most efficient we few additional item previously sort we could much smart we remember high index already sort index length 1 0 swap j 0 j j++ index j index j+1 swap both index value f f index j index j index j+1 index j+1 f value v v value j value j value j+1 value j+1 v swap swap value num duplicate 0 1 index length i++ index 1 index num duplicates++ num duplicate 0 duplicate num duplicate argument zero value meaning function count them duplicate num duplicate num duplicate 0 1 index length i++ index 1 index num duplicates++ num duplicate 0 index index length num duplicate value value ? index length num duplicate index 0 index 0 value value 0 value 0 1 j 1 index length i++ index index 1 value value j 1 + value index j index value value j value j++ index index value value serialization serial u 2 u r r e n t e r l v e r o n 1 write output stream o augmentable feature vector sure sort compress our we write augmentable feature vector sort index write u r r e n t e r l v e r o n write index ? 1 index length write value ? 1 value length index 0 index length i++ write index value 0 value length i++ write value read input stream o found read index size read value size read infinite index size 0 index index size 0 index size i++ index read value size 0 value value size 0 value size i++ value read infinite value infinite 