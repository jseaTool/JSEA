logging level logging logger transducer transducer transition iterator type dense vector type label alphabet type label vector type matrix ops type type pair logger p l n e w e m forward backward sum lattice beam sum lattice p l lattice max get viterbi path p l these work well nettalk beam width 10 k lep 005 forward backward beam beam width 3 k lep 0 rmin 0 1 nstate expl cur it 0 tct it 0 time we be call iteration cur avg nstate expl get beam width beam width beam width beam width beam width beam width get tct it tct it cur it cur it cur it cur it tct it 0 inc it tct iter++ k lep k lep k lep k lep rmin rmin rmin rmin get nstate expl nstate expl get forward backward beam forward backward beam forward backward beam forward backward beam logger logger logger get logger sum lattice beam get name ip input position op output position index transducer t weight input output lattice node node index ip lattice length cur beam width p l can adapt maximiz confuse xxx now we increment here directly there isn t need save these log probability being input position ip gamma index ip xi index ip j save save xi label vector labeling index op create output alphabet constructor lattice node get lattice node ip index node ip index node ip index lattice node ip t get index node ip index you pas output meaning lattice constrain match output sum lattice beam transducer t input output transducer incrementor incrementor t input output incrementor you pas output meaning lattice constrain match output sum lattice beam transducer t input output transducer incrementor incrementor save xi t input output incrementor save xi output alphabet label vector position output indicate probability over possible output index sum lattice beam transducer t input output transducer incrementor incrementor save xi label alphabet output alphabet t t logger loggable level f n e logger fine starting lattice logger fine input ip 0 ip input size ip++ logger fine + input get ip logger fine output output logger fine op 0 op output size op++ logger fine + output get op logger fine initialize some structure input input output output xxx very efficient lattice actually sparse especially large lattice length input size +1 num t num node lattice node lattice length num xxx yipe could get big someth sparse better? gamma lattice length num save xi xi lattice length num num output count output alphabet output count lattice length output alphabet size 0 num i++ ip 0 ip lattice length ip++ gamma ip transducer m p o l e w e g h t save xi j 0 j num j++ ip 0 ip lattice length ip++ xi ip j transducer m p o l e w e g h t forward pas logger fine starting foward pas least 0 num i++ weight t get get weight forward pas weight +initial weight weight transducer m p o l e w e g h t get lattice node 0 alpha weight node 0 alpha +node 0 alpha least least logger warning there starting p l sort our beam experiment n best slist slist n best slist lattice length p l stat nstate expl lattice length p l adapt beam optimiz getting confuse tct iter++ cur it 0 cur beam width num tct it 1 cur it 0 cur beam width math min math round cur avg nstate expl 2 num doubling beam size +cur beam width cur beam width beam width cur beam width beam width ip 0 ip lattice length 1 ip++ p l add construct beam p l set up sort slist ip n best slist num p l slist ip k l min e cur beam width slist ip k lep k lep slist ip rmin rmin 0 num i++ node ip || node ip alpha transducer m p o l e w e g h t t get p l give n viterbi node weight position n back node cnode n back node node ip alpha slist ip push cnode p l unlike std n best beam we now filter k l divergence measure compute cumulative log sum find point sum k lep k l max po 1 rmin po 1 k lep 0 k l max po slist ip get k lpo nstate expl ip k l max po k lep 0 rmin 0 rmin po slist ip get t h rpo slist ip rmin rmin rmin po slist ip get t h rpo t r w m n nstate expl ip rmin po trick negative value k lep max k l rmin slist ip k lep k lep k l max po slist ip get k lpo rmin po slist ip get t h rpo rmin 0 rmin po slist ip get t h rpo slist ip rmin rmin rmin po slist ip get t h rpo t r w m n k l max po rmin po nstate expl ip k l max po nstate expl ip rmin po nstate expl ip + p l contemplate setting value someth tmppo nstate expl ip +1 slist ip size i++ tmppo slist ip get po index node ip tmppo alpha transducer m p o l e w e g h t node ip tmppo fast seem work same contemplation 0 num i++ jj 0 jj nstate expl ip jj++ slist ip get po index jj p l dont need anymore take care list node ip || node ip alpha transducer m p o l e w e g h t xxx we up lot we could save one t get transition iterator it transition iterator input ip output ip logger loggable level f n e logger fine starting foward transition iteration + get name + input + input get ip + output + output ? output get ip it next destination it next logger loggable level f n e logger fine forward lattice input po +ip + + get name + d +destination get name + lattice node destination node get lattice node ip+1 destination get index destination node output it get output transition weight it get weight logger loggable level f n e logger fine transition weight +transition weight + node +ip+ +i+ alpha +node ip alpha + destination node alpha +destination node alpha destination node alpha transducer sum log prob destination node alpha node ip alpha + transition weight destination node alpha +destination node alpha node explore + matrix ops nstate expl cur avg nstate expl matrix ops nstate expl calculate total cost lattice normalizer weight transducer m p o l e w e g h t 0 num i++ node lattice length 1 note actually we could sum ip index choice lattice length 1 arbitrary ending alpha +i+ +node lattice length 1 alpha ending beta +i+ +t get weight weight transducer sum log prob weight node lattice length 1 alpha + t get get weight weight now unnormaliz weight entire lattice weight 0 weight +weight infinite weight just usefully avoid calling increment also relie fact gamma alpha beta value already initialize value reflect infinite weight xxx perhap alpha beta exactly correctly reflecting? weight transducer m p o l e w e g h t backward pas 0 num i++ node lattice length 1 t get node lattice length 1 beta get weight gamma lattice length 1 node lattice length 1 alpha + node lattice length 1 beta weight incrementor p math gamma lattice length 1 p transducer m p o l e w e g h t na n p p +p+ gamma +gamma lattice length 1 incrementor increment p ip lattice length 2 ip 0 ip 0 num i++ node ip || node ip alpha transducer m p o l e w e g h t note skip here alpha beta value won t correct since alpha infinite anyway shouldn t matter t get transition iterator it transition iterator input ip output ip it next destination it next logger loggable level f n e logger fine backward lattice input po +ip + + get name + d +destination get name + j destination get index lattice node destination node node ip+1 j destination node transition weight it get weight na n transition weight transition weight 0 old beta node ip beta na n node ip beta node ip beta transducer sum log prob node ip beta destination node beta + transition weight na n node ip beta d beta +destination node beta+ tran +transition weight+ sum + destination node beta+transition weight + old beta +old beta xi node ip alpha + transition weight + node ip+1 j beta weight save xi xi ip j xi na n node ip alpha na n transition weight na n node ip+1 j beta na n weight incrementor || output alphabet p math xi p transducer m p o l e w e g h t na n p xi +ip+ +i+ +j+ +xi incrementor incrementor increment transition it p output alphabet output index output alphabet lookup index it get output output index 0 xxx ip op output count ip output index + p r f lattice output count +ip+ +output index+ + +p gamma ip node ip alpha + node ip beta weight p l check normalization checknorm transducer m p o l e w e g h t 0 num i++ node ip note actually we could sum ip index choice lattice length 1 arbitrary ending alpha +i+ +node lattice length 1 alpha ending beta +i+ +t get weight checknorm transducer sum log prob checknorm gamma ip check gamma sum +checknorm p l check normalization p l normalize 0 num i++ node ip gamma ip gamma ip checknorm check gamma sum +checknorm p l normalization incrementor 0 num i++ p math gamma 0 p transducer m p o l e w e g h t na n p incrementor increment t get p output alphabet labeling label vector lattice length ip lattice length 2 ip 0 ip math ab 1 0 matrix ops sum output count ip 0 000001 labeling ip label vector output alphabet output count ip get input input p l simple node holding weight position n back node weight po n back node weight po weight weight po po n best slist max element k l min element k l max po k lep rmin n best slist max element max element max element k l min e k l min element k l min element k l min element size size empty empty pop 0 get po index n back node tn n back node get tn po get weight index n back node tn n back node get tn weight k lep k lep k lep k lep rmin rmin rmin rmin get t h rpo n back node tn lc1 lc2 tn n back node get 0 lc1 tn weight tn n back node get size 1 lc2 tn weight minc lc1 lc2 minc t h r minc minc rmin 1 size i++ tn n back node get lc1 tn weight lc2 lc1 minc t h r i+1 size get t h rpo t r w m n n back node tn lc1 lc2 tn n back node get 0 lc1 tn weight minc t h r lc1 rmin minc lc1 lc2 minc t h r minc minc rmin 1 size i++ tn n back node get lc1 tn weight lc1 minc t h r i+1 size get k lpo k lep 0 1 n l p n l p max element worstc n back node tn tn n back node get size 1 worstc tn weight 0 size i++ tn n back node get n o t e sometime we can positive number lc tn weight lc tn weight worstc lc 0 asdf 1 0 n l p lc n l p transducer sum log prob n l p 1 lc normalize 0 size i++ n l p n l p n l p size 1 n l p k lep k l max po i+1 k l max po k l min element k l max po size k l min element k l min element k l max po size k l max po push n back node vn tc vn weight 0 size i++ n back node tn n back node get lc tn weight tc lc add vn add vn p l too big first large weight element size max element max element f o total weight o next best index 0 size i++ search node n best temp node search node n best get f1 temp node total weight temp node next best index f f1 add o add o p l n best slist culotta constrain lattice constrain lattice path pas label segment indicate constrain input input output output segment segment label constrain lattice label segment start segment correctly sum lattice beam transducer t input output segment segment constrain t input output transducer incrementor constraint t input output segment constrain constraint transducer t input output segment segment constrain constrain size input size illegal argument constrain size + constrain size + input size + input size + constraint tell lattice emit observation positive value say path pas index negative value say path pas index 0 we t care initialize 0 1 extra node start constraint constrain size + 1 0 constraint length c++ constraint 0 segment get start segment get i++ si t index constrain get si 1 logger warning could find + constrain get + check label match start tage tag label see training illegal argument could find + constrain get + check label match start tag tag constraint i+1 si + 1 additional negative constraint ensure segment tag xxx segment length 1 actually constrain tag tag instead constraint tag tag fix below unsafe now f e e l o w tag constrain get segment get segment get +2 constraint length segment get start segment get segment length 1 tag start tag + tag substring 1 tag length tag start || tag start 0 illegal argument constrain lattice tag o format statei index tag statei 1 tag tag statei index constrain get segment get start constraint segment get + 2 statei + 1 segment get + 2 constraint length tag segment get tag statei t index tag statei 1 illegal argument could find + tag + check label match start tag tag constraint segment get + 2 statei + 1 print logger fine segment + segment + constrain + constrain + constraint 0 constraint length i++ logger fine constraint + logger fine constraint culotta constructor constrain lattice lattice constrain transition position label pair constraint adhere constraint entry index label position entry 0 there constraint position label positive value path pas negative value path pas n o t e constraint length equal output size + 1 lattice extra position generally unconstrain since produce observation sum lattice beam transducer t input output transducer incrementor incrementor label alphabet output alphabet constraint t t logger loggable level f n e logger fine starting lattice logger fine input ip 0 ip input size ip++ logger fine + input get ip logger fine output output logger fine op 0 op output size op++ logger fine + output get op logger fine initialize some structure input input output output xxx very efficient lattice actually sparse especially large lattice length input size +1 num t num node lattice node lattice length num xxx yipe could get big someth sparse better? gamma lattice length num xxx move ivar we can save it? what? comment because memory hog now uncomment conditionalize flag ev ca xi lattice length num num output count output alphabet output count lattice length output alphabet size 0 num i++ ip 0 ip lattice length ip++ gamma ip transducer m p o l e w e g h t comment xi ca j 0 j num j++ ip 0 ip lattice length ip++ xi ip j transducer m p o l e w e g h t forward pas logger fine starting constrain foward pas ensure least weight les infinity we can start there least 0 num i++ weight t get get weight forward pas weight +initial weight weight transducer m p o l e w e g h t get lattice node 0 alpha weight node 0 alpha +node 0 alpha least least logger warning there starting ip 0 ip lattice length 1 ip++ 0 num i++ logger fine ip + ip+ + check node possible position label skip constraint ip 0 index constraint ip 1 constraint ip 1 logger fine current match positive constraint position +ip+ constraint + constraint ip 1 + curr +i constraint ip 0 index constraint ip constraint ip +1 logger fine current match negative constraint position +ip+ constraint + constraint ip +1 + curr +i node ip || node ip alpha transducer m p o l e w e g h t xxx we up lot we could save one node ip logger fine node ip n u l l node ip alpha transducer m p o l e w e g h t logger fine node ip alpha inf logger fine n f n t e weight n u l l skip t get transition iterator it transition iterator input ip output ip logger loggable level f n e logger fine starting forward transition iteration + get name + input + input get ip + output + output ? output get ip it next destination it next transition check constraint see node ip can transition destination ip+1 constraint length constraint ip+1 0 constraint ip+1 1 destination get index logger fine destination match positive constraint assigning infinite weight position + ip+1 + constraint + constraint ip+1 1 + +i+ destination +destination get index transition ip+1 constraint length constraint ip+1 0 constraint ip+1 +1 destination get index logger fine destination match negative constraint assigning infinite weight position + ip+1 + constraint + constraint ip+1 +1 + destination +destination get index transition logger loggable level f n e logger fine forward lattice input po +ip + + get name + d +destination get name + lattice node destination node get lattice node ip+1 destination get index destination node output it get output transition weight it get weight transition logger loggable level f n e logger fine transition weight +transition weight + node +ip+ +i+ alpha +node ip alpha + destination node alpha +destination node alpha destination node alpha transducer sum log prob destination node alpha node ip alpha + transition weight destination node alpha +destination node alpha logger fine alpha lattice node ip + ip+1 + index + destination get index + destination node alpha + destination node alpha illegal transition accord our constraint prob 0 n o alpha unnormaliz weight inf destination node alpha 0 0 destination node alpha transducer m p o l e w e g h t logger fine illegal transition + + + destination get index + setting alpha inf calculate total weight lattice normalizer weight transducer m p o l e w e g h t 0 num i++ node lattice length 1 note actually we could sum ip index choice lattice length 1 arbitrary ending alpha +i+ +node lattice length 1 alpha ending beta +i+ +t get weight constraint lattice length 1 0 constraint lattice length 1 1 constraint lattice length 1 0 constraint lattice length 1 +1 logger fine sum lattice weight +i+ alpha +node lattice length 1 alpha + weight +t get get weight weight transducer sum log prob weight node lattice length 1 alpha + t get get weight weight now unnormaliz weight entire lattice weight 0 weight +weight infinite weight just usefully avoid calling increment also relie fact gamma alpha beta value already initialize value reflect infinite weight xxx perhap alpha beta exactly correctly reflecting? weight transducer m p o l e w e g h t backward pas 0 num i++ node lattice length 1 t get node lattice length 1 beta get weight gamma lattice length 1 node lattice length 1 alpha + node lattice length 1 beta weight incrementor p math gamma lattice length 1 p 0 p 1 0 na n p p +p+ gamma +gamma lattice length 1 incrementor increment p ip lattice length 2 ip 0 ip 0 num i++ node ip || node ip alpha transducer m p o l e w e g h t note skip here alpha beta value won t correct since alpha infinite anyway shouldn t matter t get transition iterator it transition iterator input ip output ip it next destination it next logger loggable level f n e logger fine backward lattice input po +ip + + get name + d +destination get name + j destination get index lattice node destination node node ip+1 j destination node transition weight it get weight na n transition weight transition weight 0 old beta node ip beta na n node ip beta node ip beta transducer sum log prob node ip beta destination node beta + transition weight na n node ip beta d beta +destination node beta+ tran +transition weight+ sum + destination node beta+transition weight + old beta +old beta xi ip j node ip alpha + transition weight + node ip+1 j beta weight na n node ip alpha na n transition weight na n node ip+1 j beta na n weight incrementor || output alphabet xi node ip alpha + transition weight + node ip+1 j beta weight p math xi p 0 p 1 0 na n p xi +ip+ +i+ +j+ + xi incrementor incrementor increment transition it p output alphabet output index output alphabet lookup index it get output output index 0 xxx ip op output count ip output index + p r f lattice output count +ip+ +output index+ + +p gamma ip node ip alpha + node ip beta weight incrementor 0 num i++ p math gamma 0 p 0 0 p 1 0 na n p incrementor increment t get p output alphabet labeling label vector lattice length ip lattice length 2 ip 0 ip math ab 1 0 matrix ops sum output count ip 0 000001 labeling ip label vector output alphabet output count ip get total weight na n weight weight weight unnormaliz weight get probability math weight get gamma weight input position gamma input position get index get gamma probability input position math gamma input position get index get xi xi get gamma gamma get xi probability ip s1 s2 xi illegal xi be save s1 get index j s2 get index math xi ip j get xi weight ip s1 s2 xi illegal xi be save s1 get index j s2 get index xi ip j length lattice length get alpha ip lattice node node get lattice node ip get index node alpha get beta ip lattice node node get lattice node ip get index node beta label vector get label position output position labeling labeling output position transducer get transducer t container some information about input position lattice node input position output position really until we deal asymmetric epsilon output alpha transducer m p o l e w e g h t beta transducer m p o l e w e g h t lattice node input position input position input position alpha transducer m p o l e w e g h t xxx check factory sum lattice factory bw factory beam width bw beam width sum lattice sum lattice transducer tran input output transducer incrementor incrementor save xi label alphabet output alphabet sum lattice beam tran input output incrementor save xi output alphabet beam width bw 