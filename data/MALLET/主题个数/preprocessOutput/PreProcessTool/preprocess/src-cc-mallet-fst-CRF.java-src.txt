2002 univ dept part m l l e t m achine learning languag e toolkit 1 0 information see ` l e n e mc callum io io output stream io o io input stream io output stream io output stream writer io print writer io serializable bit hash map iterator logging logger regex pattern decimal format type alphabet type feature inducer type feature selection type feature type feature vector type feature vector type index sparse vector type instance type instance type matrix ops type rank feature vector type type sparse vector pipe noop pipe pipe util logger math there several different kind numeric value weight range inf inf high weight path likely these t appear directly transducer appear many subclass r f weight also often sum dot feature vector unnormaliz range inf inf high path les likely unnormaliz can obtain negate weight negate sum weight these often transition iterator get value lattice node alpha value unnormaliz normalize range 0 inf high path les likely normalize can safely consider log probability some event they can obtain subtract negative normalizer unnormaliz subtract total cost lattice typically example normalize they also allow unnormaliz gamma gamma transition xi normalize well value lattice get value probability range 0 1 high probability path likely they obtain normalize taking log negate sum probability range 0 positive number they sum several probability these pass increment count r f model r f transducer serializable logger logger logger get logger r f get name l e l e p r t o r alphabet input alphabet alphabet output alphabet hash map name2state hash map factor factor sparse vector weight weight feature alphabet weight alphabet alphabet weight freeze feature induction can fill feature selection global feature selection feature selection weight over ride permanently disable feature inducer weight dimension these feature these transition feature selection feature selection store here induce feature conjunction these conjunction can test instance transduction feature inducer feature inducer feature inducer index get increment r f get change weight value change stamp 0 index get increment r f structure get change weight structure change stamp 0 cache num stamp 1 weight structure change stamp last num calculate num simple transparent container hold statistic r f factor serializable alphabet weight alphabet sparse vector weight transition index weight index weight feature index weight index weight freeze flag indicate weight weight index change learning index weight index weight index index weight index index construct empty factor empty weight alphabet 0 length weight weight factor weight alphabet alphabet weight 0 weight 0 leave rest they get late add add weight alternatively we could zero length construct factor mimic structure zero value simply point alphabet clone factor factor weight alphabet weight alphabet weight sparse vector weight length 0 weight length i++ weight sparse vector weight clone matrix zero weight weight length weight freeze weight freeze we t here because we want expectation constraint factor get r f factor alternatively we declare freezing change structure force reallocation expectation etc weight weight length weight weight length construct factor copying factor factor clone alphabet weight alphabet clone alphabet ? alphabet weight alphabet clone weight alphabet weight sparse vector weight length 0 weight length i++ weight sparse vector weight clone matrix weight weight clone weight freeze weight freeze weight weight clone weight weight clone construct factor same structure crf value initialize zero typically allocate storage statistic expectation constraint etc factor r f crf t o o change crf weight alphabet crf weight alphabet t o o consider cloning instead weight sparse vector crf weight length 0 weight length i++ weight sparse vector crf weight clone matrix zero weight crf weight length weight freeze crf weight freeze crf num crf weight length crf weight length crf weight length weight crf weight length weight crf weight length get num factor weight length weight length weight length weight length ret weight length + weight length + weight length 0 weight length i++ ret + weight num location ret zero 0 weight length i++ weight 0 fill weight 0 fill weight 0 fill weight 0 structure match factor weight alphabet size weight alphabet size weight length weight length gsc check sparse vector size weight 0 weight length i++ weight num location weight num location note we check index sparse vector weight weight length weight length weight length weight length weight length weight length na n 0 weight length i++ weight na n matrix ops na n weight matrix ops na n weight matrix ops na n weight gsc check weight sure there na n infinite value can call check weight constraint expectation crf since can infinite weight likely na n infinite 0 weight length i++ weight na n infinite matrix ops na n infinite weight matrix ops na n infinite weight matrix ops na n infinite weight plus equal factor factor plus equal factor plus equal factor factor obey weight freeze 0 weight length i++ obey weight freeze weight freeze weight plus equal sparse weight factor weight + weight factor 0 weight length i++ weight + weight factor weight + weight factor log p accord zero gaussian variance gaussian prior variance value 0 prior denom 2 variance weight length weight length 0 weight length i++ infinite weight value weight weight prior denom infinite weight value weight weight prior denom w 0 weight length i++ infinite weight value weight weight prior denom j 0 j weight num location j++ w weight value location j infinite w value w w prior denom value plus equal gaussian prior gradient factor variance weight length weight length 0 weight length i++ gsc check weight crf well since we could machine some infinite weight infinite weight infinite weight weight weight variance infinite weight infinite weight weight weight variance w ow 0 weight length i++ weight freeze t o o note there doesn t seem freeze weight weight t o o we also obey feature selection here? need enforce creation weight infinite weight weight weight variance j 0 j weight num location j++ w weight value location j ow weight value location j infinite w weight value location j w ow variance log p accord hyperbolic curve smooth approximation l1 prior hyberbolic prior slope sharpness value 0 weight length weight length 0 weight length i++ infinite weight value slope sharpness math log math cosh sharpness weight infinite weight value slope sharpness math log math cosh sharpness weight w 0 weight length i++ value slope sharpness math log math cosh sharpness weight j 0 j weight num location j++ w weight value location j infinite w value slope sharpness math log math cosh sharpness w value plus equal hyperbolic prior gradient factor slope sharpness t o o could some careful check over especially flip negation weight length weight length s slope sharpness 0 weight length i++ gsc check weight crf well since we could machine some infinite weight infinite weight infinite weight weight + s math tanh weight infinite weight infinite weight weight + s math tanh weight w ow 0 weight length i++ weight freeze t o o note there doesn t seem freeze weight weight t o o we also obey feature selection here? need enforce creation weight infinite weight weight + s math tanh weight j 0 j weight num location j++ w weight value location j ow weight value location j infinite w weight value location j w + s math tanh ow instance inner can pass variou inference can gather increment statistic count into contain factor instance incrementor transducer incrementor increment transducer count weight get index + count increment transducer count weight get index + count increment transition transducer transition iterator ti count index ti get index r f r f ti get nwi weight index index length weight index wi 0 wi nwi wi++ weight index weight index index wi freeze weight t gather statistic we ensure gradient these zero weight freeze weight index t o o we also obey feature selection here? need enforce creation weight weight weight index plus equal sparse feature vector ti get input count weight weight index + count get ab norm ret 0 0 weight length i++ weight transducer m p o l e w e g h t ret + math ab weight weight transducer m p o l e w e g h t ret + math ab weight 0 weight length i++ ret + math ab weight nl weight num location j 0 j nl j++ ret + math ab weight value location j ret weight incrementor transducer incrementor instance weight 1 0 weight incrementor instance weight instance weight instance weight increment transducer count weight get index + count instance weight increment transducer count weight get index + count instance weight increment transition transducer transition iterator ti count index ti get index r f r f ti get nwi weight index index length weight index count instance weight wi 0 wi nwi wi++ weight index weight index index wi freeze weight t gather statistic we ensure gradient these zero weight freeze weight index t o o we also obey feature selection here? need enforce creation weight weight weight index plus equal sparse feature vector ti get input count weight weight index + count get buffer buffer length get num factor illegal argument expect size buffer + get num factor + size + buffer length pi 0 0 weight length i++ buffer pi++ weight buffer pi++ weight 0 weight length i++ buffer pi++ weight nl weight num location j 0 j nl j++ buffer pi++ weight value location j get parameter index num parm 2 weight length index num parm index % 2 0 weight index 2 weight index 2 index num parm 0 weight length i++ index 0 weight index index weight num location weight value location index index weight num location illegal argument index too high +index buff buff length get num factor pi 0 0 weight length i++ weight buff pi++ weight buff pi++ 0 weight length i++ weight buff pi++ nl weight num location j 0 j nl j++ weight value location j buff pi++ parameter index value num parm 2 weight length index num parm index % 2 0 weight index 2 value weight index 2 value index num parm 0 weight length i++ index 0 weight value index index weight num location weight value location index value index weight num location illegal argument index too high +index gsc serialization factor serial u 1 u r r e n t e r l v e r o n 1 write output stream o write u r r e n t e r l v e r o n write weight alphabet write weight write weight write weight freeze write weight write weight read input stream o found read weight alphabet alphabet read weight sparse vector read weight read weight freeze read weight read weight read r f pipe input pipe pipe output pipe input pipe output pipe input alphabet input pipe get alphabet output alphabet input pipe get target alphabet input alphabet stop growth r f alphabet input alphabet alphabet output alphabet noop input alphabet output alphabet input alphabet stop growth logger info r f input dictionary size +input alphabet size xxx output alphabet stop growth input alphabet input alphabet output alphabet output alphabet r f weight another r f r f r f input pipe output pipe we need add another constructor handle get input pipe get output pipe weight weight length weight r f r f factor r f transition weight weight alphabet alphabet r f weight alphabet clone weight alphabet alphabet r f weight alphabet clone weight sparse vector r f weight length clear clear these because they fill add weight 0 weight 0 0 r f size i++ r f get weight name weight index length j 0 j weight name length j++ w weight index j weight name j r f weight alphabet lookup w weight index j length add name r f weight r f weight destination name label weight name feature selection r f feature selection clone yyy weight freeze r f weight freeze clone alphabet get input alphabet input alphabet alphabet get output alphabet output alphabet call whenev r f weight structure arity change weight structure change weight structure change stamp++ weight value change stamp++ call whenev r f weight change weight value change weight value change stamp++ can over ride subclass r f subclass r f r f name index weight weight destination name label name weight name r f crf name index weight weight destination name label name weight name crf add name weight weight destination name label name weight name weight name length destination name length label name length destination name length weight structure change name2state get name illegal argument name ` +name+ already weight matrix ops append weight weight weight matrix ops append weight weight name size weight weight destination name label name weight name print add weight m p o l e w e g h t add name2state put name add name weight weight destination name label name weight name weight name weight name length 1 0 weight name length i++ weight name 0 weight name add name weight weight destination name label name weight name give transition add name weight weight destination name label name destination name length label name length weight name label name length 0 label name length i++ weight name name + + destination name + + label name add name weight weight destination name label name weight name add equal zero label going arc same name destination name add name destination name add name 0 0 destination name destination name add group fully connect equal zero label going arc same name destination name add fully connect name 0 name length i++ add name name add fully connect label label output alphabet size assume entry output alphabet 0 output alphabet size i++ logger info r f output alphabet lookup + output alphabet lookup get get name label output alphabet lookup add fully connect label add start add start t r t add start name 0 num i++ weight m p o l e w e g h t dest num 0 dest length i++ dest get get name add name 0 0 0 dest dest weight 0 0 start 0 num i++ transducer get weight 0 weight m p o l e w e g h t weight value change label connection instance training label connection training label connection instance training start num label output alphabet size connection num label num label 0 training size i++ instance instance training get feature output feature instance get target j 1 j output size j++ index output alphabet lookup index output get j 1 d index output alphabet lookup index output get j index 0 d index 0 connection index d index handle start start start index output alphabet lookup index start j 0 j output alphabet size j++ connection start index j connection add first markov model label add transition occur training add label connect instance training num label output alphabet size connection label connection training 0 num label i++ num destination 0 j 0 j num label j++ connection j num destinations++ destination name num destination destination index 0 j 0 j num label j++ connection j destination name destination index++ output alphabet lookup j add output alphabet lookup destination name add many there label t weight destination pair instead incoming transition share same weight add half label connect instance training num label output alphabet size connection label connection training 0 num label i++ num destination 0 j 0 j num label j++ connection j num destinations++ destination name num destination destination index 0 j 0 j num label j++ connection j destination name destination index++ output alphabet lookup j add output alphabet lookup 0 0 0 0 destination name destination name destination name add many there label t observational test weight destination pair instead incoming transition share same observational feature test weight feature transition h m m style transition probability add three quarter label connect instance training num label output alphabet size connection label connection training 0 num label i++ num destination 0 j 0 j num label j++ connection j num destinations++ destination name num destination weight name num destination destination index 0 j 0 j num label j++ connection j label name output alphabet lookup j destination name destination index label name weight name destination index 2 half label observe test weight name destination index 0 label name transition weight feature wn output alphabet lookup + + output alphabet lookup j weight name destination index 1 wn wi get weight index wn empty feature selection won t feature here we get feature transition feature selection wi feature selection training get alphabet destination index++ add output alphabet lookup 0 0 0 0 destination name destination name weight name add fully connect three quarter label instance training num label output alphabet size 0 num label i++ destination name num label weight name num label j 0 j num label j++ label name output alphabet lookup j destination name j label name weight name j 2 half label observational test weight name j 0 label name transition weight feature wn output alphabet lookup + + output alphabet lookup j weight name j 1 wn wi get weight index wn empty feature selection won t feature here we get feature transition feature selection wi feature selection training get alphabet add output alphabet lookup 0 0 0 0 destination name destination name weight name add fully connect bi label label output alphabet size assume entry output alphabet 0 output alphabet size i++ logger info r f output alphabet lookup + output alphabet lookup get get name label output alphabet lookup 0 label length i++ j 0 j label length j++ destination name label length k 0 k label length k++ destination name k label j + l e l e p r t o r+label k add label + l e l e p r t o r+label j 0 0 0 0 destination name label add second markov model label add transition occur training add bi label connect instance training num label output alphabet size connection label connection training 0 num label i++ j 0 j num label j++ connection j num destination 0 k 0 k num label k++ connection j k num destinations++ destination name num destination label num destination destination index 0 k 0 k num label k++ connection j k destination name destination index output alphabet lookup j + l e l e p r t o r+ output alphabet lookup k label destination index output alphabet lookup k destination index++ add output alphabet lookup + l e l e p r t o r+ output alphabet lookup j 0 0 0 0 destination name label add fully connect tri label label output alphabet size assume entry output alphabet 0 output alphabet size i++ logger info r f output alphabet lookup + output alphabet lookup get get name label output alphabet lookup 0 label length i++ j 0 j label length j++ k 0 k label length k++ destination name label length l 0 l label length l++ destination name l label j + l e l e p r t o r+label k + l e l e p r t o r+label l add label + l e l e p r t o r+label j + l e l e p r t o r+label k 0 0 0 0 destination name label add self transition label name label output alphabet size destination name output alphabet size assume entry output alphabet 0 output alphabet size i++ logger info r f output alphabet lookup + output alphabet lookup get get name label output alphabet lookup destination name name add name 0 0 0 0 destination name label concat label label sep buffer buf buffer 0 label length i++ buf append sep append label sep l e l e p r t o r buf next k gram history k next sep buffer buf buffer start history length + 1 k start history length i++ buf append sep append history sep l e l e p r t o r buf append sep append next buf allow transition prev curr pattern pattern yes pair concat label prev curr matcher pair match yes yes matcher pair match allow history history pattern pattern yes 1 history length i++ allow transition history 1 history yes r f output alphabet contain create em n em r f input predicate output label training connectivity weight remain argument training training instance order increase negative number giving order feature r f large em n em markov r f em n em tuple output label number em k em order weight share destination last most recent em k em label agree order 0 r f build same length order position indicate weight correspond contain weight feature weight weight feature build input predicate start label context start also label label name will between start label label tt fully connect tt tt tt argument start forbid specifie what pair successive label allow both construct em n em transition label pair em u em em v em allow em u em + + em v em match forbid allow specifie what pair successive label allow both construct em n em transition label pair em u em em v em allow em u em + + em v em match allow fully connect allow transition occur training name start add n instance training order start pattern forbid pattern allow fully connect connection start output alphabet lookup index start fully connect connection label connection training start 1 length order length illegal argument match order order 0 0 order length i++ order illegal argument order negative ascending order 0 0 0 history index history label0 output alphabet lookup 0 0 i++ history label0 num label output alphabet size history index 0 num label logger info prepare + concat label history allow history history forbid allow name concat label history nt 0 d name num label label name num label weight name num label order length next index 0 next index num label next index++ next output alphabet lookup next index allow transition history 1 next forbid allow fully connect || connection history index 1 next index d name nt next k gram history next label name nt next 0 order length i++ weight name nt next k gram history order +1 next wi get weight index weight name nt empty feature selection give u feature feature selection wi feature selection training get alphabet nt++ nt num label d name nt label name nt weight name nt t 0 t nt t++ d name t d name t label name t label name t weight name t weight name t d name d name label name label name weight name weight name 0 d name length i++ buffer buffer j 0 j order length j++ append append weight name j logger info name + + d name + + label name + + add name 0 0 0 0 d name label name weight name o 1 o 0 o ++history index o num label history o output alphabet lookup history index o o 0 history index o 0 history o label0 0 i++ history start concat label history name output alphabet size 0 output alphabet size s++ name output alphabet lookup 0 output alphabet size s++ add name 0 0 0 0 name name name start get name name2state get name weight weight index sparse vector transition weight weight structure change weight index weight length || weight index 0 illegal argument weight index +weight index+ bound weight weight index transition weight weight weight name sparse vector transition weight weight get weight index weight name transition weight get weight name weight index weight alphabet lookup weight index sparse vector get weight weight name weight get weight index weight name sparse vector get weight weight index weight weight index get weight weight sparse vector get weight weight weight sparse vector m weight structure change weight m weight w weight structure change weight w weight widx val weight value change weight widx val support making optimize optimizable r f weight freeze weight index weight freeze weight index freeze weight current value freeze weight label sequence tt transduce tt tt train tt weight index index weight freeze freeze weight weight index weight freeze weight index freeze weight current value freeze weight label sequence tt transduce tt tt train tt weight name name weight freeze freeze weight weight name widx get weight index weight name freeze weight widx unfreez weight freeze weight label sequence tt transduce tt tt train tt weight name name weight unfreeze unfreeze weight weight name widx get weight index weight name weight freeze widx feature selection weight idx feature selection f feature selection weight idx f weight structure change necessary? akm 11 2007 weight dimension instance training weight dimension training gsc change consider training mix label unlabel we want unlabel well some weight unsupport trick note target unlabel instance size zero weight dimension instance training some unsupport trick bit weight present num weight 0 value doesn t actually change because zero value gradient because now different layout weight structure change weight present bit weight length 0 weight length i++ weight present bit put weight already there 0 weight length i++ j weight num location 1 j 0 j weight present weight index location j put weight training 0 training size i++ instance instance training get feature vector input feature vector instance get feature output feature instance get target gsc training can unlabel instance well output output size 0 path consistent label sum lattice factory sum lattice input output transducer incrementor increment transition transducer transition iterator ti count r f ti get feature vector input feature vector ti get input index ti get index nwi weight index index length wi 0 wi nwi wi++ weight index weight index index wi 0 input num location i++ feature index input index location global feature selection || global feature selection contain feature index feature selection || feature selection weight index || feature selection weight index contain feature index weight present weight index feature index increment transducer count increment transducer count also path select current model we get some negative weight some unsupport trick get ab norm 0 0 logger info r f incremental training detect add weight some unsupport feature once some training sum lattice factory sum lattice input transducer incrementor increment transition transducer transition iterator ti count count 0 2 feature transition probability 0 2 0 2 somewhat arbitrary akm r f ti get feature vector input feature vector ti get input index ti get index nwi weight index index length wi 0 wi nwi wi++ weight index weight index index wi 0 input num location i++ feature index input index location global feature selection || global feature selection contain feature index feature selection || feature selection weight index || feature selection weight index contain feature index weight present weight index feature index increment transducer count increment transducer count sparse vector weight sparse vector weight length 0 weight length i++ num location weight present cardinality logger info r f weight +parameter weight alphabet lookup + num feature +num location index num location j 0 j num location j++ index j weight present next bit j 0 ? 0 index j 1 +1 r f4 index +indice j weight index sparse vector index num location num location num location weight plus equal sparse weight put previou weight num weight + num location + 1 logger info weight +num weight weight weight weight dimension densely weight structure change sparse vector weight sparse vector weight length max input alphabet size num weight 0 logger info r f dense weight num input feature +max 0 weight length i++ nfeature feature selection nfeature max weight sparse vector max max max feature selection feature selection f feature selection nfeature f get bit cardinality idx nfeature j 0 idx 1 idx f next select index idx + 1 0 idx j++ idx weight index sparse vector idx nfeature nfeature nfeature weight plus equal sparse weight num weight + nfeature + 1 logger info weight +num weight weight weight weight vector weight name get weight index weight name wi weight alphabet lookup index weight name wi 1 illegal argument alphabet freeze weight name + weight name weight wi 0 weight sparse vector 1 weight 1 feature selection feature selection 1 weight freeze 1 capacity 8 weight 0 index sparse vector weight 0 0 feature selection 0 weight structure change wi weight length sparse vector weight sparse vector weight length+1 weight weight length+1 feature selection feature selection feature selection weight length+1 0 weight length i++ weight weight weight weight feature selection feature selection weight wi index sparse vector weight wi 0 feature selection wi weight weight weight weight feature selection feature selection weight freeze util append weight freeze weight structure change trainable wi weight length weight weight feature selection weight freeze n weight length weight length n feature selection length n weight freeze length n num size transducer get index get index iterator iterator iterator trainable gsc accessor get weight value change stamp weight value change stamp kedar access structure stamp get weight structure change stamp weight structure change stamp factor get gsc get ab norm ret 0 0 num i++ ret + math ab weight ret + math ab weight 0 weight length i++ ret + math ab weight ret + weight ab norm ret set parameter first group parameter index d index feature index value parameter index d index feature index 0 value parameter index d index feature index weight index value weight value change get index d get d index row index row index 0 row index destination name length row index++ destination name row index equal d name row index destination name length illegal argument transtition +source index+ +d index+ weight index weight index row index weight index feature index 0 weight weight index value weight weight index value feature index value get parameter first group get parameter index d index feature index get parameter index d index feature index 0 get parameter index d index feature index weight index get index d get d index row index row index 0 row index destination name length row index++ destination name row index equal d name row index destination name length illegal argument transtition +source index+ +d index+ weight index weight index row index weight index feature index 0 weight weight index weight weight index value feature index get num cache num stamp weight structure change stamp num 2 num + weight length 0 weight length i++ num + weight num location num deprecate here reminder someth about induce feature deprecate predict instance testing testing feature selection global feature selection 0 feature inducer size i++ feature inducer klfi feature inducer feature inducer get klfi induce feature testing ret testing size 0 testing size i++ instance instance testing get input instance get output instance get target input size output size pr output max lattice input best output pr output size output size ret pr output ret deprecate deprecate evaluate transducer evaluator eval instance testing illegal longer usable r f induce feature instead testing feature selection global feature selection 0 feature inducer size i++ feature inducer klfi feature inducer feature inducer get klfi induce feature testing eval evaluate 0 0 0 testing r f feature induction these feature conjunction create test validation them take effect induce feature instance instance instance feature selection global feature selection 0 feature inducer size i++ feature inducer klfi feature inducer get klfi induce feature instance t o o put support optimizable here get value instance ?? print print print writer output stream writer print print writer r f t t e 0 num i++ get print t t e n m e \ print name print \ print destination length print outgo transition print print weight print weight print print print weight print weight print transition j 0 j destination length j++ print print name print get destination j get name k 0 k weight index j length k++ print w e g h t \ widx weight index j k print weight alphabet lookup widx print \ weight n o w e g h t r f w e g h t widx 0 widx weight length widx++ w e g h t n m e + weight alphabet lookup widx print e f u l t f e t u r e print weight widx print sparse vector transition weight weight widx transition weight num location 0 rank feature vector rfv rank feature vector input alphabet transition weight m 0 m rfv num location m++ v rfv get value rank m index rfv index location rfv get index rank m doesn t sense ev work? akm 12 2007 index rfv get index rank m feature input alphabet lookup index v 0 print print feature print v flush write f output stream oo output stream output stream f oo write oo close o e err + f + + e gsc serialization r f serial u 1 u r r e n t e r l v e r o n 1 write output stream o write u r r e n t e r l v e r o n write input alphabet write output alphabet write write write name2state write write global feature selection write feature selection write feature inducer write weight value change stamp write weight structure change stamp write cache num stamp write num suppres warning uncheck read input stream o found read input alphabet alphabet read output alphabet alphabet read read read name2state hash map read factor read global feature selection feature selection read feature selection feature selection read feature inducer feature inducer read weight value change stamp read weight structure change stamp read cache num stamp read num read why ? couldn t inner class? transducer also akm 12 2007 transducer serializable index destination feature index name index destination name destination n element until get destination call weight index contain index into r f weight label r f crf constructor serialization name index weight weight destination name label name weight name r f crf destination name length label name length destination name length weight name length name name index index note setting these here actually redundant they be already r f add m consider remove weight weight argument constructor need think akm 12 2007 r f be constructor could add put name2state also crf weight index weight crf weight index weight destination name destination name length destination label name length weight index label name length label label name length crf crf 0 label name length i++ sure label appear our output alphabet crf output alphabet lookup index label name destination name destination name label label name weight index weight name length j 0 j weight name length j++ weight index j crf get weight index weight name j crf weight structure change transducer get transducer crf get weight crf weight index weight crf weight index get weight crf weight index weight crf weight index print +index+ \ +name+ \ weight +crf weight index + weight +crf weight index destination +destination length 0 destination length i++ +destination name num destination destination length get weight name index index weight index index ret index length 0 ret length i++ ret crf weight alphabet lookup index ret add weight didx weight name widx crf get weight index weight name weight index didx util append weight index didx widx get label name index label index get destination index ret ret destination index ret destination index crf name2state get destination name index ret illegal argument name +thi name+ index +index+ destination name index +destination name index + name2state size + crf name2state size ret transducer transition iterator transition iterator input input position output output position input position 0 || output position 0 unsupport operation epsilon transition input unsupport operation r f generative model input transition iterator feature vector input input position output ? output get output position crf transducer transition iterator transition iterator feature vector fv output transition iterator fv output crf get name name efficient inside increment transition get index index serialization serial u 1 u r r e n t e r l v e r o n 0 write output stream o write u r r e n t e r l v e r o n write name write index write destination name write destination write weight index write label write crf read input stream o found read name read index read destination name read destination r f read weight index read label read crf r f read transition iterator transducer transition iterator serializable index next index weight feature vector input r f crf transition iterator feature vector input seq input position output r f crf input seq get input position output crf transition iterator feature vector fv output r f crf crf crf input fv weight destination length nwi swi tran index 0 tran index destination length tran index++ xxx we want output equal here? output || output equal label tran index here dot feature weight lambda weight transition weight tran index 0 nwi weight index tran index length wi 0 wi nwi wi++ swi weight index tran index wi weight tran index + crf weight swi dot fv implicit weight 1 0 feature + crf weight swi na n weight tran index weight tran index p o t v e n f n t y weight tran index m p o l e w e g h t next index point next impossible transition next index 0 next index destination length weight next index m p o l e w e g h t next index++ next next index destination length transducer next next index destination length index next index next index++ next index destination length weight next index m p o l e w e g h t next index++ get destination index these just efficient perhap some them go away get index index get input input get output label index get weight weight index transducer get transducer get destination get destination index serialization transition iterator serial u 1 u r r e n t e r l v e r o n 0 n u l l n t e g e r 1 write output stream o write u r r e n t e r l v e r o n write write index write next index write weight write input write crf read input stream o found read read index read next index read weight read input feature vector read crf r f read describe transition cutoff decimal format f decimal format 0 buffer buf buffer buf append value + f format get weight + these weight weight index index 0 these weight length i++ wi these weight sparse vector w crf weight wi buf append w e g h t + crf weight alphabet lookup wi + buf append p +f format w dot input + val input num location ab val input num location k 0 k val length k++ index input index location k val k w value index input value index ab val k math ab val k buf append e f u l t + f format crf weight wi + rank feature vector rfv rank feature vector crf input alphabet input get index ab val rank 0 rank ab val length rank++ fidx rfv get index rank rank fname crf input alphabet lookup input index location fidx ab val fidx cutoff looping over feature val fidx 0 buf append fname + + f format val fidx + e err transition description e print stack trace buf append e r r o r w h l e w r t n g o u t p u t buf 