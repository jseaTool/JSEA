2002 univ dept part m l l e t m achine learning languag e toolkit 1 0 information see ` l e n e mc callum io o io input stream io output stream io serializable iterator logging logger type instance type instance type type pair alignment pipe pipe logger sequence base model analogou link classify classifier transducer serializable variable name key ip input position op output position logger logger logger get logger transducer get name z e r o o t 0 n f n t e o t p o t v e n f n t y e r t n w e g h t p o t v e n f n t y t o o because nev result na n m p o l e w e g h t n e g t v e n f n t y factory instance we can ask sum lattice sum lattice factory sum lattice factory factory instance we can ask max lattice max lattice factory max lattice factory pipe produce slot possibly target slot also pipe input pipe pipe expect transducer output target slot produce someth printable slot indicate result transduction pipe output pipe initializ sum max inference engine transducer sum lattice factory sum lattice factory max lattice factory max lattice factory transducer pipe input pipe pipe output pipe input pipe input pipe output pipe output pipe pipe get input pipe input pipe pipe get output pipe output pipe sum lattice factory sum lattice factory fbf sum lattice factory fbf max lattice factory max lattice factory vf max lattice factory vf sum lattice factory get sum lattice factory sum lattice factory max lattice factory get max lattice factory max lattice factory take input instance put output instance target transduce instance put best output into instance target rath instance t o o consider different name instance label instance instance input pipe instance input pipe instance instance t o o max lattice factory instead hardcod instance target max lattice instance get best output output pipe instance output pipe instance instance instance take input instance put output instance instance transduce instance instance input pipe instance input pipe instance instance t o o max lattice factory instead hardcod instance max lattice instance get best output output pipe instance output pipe instance instance instance convert into another accord transducer exmaple probabilistic transducer someth viterbi here subclass transducer specify they kind input input output transudc transduce input max lattice factory max lattice input best output num get index note allow impossible infinity weight iterator iterator some transducer generative meaning you can get them giving them input transition iterator transition attempt input weight field t o o why could obtain weight problem??? can iterate transition generative transducer transition iterator transition input cost field here imply can iterate transition generative run inference acros instance average accuracy average accuracy instance ilist accuracy 0 0 ilist size i++ instance instance ilist get input instance get output instance get target input size output size predict max lattice factory max lattice input best output path accuracy sequence elementwise accuracy output predict accuracy + path accuracy logger fine transducer path accuracy +path accuracy accuracy ilist size treat they log probabilie we normalize them pair alignment generate path generative illegal transducer generative iterator it iterator it next add it next xxx yet finish unsupport operation index input name 1 name found index 0 num i++ get get name equal 1 print 0 num i++ logger fine + + get get name print logger fine transducer +thi print serialization transducer serial u 1 u r r e n t e r l v e r o n 1 gsc fix serialization reading lattice factory write output stream o write u r r e n t e r l v e r o n write input pipe write output pipe write sum lattice factory write max lattice factory read input stream o found read input pipe pipe read output pipe pipe read sum lattice factory sum lattice factory read max lattice factory max lattice factory read represent transducer serializable get name get index get weight weight get weight weight transducer get transducer pas negative position request epsilon transition input output position 1 position we insert espilon transition transition iterator transition iterator input input position output output position pas negative input position request epsilon transition position 1 position we insert espilon transition transition iterator transition iterator input input position transition iterator input input position 0 generative transducer possible transition independent input transition iterator transition iterator transition iterator 0 0 serialization serial u 1 u r r e n t e r l v e r o n 0 write output stream o write u r r e n t e r l v e r o n read input stream o found read call inference indicate partial count statistic much probability mass fall transition incrementor increment transition transition iterator ti count increment count increment count iterate over transducer transition iterator iterator serializable next deprecate what for? ve forget akm 11 2007 next 1 deprecate next destination next next unsupport operation specific index transition can index into transition get index input symbol appearing transition get input output symbol appearing transition get output weight between infinity infinity taking transition input output get weight we be taking transition get we taking transition get destination input position transition consume transition consume variable amount sequence get input position increment 1 output position transition produce transition consume variable amount sequence get output position increment 1 transducer get transducer get get transducer hate need there really ca describe transition cutoff serialization serial u 1 u r r e n t e r l v e r o n 0 write output stream o write u r r e n t e r l v e r o n read input stream o found suppres warning unus read sum log prob we need able sum probability represent weight log probability naively we just convert them into probability sum them convert them back into weight sum log prob math log math + math fail too negative machine resolution represent weight resolution represent intermediate exponentiat weight we get infinity our answer what we want getting sum exponentiat too large we can starting equation sum prob log + sum prob + sum prob 1 + sum prob 1 + sum prob log 1 + sum prob + log 1 + we want sure negative small positive we can assure notice we could equivalently derive sum prob + log 1 + we can simply select among two alternative equation small most negative exponent longer sum neg log prob p o t v e n f n t y p o t v e n f n t y p o t v e n f n t y math log 1 + math math log 1 + math tt math log math + math tt p tt tt represent weight sum log prob n e g t v e n f n t y n e g t v e n f n t y n e g t v e n f n t y n e g t v e n f n t y + math log 1 + math + math log 1 + math les efficient sum log prob n e g t v e n f n t y n e g t v e n f n t y n e g t v e n f n t y + math log 1 + math + math log 1 + math 