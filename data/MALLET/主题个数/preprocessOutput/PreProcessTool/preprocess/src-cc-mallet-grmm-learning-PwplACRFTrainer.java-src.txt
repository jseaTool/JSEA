2006 univ dept part m l l e t m achine learning languag e toolkit 1 0 information see ` l e n e learning inference inferenc type optimize optimizable type util logger math timing cache optimizable io io output stream io o io print stream bit iterator logging logger piecewise p l sutton mc callum 2007 n wrong wrong option extension we nev quite work create mar 15 2005 h r e f $ biconditional piecewise r f trainer v 1 1 2007 10 22 21 37 40 $ pwpl r f trainer acrf trainer logger logger logger get logger pwpl r f trainer get name print gradient n o w r o n g w r o n g 0 o n t o n w w 1 wrong wrong type n o w r o n g w r o n g wrong wrong it 10 wrong wrong threshold 0 1 output prefix optimizable gradient value optimizable r f acrf instance training pwpl r f trainer maxable acrf training get wrong wrong threshold wrong wrong threshold wrong wrong threshold wrong wrong threshold wrong wrong threshold wrong wrong threshold wrong wrong type wrong wrong type wrong wrong type wrong wrong type wrong wrong it wrong wrong it wrong wrong it wrong wrong it train r f acrf instance training instance validation instance test r f evaluator eval num it optimizable gradient value macrf wrong wrong type n o w r o n g w r o n g train acrf training validation test eval num it macrf maxable bipw maxable maxable macrf add wrong wrong 5 iteration logger info biconditional piecewise r f trainer training train acrf training validation test eval wrong wrong it macrf util write gzipp output prefix acrf s gz acrf logger info biconditional piecewise r f trainer add wrong wrong bipw maxable add wrong wrong training logger info biconditional piecewise r f trainer add wrong wrong converge train acrf training validation test eval num it macrf report training likelihood acrf training converge report joint likelihood estimate training report training likelihood r f acrf instance training total 0 inferenc inf acrf get inferenc 0 training size i++ instance inst training get r f unroll graph unroll acrf unroll inst inf compute marginal unroll lik inf lookup log joint unroll get assignment total + lik logger info instance +i+ likelihood +lik logger info unregulariz joint likelihood +total maxable cache optimizable gradient r f acrf instance train r f template template bit infinite value num e f u l t g u n p r o r v r n e 10 0 get gaussian prior variance gaussian prior variance gaussian prior variance gaussian prior variance gaussian prior variance gaussian prior variance gaussian prior variance pwpl r f trainer maxable e f u l t g u n p r o r v r n e vector contain count feature observe training map clique template feature count sparse vector constraint vector contain expect value over label feature see training training label sparse vector expectation sparse vector constraint sparse vector expectation init weight instance training tidx 0 tidx template length tidx++ num + template tidx init weight training initialize constraint expectation same dimension weight zero init constraint expectation first constraint sparse vector template length expectation sparse vector template length tidx 0 tidx template length tidx++ sparse vector template tidx get weight constraint tidx sparse vector clone matrix zero expectation tidx sparse vector clone matrix zero now other constraint sparse vector template length expectation sparse vector template length tidx 0 tidx template length tidx++ r f template tmpl template tidx sparse vector weight tmpl get weight constraint tidx sparse vector weight length expectation tidx sparse vector weight length 0 weight length i++ constraint tidx sparse vector weight clone matrix zero expectation tidx sparse vector weight clone matrix zero num cvga call 0 cvga call 0 reset profiling call num cvga call 0 cvga call 0 expectation 0 they ve be initialize reset expectation tidx 0 tidx expectation length tidx++ expectation tidx 0 0 0 expectation tidx length i++ expectation tidx 0 0 reset constraint tidx 0 tidx constraint length tidx++ constraint tidx 0 0 0 constraint tidx length i++ constraint tidx 0 0 maxable r f acrf instance ilist pwpl r f trainer logger fine initialize optimizable r f acrf acrf template acrf get template allocate weight constraint expectation train ilist init weight train init constraint expectation num instance train size cache value stale cache gradient stale cache unroll graph unroll graph unroll graph num instance pwpl r f trainer logger info training instance + num instance pwpl r f trainer logger info + num describe prior pwpl r f trainer logger fine computing constraint collect constraint train describe prior pwpl r f trainer logger info gaussian prior variance + gaussian prior variance get num num negate value value because weight value get buf buf length num illegal argument argument + correct dimension idx 0 tidx 0 tidx template length tidx++ r f template tmpl template tidx sparse vector tmpl get weight value get value arraycopy value 0 buf idx value length idx + value length tidx 0 tidx template length tidx++ r f template tmpl template tidx sparse vector weight tmpl get weight assn 0 assn weight length assn++ value weight assn get value arraycopy value 0 buf idx value length idx + value length internal cache value stale cache gradient stale idx 0 tidx 0 tidx template length tidx++ r f template tmpl template tidx sparse vector tmpl get weight value get value arraycopy idx value 0 value length idx + value length tidx 0 tidx template length tidx++ r f template tmpl template tidx sparse vector weight tmpl get weight assn 0 assn weight length assn++ value weight assn get value arraycopy idx value 0 value length idx + value length function unit test get constraint expectation m too lazy deep caller these sparse vector get expectation cnum expectation cnum sparse vector get constraint cnum constraint cnum print weight print buf num get buf len buf length w 0 w len w++ print buf w + compute value retval 0 0 num instance train size start current milli unroll 0 reset profiling call instance value nev total value we can t just sometime skip value because infinite off total value we instance infinite value happen start we t compute value instance first round instance infinite value initialize infinite value infinite value we could initialize bitset slot instance probably cheap taking hit allocate space bit become infinite value bit initialize infinite value clear statistic we about fill reset expectation fill expectation instance 0 num instance i++ instance instance train get compute marginal clique unroll start current milli r f unroll graph unroll acrf unroll structure instance r f unroll graph unroll r f unroll graph instance template fix tmpl unroll current milli unroll + unroll unroll start unroll num variable 0 happen node prune save expect value feature we compute gradient assignment observation unroll get assignment value collect expectation value unroll observation infinite value initialize infinite value pwpl r f trainer logger warning instance + instance get name + infinite value skip infinite value infinite value get pwpl r f trainer logger warning infinite value instance + instance get name + infinity n e g t v e n f n t y print debug info unroll illegal instance + instance get name + infinite + value now infinite value na n value na n instance + + + instance get name print debug info unroll illegal value na n r f get value instance +i pwpl r f trainer logger warning value na n r f get value instance + + + infinity n e g t v e n f n t y retval + value incorporate gaussian prior weight we add w^2 2 variance log probability prior denom 2 gaussian prior variance tidx 0 tidx template length tidx++ sparse vector weight template tidx get weight j 0 j weight length j++ fnum 0 fnum weight j num location fnum++ w weight j value location fnum weight w tidx j retval + w w prior denom current milli pwpl r f trainer logger info r f inference m + start pwpl r f trainer logger info r f unroll m + unroll pwpl r f trainer logger info get value loglikelihood + retval logger info v g call + num cvga call logger info total v g m + cvga call retval compute gradient penalize log likelihood r f place cache gradient p gradient constraint expectation gaussian prior variance compute value gradient grad index into current element cache gradient gidx 0 first gradient wrt weight tidx 0 tidx template length tidx++ sparse vector these weight template tidx get weight sparse vector these constraint constraint tidx sparse vector these expectation expectation tidx j 0 j these weight num location j++ weight these weight value location j constraint these constraint value location j expectation these expectation value location j pwpl r f trainer print gradient gradient + gidx + + constraint + ctr + expectation + + weight gaussian prior variance + reg feature e f u l t grad gidx++ constraint expectation weight gaussian prior variance now weight tidx 0 tidx template length tidx++ r f template tmpl template tidx sparse vector weight tmpl get weight 0 weight length i++ sparse vector weight vec weight sparse vector constraint vec constraint tidx sparse vector expectation vec expectation tidx j 0 j weight vec num location j++ w weight vec value location j gradient compute below constraint constraint vec value location j expectation expectation vec value location j parameter infinity external user we gradient 0 because parameter value can nev change anyway mess up future calculation matrix infinite w pwpl r f trainer logger warning infinite weight node index + + feature + acrf get input alphabet lookup j gradient 0 0 gradient constraint w gaussian prior variance expectation pwpl r f trainer print gradient idx weight vec index location j fname acrf get input alphabet lookup idx gradient + gidx + + constraint + ctr + expectation + + w gaussian prior variance + reg feature + fname + grad gidx++ gradient feature f k compute expect value f k aver possible label sequence instance we p these value store collector collector j k get expect value feature clique label assignment j input feature k collect expectation value r f unroll graph unroll assignment observation inum value 0 0 iterator unroll unroll var iterator next r f unroll var clique r f unroll var next r f template tmpl clique get template tidx tmpl index tidx 1 vi 0 vi clique size vi++ variable target clique get vi value + compute value gradient assn observation clique target wrong wrong type n o w r o n g w r o n g o n t o n w w value + add conditional w w unroll inum illegal value add conditional w w r f unroll graph unroll inum value 0 wrong wrong wrong wrong wrong inum iterator wrong iterator next wrong wrong ww wrong wrong next variable target ww find variable unroll r f unroll var clique ww find var unroll assignment wrong assignment single index clique ww assn idx computing w w +clique+ idx +ww assn idx+ target +target value + compute value gradient assn wrong clique target value compute value gradient assn assignment observation r f unroll var clique variable target num cvga calls++ timing timing timing r f template tmpl clique get template tidx tmpl index assignment clique assn assignment restriction observation clique m target get num outcome val m single m assn idx 0 assn idx m assn idx++ clique assn value target assn idx val assn idx compute log factor value clique assn tmpl clique get fv single assn idx clique assn single index log z math sum log prob val assn idx 0 assn idx m assn idx++ marginal math val assn idx log z idx single assn idx expectation tidx idx plus equal sparse clique get fv marginal expectation tidx location idx 1 expectation tidx increment value idx marginal observe val observation get target cvga call + timing elapse val observe val log z compute log factor value assignment clique assn r f template tmpl feature vector fv sparse vector weight tmpl get weight idx clique assn single index sparse vector w weight idx dp w dot fv dp + tmpl get weight idx dp collect constraint instance ilist inum 0 inum ilist size inum++ pwpl r f trainer logger fine collecting constraint instance + inum instance inst ilist get inum r f unroll graph unroll r f unroll graph inst template iterator unroll unroll var iterator next r f unroll var clique r f unroll var next tidx clique get template index tidx 1 assn clique lookup assignment constraint tidx assn plus equal sparse clique get fv clique size constraint tidx location assn 1 constraint tidx increment value assn clique size constraint wrong wrong instance wrong wrong wrong wrong wrong inum iterator ww wrong iterator ww next wrong wrong ww wrong wrong ww next r f unroll var clique ww find var unroll tidx clique get template index wrong2right ww assn idx constraint tidx wrong2right plus equal sparse clique get fv 1 0 constraint tidx location wrong2right 1 constraint tidx increment value wrong2right 1 0 dump gradient name grad get num get value gradient grad print stream w print stream output stream name 0 num i++ w grad w close o e err could output e print stack trace dump constraint 0 constraint length i++ template + constraint print expectation 0 expectation length i++ template + expectation print print debug info r f unroll graph unroll acrf print err assignment assn unroll get assignment iterator unroll unroll var iterator next r f unroll var clique r f unroll var next clique + clique dump assn clique assn clique factor ptl unroll factor clique value + ptl value assn ptl dump assn clique assignment assn r f unroll var clique iterator clique iterator next variable var variable next var + + assn get var + + assn get var + weight w cnum j infinite w pwpl r f trainer logger warning weight infinite clique + cnum + assignment + j na n w pwpl r f trainer logger warning weight nan clique + cnum + assignment + j w r o n g w r o n g h n l n g wrong wrong var idx v idx assn idx wrong wrong r f unroll graph graph var v variable var assn idx var idx graph get index var v idx graph get index v assn idx assn idx r f unroll var find var r f unroll graph unroll unroll get unroll var v idx variable find variable r f unroll graph unroll unroll get var idx wrong wrong add wrong wrong instance training wrong wrong training size total 0 acrf cache unroll graph illegal wrong wrong won t work cache unroll graph 0 training size i++ wrong wrong num 0 instance instance training get r f unroll graph unroll acrf unroll instance unroll factor size 0 err w r n n g factor graph instance + instance get name + factor inferenc inf acrf get inferenc inf compute marginal unroll assignment target unroll get assignment iterator unroll unroll var iterator next r f unroll var v r f unroll var next factor marg inf lookup marginal v assignment iterator assn v assignment iterator assn next assn advance marg value assn wrong wrong threshold assignment assn assn assignment vi 0 vi v size vi++ variable var v get vi wrong2 assn target assn var assn idx assn single index computing w w +vs+ idx +assn idx+ target +var wrong wrong add wrong wrong unroll v var assn idx num added++ logger info wrong wrong instance + + + instance get name + num + num total + num reset constraint collect constraint training force stale logger info total timestep + total timestep training logger info total wrong wrong + total total timestep instance ilist total 0 0 ilist size i++ instance inst ilist get seq inst get total + seq size total wrong2 assn assignment target assignment assn variable exclude variable var assn get var 0 var length i++ variable variable var variable exclude assn get variable target get variable assn get exclude target get exclude optimizable r f 