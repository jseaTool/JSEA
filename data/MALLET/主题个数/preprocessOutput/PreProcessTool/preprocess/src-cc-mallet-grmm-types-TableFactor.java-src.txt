2003 univ dept part m l l e t m achine learning languag e toolkit 1 0 information see ` l e n e type collection iterator flop type matrix type matrixn math create jan 4 2006 h r e f $ table factor v 1 1 2007 10 22 21 37 44 $ table factor table factor discrete factor multiply factor phi multiply phi collection multinomial potential xxx once there type potential need refactor into factor utility table factor multiply collection phi phi size 1 factor first factor phi iterator next table factor first duplicate get variable var v hash var iterator phi iterator next factor phi factor next v add phi var define over neighbor n o e table factor p f table factor v iterator phi iterator next factor phi factor next p f multiply phi p f table factor variable var var table factor variable var value var value table factor table factor bidirectional map var map var map table factor variable var var table factor collection var var table factor variable var prob var prob table factor var var prob var prob table factor variable var matrix prob var prob table factor table factor prob matrix get value matrix clone matrix table factor var var matrix prob var prob table factor table factor ptl prob ptl prob identity 1 0 factor duplicate table factor table factor blank subset variable var table factor var multiplie entry constant entry sum 1 factor normalize flop increment 2 prob num location prob normalize sum flop increment prob num location prob norm log value assignment iterator flop log math log raw value index current assn log value assignment assn flop log math log raw value assn log value loc flop log math log raw value loc value assignment assn raw value assn value loc raw value loc value assignment iterator assn raw value assn index current assn factor marginalize internal table factor 0 0 projection large idx small add element single large potentialto correct element small num loc prob num location large loc 0 large loc num loc large loc++ convert single index small small idx projection large loc whew now add old value prob value location large loc prob increment single value small idx old value flop increment num loc destructive multiplication assume variable pot multiply internal discrete factor ptl projection large idx small ptl num loc prob num location single loc 0 single loc num loc single loc++ small idx projection single loc prev prob value location single loc val ptl value small idx prob value location single loc prev val flop increment num loc destructive divison assume variable pot divide internal discrete factor ptl projection large idx small ptl num loc prob num location single loc 0 single loc num loc single loc++ small idx projection single loc prev prob value location single loc val ptl value small idx prev val convention let divide zero just 0 math almost equal val 0 0 prob value location single loc flop increment num loc destructive assume variable pot plus equal internal discrete factor ptl projection large idx small ptl num loc prob num location single loc 0 single loc num loc single loc++ small idx projection single loc prev prob value location single loc val ptl value small idx prob value location single loc prev + val flop increment num loc raw value assignment assn num var get num var index num var 0 num var i++ variable var get variable index assn get var value raw value index value raw value index handle occur index specially value inf log space single idx prob single index index raw value single idx raw value single idx loc prob location single idx loc 0 0 prob value location loc exponentiate power loc 0 loc prob num location loc++ old val prob value location loc val math pow old val power prob value location loc val flop pow prob num location table factor ensure operand compatible table factor ptl ptl table factor table factor ptl ptl log value assignment assn log value flop raw value assn math log value log value assignment iterator assn log value flop raw value assn math log value value assignment iterator assn value raw value assn value log value val flop val length 0 val length i++ raw value math val value val 0 val length i++ raw value val time equal v flop increment prob num location prob time equal v plus equal location loc v flop increment 1 old val value location loc raw value loc old val + v matrix get value matrix prob matrix get log value matrix flop log prob num location matrix log prob matrix prob clone matrix loc 0 loc prob num location loc++ log prob value location loc math log log prob value location loc log prob value location idx prob value location idx create another restrict assignment var variable over observe evidence restrict give value variable ptl var var discrete over var factor slice onevar variable var assignment observe val var get num outcome 0 var get num outcome i++ assignment assn assignment var assignment union assignment union assn observe val value union table factor var val factor slice twovar variable v1 variable v2 assignment observe n1 v1 get num outcome n2 v2 get num outcome sz n1 n2 variable varr variable v1 v2 outcome 2 val n1 n2 0 n1 i++ outcome 0 j 0 j n2 j++ outcome 1 j assignment var assignment varr outcome assignment assn assignment union var observe idx matrixn single index sz j inefficient much les prone val idx value assn table factor variable v1 v2 val factor slice variable var assignment observe var keep hash var var keep observe var val keep weight assignment iterator keep assignment iterator next assignment union assignment union observe assignment val index current assn value union advance table factor keep val table factor log value var domain val vals2 val length 0 val length i++ vals2 math val table factor domain vals2 table factor recent loc argmax val value location loc time equal 1 0 val 