2003 univ dept part m l l e t m achine learning languag e toolkit 1 0 information see ` l e n e learning logging logger io regex pattern gnu trove jdom document jdom element jdom j dom jdom input builder inference type label assignment model optimize optimizable pipe pipe type util logger arbitrary r f these r f completely arbitrary graphical structure user pass instance r f clique factory get look decide what charles sutton $ r f v 1 1 2007 10 22 21 37 43 $ r f serializable logger logger logger get logger r f get name template template fix ptl 0 graph post processor graph processor alphabet input alphabet inferenc global inferenc t r p inferenc viterbi t r p max feature index pipe input pipe cache unroll graph map graph cache t hash map gaussian prior variance e f u l t g u n p r o r v r n e e f u l t g u n p r o r v r n e 10 0 size scale r f 1 need template r f pipe input pipe template tmpl illegal argument input pipe input pipe template tmpl input alphabet input pipe get alphabet feature index input alphabet size tidx 0 tidx template length tidx++ template tidx index tidx accessor alphabet get input alphabet input alphabet get feature index feature index inferenc get inferenc global inferenc inferenc inferenc inf global inferenc inf inferenc get viterbi inferenc viterbi viterbi inferenc inferenc inf viterbi inf size scale size scale size scale size scale size scale size scale set template r f support feature template support feature unsupport feature support 0 template length i++ template support cache unroll graph cache unroll graph cache unroll graph cache unroll graph cache unroll graph cache unroll graph fix potential template fix fix ptl fix tidx 0 tidx fix length tidx++ fix tidx index 1 add fix potential template tmpl 0 tmpl length i++ template tmpl tmpl tmpl trainable fix ptl add tmpl tmpl index 1 template get template template pipe get input pipe input pipe template get fix template template fix ptl template fix ptl size add fix template tmpl tmpl trainable fix ptl add tmpl tmpl index 1 get gaussian prior variance gaussian prior variance gaussian prior variance gaussian prior variance gaussian prior variance gaussian prior variance graph processor graph post processor graph processor graph processor graph processor making global transformation unroll graph be generate direct model can simulate selectively normalize potential graph post processor serializable process unroll graph graph instance inst type clique model type clique assume same possible outcome same weight t o o implement log linear template fix template template serializable o m e u n u p p o r t e t h r e h o l 0 1 unsupport weight add instiat clique instance call graph being unroll instance graph graph clique instance instance unroll grpah subclass specify what type they expect instance slot add instantiate clique unroll graph graph instance instance modifie factor compute template useful template wish implement normalization etc nothing p w r n n g you implement likely you change factor weight you able tt r f trainer tt template unroll graph graph factor sit clique node domain factor ptl factor unroll graph unroll graph unroll var clique table factor ptl sparse vector weight bit assignment present support support support set template support feature support support support support unsupport weight unsupport weight bit get assignment present assignment present weight clique template possible assignment clique can different weight sparse vector w w weight assignment sparse vector get weight weight weight sparse vector w weight w length weight length illegal argument weight length change +weight length+ now +w length weight w initializ weight vector appropriate size training weight create init weight instance training logger info template +this+ weight + support ? n o l l + unsupport feature support init sparse weight training init dense weight training init dense weight instance training numf training get alphabet size total 0 handle weight size clique size instance training total + allocate weight size regular weight sparse vector weight sparse vector size 0 size i++ weight sparse vector numf weight weight plus equal sparse weight total + numf logger info r f template +this+ weight +i+ num feature +numf logger info r f template +this+ total num weight +total weight weight total init sparse weight instance training check clique size consistent training debug total 0 build bitset tell u what weight occur size clique size instance training bit weight present bit size 0 size i++ weight present bit assignment present bit size collect weight present training weight present weight add current weight weight present we can allocate weight now total + allocate weight size allocate sparse vector sparse vector weight sparse vector size total + allocate weight weight present weight logger info r f template +this+ total num weight +total weight weight total allocate weight bit weight present sparse vector weight total 0 0 weight present length i++ sparse vector allowable index specify advance num location weight present cardinality index num location j 0 j num location j++ index j weight present next bit j 0 ? 0 index j 1 +1 r f +this+ +i+ index +indice j weight hash sparse vector index num location num location num location weight weight plus equal sparse weight total + num location num location 0 logger info r f template +this+ weight +i+ num feature +num location total weight already initialize add some unsupport weight instance training add debug marker unsupport weight size weight length bit weight present bit size 0 size i++ weight present bit collect some unsupport weight training weight present add current weight weight present sparse vector weight sparse vector size num allocate weight weight present weight logger info this+ some support weight +num weight weight num collect some unsupport weight instance training bit weight present 0 training size ii++ instance inst training get unroll graph unroll unroll graph inst template iterator unroll unroll var iterator next unroll var v unroll var next factor f v get factor factor nrm f normalize assignment iterator assn nrm assignment iterator assn next nrm value assn o m e u n u p p o r t e t h r e h o l add present feature weight present assn index current assn v fv assn advance allocate weight size sparse vector newdefault weight sparse vector size weight newdefault weight plus equal sparse weight weight newdefault weight size clique size instance instance training max weight 0 0 training size i++ instance instance training get unroll graph unroll unroll graph instance template iterator unroll unroll var iterator next unroll var clique unroll var next clique tmpl weight clique weight weight max weight max weight weight max weight 0 logger warning r f t know size +this+ nev training max weight debug function check clique size consistent instance training weight 1 0 training size i++ instance instance training get unroll graph unroll unroll graph instance template iterator unroll unroll var iterator next unroll var clique unroll var next clique tmpl weight clique weight err weight change clique +clique+ template +this+ old +weight+ +clique weight vi 0 vi clique size vi++ variable var clique get vi err var+ +var get num outcome weight 1 weight clique weight illegal instance +instance+ template +this+ clique +clique+ strange weight +weight+ now +clique weight add current weight bit weight present assn 0 assn weight length assn++ j 0 j weight assn num location j++ weight present assn weight assn index location j collect weight present instance ilist bit weight present inum 0 inum ilist size inum++ instance inst ilist get inum unroll graph unroll unroll graph inst template collect transition present graph unroll collect weight present graph unroll weight present collect transition present graph unroll graph unroll iterator unroll unroll var iterator next unroll var clique unroll var next clique tmpl assn clique lookup assignment assignment present assn collect weight present graph unroll graph unroll bit weight present iterator unroll unroll var iterator next unroll var clique unroll var next clique tmpl assn clique lookup assignment add present feature weight present assn clique fv add present feature bit wp feature vector fv 0 fv num location i++ index fv index location wp index table factor compute factor unroll var clique matrix phi factor matrix clique sparse vector weight get weight unroll clique +clique f v +clique fv loc 0 loc phi num location loc++ idx phi index location loc idx weight length instantiate +this+ +clique+ clique too many + assignment weight +weight length+ clique weight +clique weight sparse vector w weight idx weight +idx+ +w w print dp w dot clique fv dp + get weight idx phi value location loc dp table factor ptl log table factor clique ptl value phi ptl create empty matrix store factor value template unroll override subclass enforce factor generate sparse clique empty matrixn matrix factor matrix unroll var clique sz clique var dimension matrixn sz index sparse vector weight get weight weight value sparse vector get weight weight weight sparse vector w weight w weight w weight value w trainable trainable trainable trainable tr trainable tr hate serialization serial u 727618747254644076 l 8830720632081401678 l read input stream o found read assignment present assignment present bit weight length assignment present flip 0 assignment present size assignment compute assignment assignment graph assn var v assignment graph assn marginalize v template expect feature vector label instance template template add instiat clique instance call graph being unroll instance graph graph clique fv input feature instance unroll clique lblseq label instance being unroll add instantiate clique unroll graph graph feature vector fv label assignment lblseq add instantiate clique unroll graph graph instance instance feature vector fv feature vector instance get label assignment lblseq label assignment instance get target add instantiate clique graph fv lblseq potential weight know te construct fix factor template template init weight instance training 0 sparse vector get weight sparse vector 0 sparse vector get weight sparse vector trainable trainable tr tr illegal argument template nev trainable table factor compute factor unroll var clique clique unroll graphical model instantiation some template contain pointer correspond template feature vector unroll var hash var template tmpl template generate clique feature vector fv feature clique variable var factor factor factor compute clique unroll graph graph last change cache graph change var factor since last grad call var dimension dim size 0 size i++ dim get get num outcome dim unroll var unroll graph graph template tmpl variable var feature vector fv var graph graph var var tmpl tmpl fv fv assignment get assignment assn size var dimension index size length matrixn single index assn index size assignment var index lookup assignment assignment mine lookup assignment mine single index assignment lookup assignment tmpl compute assignment graph get assignment lookup assignment assignment assn size var dimension index size length 0 index length i++ index assn get var matrixn single index size index template get template tmpl feature vector get fv fv factor get factor factor factor factor f factor last change factor dist linf table factor f table factor factor factor f get last change last change unroll graph undirect model t o o unroll graph factor graph compactible variable contain node model var contain instantiate clique unroll clique model clique label label num slice cache instance instance feature vector fv assignment assignment output label alphabet output alphabet r f acrf template factor t hash map uv map t hash map unroll graph instance inst template template template fix inst template fix unroll graph instance inst template template fix inst template fix create graphical model instance call unroll dynamic model unroll graph instance inst template template fix setup potential capacity inst instance inst fv feature vector inst get assignment assignment inst get target template fix template add fix template add template setup graph setup potential compute p f guess much cache undirect model space capacity instance inst inst get 8 feature vector fv feature vector inst get t fv size 3 t setup graph iterator template iterator next template tmpl template next tmpl add instantiate clique instance setup graph add clique unroll var clique clique add clique compute p f factor t resid tmp t iterator clique iterator next unroll var clique unroll var next table factor ptl clique tmpl compute factor clique add factor internal clique ptl clique tmpl clique ptl uv map put ptl clique sigh log table factor unif log table factor clique resid tmp add factor dist linf unif ptl last resid resid tmp add f t o r graph maintain invariant variable most factor over exactly domain f t o r domain already some factor p r e v p r e v replace factor graph contain p r e v f t o r clique factor factor add add factor internal unroll var clique factor factor clique factor factor factor prev factor factor factor var prev factor add factor factor prev factor factor graph prev factor multiply factor divide prev factor add factor factor graph factor factor prev factor last resid recompute factor last resid factor size iterator clique iterator next unroll var clique unroll var next table factor old f table factor clique get factor table factor f clique tmpl compute factor clique dist factor dist linf table factor old f duplicate normalize table factor f duplicate normalize last resid get index old f dist old f value f get log value matrix clique tmpl clique old f get last resid last resid accessor get max fv size get num factor output alphabet length assignment correspond label graph unroll assignment get assignment assignment xxx these refactor undirect model automatically add evidence potential t hash map observe var t hash map observe variable var observe var contain var observe variable var outcome observe var put var outcome observe value variable var observe var get var iterator unroll var iterator clique iterator unroll var get unroll var cnum unroll var clique get cnum get index var v clique index v variable get idx factor get idx variable var get idx get index variable var factor get index var var index var get log num assignment total 0 0 num variable i++ variable var get total + math log var get num outcome total convenience variable var index t j label assignment lblseq label assignment instance get target lblseq var index t j num slice label assignment lblseq label assignment instance get target lblseq num slice compute residual factor actually change unroll graph compute current resid last resid factor size iterator clique iterator next unroll var clique unroll var next table factor old f table factor clique get factor table factor f clique tmpl compute factor clique dist factor dist linf old f f last resid get index old f dist last resid unroll var get unroll var factor f unroll var uv map get f optimizable gradient value get maximizable instance ilst maximizable r f ilst best assignment instance lst ret lst size 0 lst size i++ ret add best assignment lst get ret assignment best assignment instance inst compute m p assignment unroll graph unroll unroll inst model best assignment unroll viterbi get best label instance lst ret lst size 0 lst size i++ ret add get best label lst get ret label get best label instance inst assignment assn best assignment inst label assignment gold label assignment inst get target gold label assn unroll graph unroll instance inst unroll graph g cache unroll graph graph cache contain key inst g unroll graph graph cache get inst g recompute factor g unroll graph inst template fix ptl graph processor graph processor process g inst cache unroll graph graph cache put inst g g unroll graph unroll structure instance inst unroll graph g cache unroll graph graph cache contain key inst g unroll graph graph cache get inst g recompute factor g unroll graph inst template fix ptl graph processor graph processor process g inst cache unroll graph graph cache put inst g g report graph cache logger info cache graph +graph cache size maximizable r f optimizable gradient value serializable instance train cache value 123456789 cache gradient bit infinite value cache value stale cache gradient stale num total node 0 print gradient unroll r f unroll graph graph inferenc inferenc global inferenc duplicate vector contain count feature observe training map clique template feature count sparse vector constraint vector contain expect value over label feature see training training label sparse vector expectation sparse vector constraint sparse vector expectation init weight instance training tidx 0 tidx template length tidx++ num + template tidx init weight training initialize constraint expectation same dimension weight zero init constraint expectation first constraint sparse vector template length expectation sparse vector template length tidx 0 tidx template length tidx++ sparse vector template tidx get weight constraint tidx sparse vector clone matrix zero expectation tidx sparse vector clone matrix zero now other constraint sparse vector template length expectation sparse vector template length tidx 0 tidx template length tidx++ template tmpl template tidx sparse vector weight tmpl get weight constraint tidx sparse vector weight length expectation tidx sparse vector weight length 0 weight length i++ constraint tidx sparse vector weight clone matrix zero expectation tidx sparse vector weight clone matrix zero expectation 0 they ve be initialize reset expectation tidx 0 tidx expectation length tidx++ expectation tidx 0 0 0 expectation tidx length i++ expectation tidx 0 0 maximizable r f instance ilist logger fine initialize maximizable r f allocate weight constraint expectation train ilist init weight train init constraint expectation num instance train size cache gradient num cache value stale cache gradient stale cache unroll graph unroll graph unroll graph num instance logger info training instance + num instance logger info + num logger info feature index + feature index describe prior logger fine computing constraint collect constraint train describe prior logger info gaussian prior variance +gaussian prior variance test maximizable r f maximizable r f maxable instance ilist logger fine initialize maximizable r f train ilist init constraint expectation constraint maxable constraint these can share num instance train size these occur init weight num num weight cache gradient num cache value stale cache gradient stale cache unroll graph unroll graph unroll graph num instance get num num negate value value because weight value get buf buf length num illegal argument argument + correct dimension idx 0 tidx 0 tidx template length tidx++ template tmpl template tidx sparse vector tmpl get weight value get value arraycopy value 0 buf idx value length idx + value length tidx 0 tidx template length tidx++ template tmpl template tidx sparse vector weight tmpl get weight assn 0 assn weight length assn++ value weight assn get value arraycopy value 0 buf idx value length idx + value length length num illegal argument argument + correct dimension cache value stale cache gradient stale idx 0 tidx 0 tidx template length tidx++ template tmpl template tidx sparse vector tmpl get weight value get value arraycopy idx value 0 value length idx + value length tidx 0 tidx template length tidx++ template tmpl template tidx sparse vector weight tmpl get weight assn 0 assn weight length assn++ value weight assn get value arraycopy idx value 0 value length idx + value length function unit test get constraint expectation m too lazy deep caller these sparse vector get expectation cnum expectation cnum sparse vector get constraint cnum constraint cnum print weight print buf num get buf len buf length w 0 w len w++ print buf w + get parameter index 0 0 parameter index value log probability training label get value cache value stale cache value compute log likelihood cache value stale cache gradient stale save num++ % save 0 saving r f r f write weight weight logger info get value loglikelihood + cache value na n cache value logger warning value na n cache value 0 cache value compute log likelihood retval 0 0 num instance train size start current milli unroll 0 marginal 0 instance value nev total value we can t just sometime skip value because infinite off total value we instance infinite value happen start we t compute value instance first round instance infinite value initialize infinite value infinite value we could initialize bitset slot instance probably cheap taking hit allocate space bit become infinite value bit initialize infinite value clear statistic we about fill reset expectation fill expectation instance 0 num instance i++ instance instance train get compute marginal clique unroll start current milli unroll graph unroll unroll instance unroll current milli unroll + unroll unroll start unroll num variable 0 happen node prune inferenc compute marginal unroll marginal + current milli unroll unroll dump save expect value feature we compute gradient collect expectation unroll inferenc add joint prob label assignment joint assn unroll get assignment value inferenc lookup log joint joint assn infinite value initialize infinite value logger warning instance + instance get name + infinite value skip infinite value infinite value get logger warning infinite value instance +instance get name + infinity n e g t v e n f n t y print debug info unroll illegal instance + instance get name + infinite + value now infinite value na n value na n instance +i+ +instance get name print debug info unroll illegal value na n r f get value instance +i logger warning value na n r f get value instance +i+ + infinity n e g t v e n f n t y retval + value size scale retval retval train size incorporate gaussian prior weight we add w^2 2 variance log probability prior denom 2 gaussian prior variance tidx 0 tidx template length tidx++ sparse vector weight template tidx get weight j 0 j weight length j++ fnum 0 fnum weight j num location fnum++ w weight j value location fnum weight w tidx j retval + w w prior denom cache unroll graph report graph cache current milli logger info r f inference m + start logger info r f marginal m +marginal logger info r f unroll m +unroll logger info get value loglikelihood +retval retval compute graident penalize log likelihood r f buf get value gradient buf cache gradient stale fill expectation cache value stale get value compute gradient cache gradient stale buf length num illegal argument incorrect length buffer get value gradient expect + num + + buf length arraycopy cache gradient 0 buf 0 cache gradient length compute gradient penalize log likelihood r f place cache gradient gradient constraint expectation gaussian prior variance compute gradient index into current element cache gradient gidx 0 first gradient wrt weight tidx 0 tidx template length tidx++ sparse vector these weight template tidx get weight sparse vector these constraint constraint tidx sparse vector these expectation expectation tidx j 0 j these weight num location j++ weight these weight value location j constraint these constraint value location j expectation these expectation value location j print gradient gradient + gidx + e f u l t +template tidx + +j+ + constraint + ctr + expectation + + weight gaussian prior variance + reg scale size scale ? 1 0 train size 1 0 cache gradient gidx++ scale constraint expectation weight gaussian prior variance now weight tidx 0 tidx template length tidx++ template tmpl template tidx sparse vector weight tmpl get weight 0 weight length i++ sparse vector weight vec weight sparse vector constraint vec constraint tidx sparse vector expectation vec expectation tidx j 0 j weight vec num location j++ w weight vec value location j gradient compute below parameter infinity external user we gradient 0 because parameter value can nev change anyway mess up future calculation matrix infinite w logger warning infinite weight node index +i+ feature + input alphabet lookup j gradient 0 0 constraint constraint vec value location j expectation expectation vec value location j scale size scale ? 1 0 train size 1 0 gradient scale constraint expectation w gaussian prior variance print gradient feature name input alphabet lookup j gradient + gidx + w e g h t +template tidx + +i+ +feature name+ + constraint + ctr + expectation + + w gaussian prior variance + reg cache gradient gidx++ gradient report gradient useful debug grad call 0 report gradient verbose output directory grad call no++ verbose output directory acrf grad +grad call no+ txt print writer writer print writer writer writer util cache gradient writer close verbose output directory acrf value +grad call no+ txt writer print writer writer writer cache value writer close buf get num get buf verbose output directory acrf weight +grad call no+ txt writer print writer writer writer util buf writer close verbose output directory acrf constraint +grad call no+ txt print vec constraint constraint verbose output directory acrf +grad call no+ txt print vec expectation expectation verbose output directory acrf dump +grad call no+ txt writer print writer writer 0 train size ii++ r f unroll graph unroll unroll train get writer unroll writer close o e runtime e print vec sparse vector constraint sparse vector constraint o print writer writer print writer writer ti 0 ti constraint length ti++ writer constraint ti ti 0 ti constraint length ti++ 0 constraint ti length i++ writer constraint ti writer close feature f k compute expect value f k aver possible label sequence instance we these value store collector collector j k get expect value feature clique label assignment j input feature k collect expectation unroll graph unroll inferenc inferenc iterator unroll unroll var iterator next unroll var clique unroll var next tidx clique tmpl index tidx 1 factor ptl inferenc lookup marginal clique assigment clique note we get assignment iterator factor rath clique because factor know about sparsity also note we assn index current assn ordering variable var lookup margianl consistent between call somewhat brittle assumption t see relax being terribly inefficient assignment iterator assn ptl assignment iterator assn next marginal ptl value assn idx assn index current assn expectation tidx idx plus equal sparse clique fv marginal expectation tidx location idx 1 expectation tidx increment value idx marginal assn advance collect constraint instance ilist inum 0 inum ilist size inum++ logger fine collecting constraint instance +inum instance inst ilist get inum unroll graph unroll unroll graph inst template total node + unroll num variable iterator unroll unroll var iterator next unroll var clique unroll var next tidx clique tmpl index tidx 1 assn clique lookup assignment constraint tidx assn plus equal sparse clique fv constraint tidx location assn 1 constraint tidx increment value assn 1 0 dump gradient name print stream w print stream output stream name 0 num i++ w cache gradient w close o e err could output e print stack trace dump constraint 0 constraint length i++ template +i constraint print expectation 0 expectation length i++ template +i expectation print print debug info unroll graph unroll print err assignment assn unroll get assignment iterator unroll unroll var iterator next unroll var clique unroll var next clique +clique dump assn clique assn clique factor ptl unroll factor clique value +ptl value assn ptl dump assn clique assignment assn unroll var clique iterator clique iterator next variable var variable next var+ +assn get var + +assn get var + weight w cnum j infinite w logger warning weight infinite clique +cnum+ assignment +j na n w logger warning weight nan clique +cnum+ assignment +j report nmsg 1 inferenc belief propagation nmsg belief propagation inferenc get total message sent inferenc junction tree inferenc nmsg junction tree inferenc inferenc get total message sent nmsg 1 logger info total message sent +nmsg force stale cache value stale cache gradient stale get total node total node maximizable r f printing function print output stream o print stream print stream o r f template +template length weight tidx 0 tidx template length tidx++ template tmpl template tidx t e m p l t e +tidx+ +tmpl weight sparse vector tmpl get weight loc 0 loc num location loc++ +default index location loc + +default value location loc sparse vector weight tmpl get weight assn 0 assn weight length assn++ assignment +assn sparse vector w weight assn 0 w num location x++ idx w index location idx feature index print e f u l t print input alphabet lookup idx +w value location dump value sparse vector value cnum 0 cnum value length cnum++ title+ clique +cnum write clique value value cnum o e err e print stack trace write clique value sparse vector value o num assignment +value length assn 0 assn value length assn++ num location +value assn num location j 0 j value assn num location j++ idx value assn index location j print sparse +assn+ +idx+ value assn value location j dump graph unroll graph unroll assignment assn unroll get assignment iterator unroll unroll var iterator next unroll var clique unroll var next clique +clique dump assn clique assn clique factor ptl unroll factor clique ptl ptl dump unroll graph instance lst 0 lst size i++ instance inst lst get n t n e +i+ +inst get name unroll graph unroll unroll inst dump graph unroll template template add edge between adjacent node label factor bigram template r f template factor bigram template factor factor factor add instantiate clique r f unroll graph graph feature vector fv label assignment lblseq 0 lblseq max 1 i++ variable v1 lblseq var index factor variable v2 lblseq var index + 1 factor feature vector fv fv get feature vector variable var variable v1 v2 v1 couldn t get label factor +factor+ +i v2 couldn t get label factor +factor+ + i+1 r f unroll var clique r f unroll var graph var fv graph add clique clique bigram template +factor+ get factor factor serial u 8944142287103225874 l template add node potential factor unigram template r f template factor unigram template factor factor factor add instantiate clique r f unroll graph graph feature vector fv label assignment lblseq 0 lblseq max i++ variable v lblseq var index factor feature vector fv fv get feature vector variable var variable v v couldn t get label factor +factor+ +i r f unroll var clique r f unroll var graph var fv graph add clique clique unigram template +factor+ serial u 1 l template add edge between cotemporal node pair factor pairwise factor template r f template factor0 factor1 pairwise factor template factor0 factor1 factor0 factor0 factor1 factor1 add instantiate clique r f unroll graph graph feature vector fv label assignment lblseq 0 lblseq max i++ variable v1 lblseq var index factor0 variable v2 lblseq var index factor1 feature vector fv fv get feature vector variable var variable v1 v2 v1 couldn t get label factor +factor0+ +i v2 couldn t get label factor +factor1+ +i r f unroll var clique r f unroll var graph var fv graph add clique clique pairwise factor template +factor0+ +factor1+ serial u 1 l read weight reader reader o document builder build reader element root get root element tmpl root get child t e m p l t e iterator tmpl iterator next element tmpl elt element next tmpl name tmpl elt get attribute value n m e ti parse tmpl elt get attribute value r f template tmpl template ti tmpl get get name equal tmpl name runtime expect template +tmpl+ get +tmpl name element def w elt tmpl elt get child e f u l t w e g h t sparse vector def w read sparse vector def w elt get element w vec elt tmpl elt get child w e g h t nw parse w vec elt get attribute value z e sparse vector w sparse vector nw w lst w vec elt get child w e g h t iterator it2 w lst iterator it2 next element w elt element it2 next wi parse w elt get attribute value w wi read sparse vector w elt get get input alphabet tmpl weight def w tmpl weight w j dom e runtime e sparse vector read sparse vector str alphabet dict o t idx t t val t line str split 0 line length li++ line line pattern match ^\\ $ line field line split idx dict idx dict lookup index field 0 idx parse field 0 val parse field 1 idx add idx val add val sparse vector idx val write weight writer writer print writer print writer writer r f ti 0 ti template length ti++ template tmpl template ti t e m p l t e n m e \ +tmpl get get name + \ \ +ti+ \ e f u l t w e g h t sparse vector def w tmpl get weight loc 0 loc def w num location loc++ print def w index location loc print def w value location loc e f u l t w e g h t sparse vector w tmpl get weight w e g h t z e \ +w length+ \ wi 0 wi w length wi++ w e g h t \ +wi+ \ write weight vector w wi w e g h t w e g h t t e m p l t e r f write weight vector print writer sparse vector sv t alphabet dict get input alphabet loc 0 loc sv num location loc++ idx sv index location loc val sv value location loc idx dict size print dict lookup idx print +idx print val convenient construct r f r f factorial pipe p num level t 0 num level i++ t add bigram template i+1 num level t add pairwise factor template i+1 template tmpl template t template t size r f p tmpl hate serialization serial u 2865175696692468236 l 2113750667182393436 l read input stream o found read graph cache t hash map verbose output directory verbose output directory dir verbose output directory dir r f 