2003 univ dept part m l l e t m achine learning languag e toolkit 1 0 information see ` l e n e inference 3pq jgrapht graph helper 3pq jgrapht undirect graph 3pq jgrapht alg connectivity inspector 3pq jgrapht graph simple graph 3pq jgrapht graph listenable undirect graph 3pq jgrapht traverse breadth first iterator type graph type alphabet logger io o io input stream io output stream logging level logging logger inference graphical model hugin junction tree algorithm create mon nov 10 23 58 44 2003 charles sutton $ junction tree inferenc v 1 1 2007 10 22 21 37 49 $ junction tree inferenc inferenc logger logger logger get logger junction tree inferenc get name log space junction tree propagation propagator junction tree inferenc junction tree propagation sum inferenc junction tree inferenc constructor junction tree inferenc junction tree propagation propagator propagator propagator junction tree inferenc max junction tree inferenc junction tree propagation max inferenc adjacent undirect graph g variable v1 variable v2 g get edge v1 v2 junction tree jt current clique edge graph vertex remove triangulation procedure value edge elimination clique v already present edge undirect graph mdl variable v rating 0 iterator it1 neighbor iterator mdl v it1 next variable neighbor1 variable it1 next iterator it2 neighbor iterator mdl v it2 next variable neighbor2 variable it2 next neighbor1 neighbor2 adjacent mdl neighbor1 neighbor2 rating++ v+ +rat rating weight clique graph vertex remove triangulation procedure value edge elimination clique v already present weight undirect graph mdl variable v rating 1 iterator it1 neighbor iterator mdl v it1 next variable neighbor variable it1 next rating neighbor get num outcome v+ +rat rating connect neighbor undirect graph mdl variable v iterator it1 neighbor iterator mdl v it1 next variable neighbor1 variable it1 next iterator it2 neighbor iterator mdl v it2 next variable neighbor2 variable it2 next neighbor1 neighbor2 adjacent mdl neighbor1 neighbor2 mdl add edge neighbor1 neighbor2 e runtime e xx refactor into collection coll t proc iff clique l strictly contain find clique l var iterator l iterator next var c2 var next c2 contain obscure operator perl cmp i1 i2 i1 i2 1 i1 i2 1 0 variable pick vertex undirect graph mdl lst iterator lst iterator variable best variable next best val1 edge mdl best best val2 weight mdl best next variable v variable next val edge mdl v val best val1 best v best val1 val best val2 weight mdl v val best val1 val2 weight mdl v val2 best val2 best v best val1 val best val2 val2 best add edge graph until triangulate triangulate undirect graph mdl undirect graph mdl2 dup graph mdl var mdl vertex alphabet var map vertex map var clique debug logger loggable level f n e r logger fine triangulate model +mdl ret 0 var size i++ variable next variable var get ret + next + + mdl get index next + logger fine ret var empty variable v variable pick vertex mdl2 var logger fine triangulate vertex + v var var bit var v get universe graph helper neighbor mdl2 v var add v find clique clique var clique add var logger loggable level f n e r logger fine elim clique + var + size + var size + weight + var weight v graph first because add edge change rating vertex connect neighbor mdl2 v var v mdl2 vertex v logger loggable level f n e logger fine triangulation clique tot size 0 tot weight 0 max size 0 max weight 0 iterator clique iterator next var var next logger fine tot size + size max size math max size max size tot weight + weight max weight math max weight max weight sz clique size logger fine jt create + sz + clique size avg + tot size sz + max + max size + weight avg + tot weight sz + max + max weight alphabet vertex map var alphabet map alphabet var size variable map lookup index var map sepset size bit var pair pair length 2 pair 0 intersection size pair 1 sepset cost var pair pair length 2 pair 0 weight + pair 1 weight two pair clique 1 pair o1 tree first we add pair large mass vertex ensure clique tree satifie running intersection comparator sepset chooser comparator compare o1 o2 o1 o2 0 bit var pair1 bit var o1 bit var pair2 bit var o2 size1 sepset size pair1 size2 sepset size pair2 retval cmp size1 size2 retval 0 tie add sepset small cost sum weight connect cluster cost1 sepset cost pair1 cost2 sepset cost pair2 retval cmp cost1 cost2 still tie? arbitrarily consistently retval 0 retval cmp o1 hash o2 hash retval junction tree graph jt undirect graph g junction tree jt junction tree g vertex size root g vertex iterator next jt add root iterator it1 breadth first iterator g root it1 next v1 it1 next iterator it2 graph helper neighbor g v1 iterator it2 next v2 it2 next jt get parent v1 v2 jt add node v1 v2 jt junction tree build jt structure tree pq tree sepset chooser initialize pq possible edge iterator clique iterator next bit var c1 bit var next iterator it2 clique iterator it2 next bit var c2 bit var it2 next c1 c2 pq add bit var c1 c2 add edge jt come top queue t cycle xxx o k suck openjgraph doesn t add disconnect edge tree what we ll graph frist convert tree listenable undirect graph g listenable undirect graph simple graph first add clique graph iterator clique iterator next var var next g add vertex connectivity inspector inspector connectivity inspector g g add graph listener inspector add n 1 edge num clique clique size edge 0 edge num clique 1 var pair var pq first pq pair inspector path pair 0 pair 1 g add edge pair 0 pair 1 edge added++ junction tree jt graph jt g logger loggable level f n e r logger fine jt structure + jt jt init jt cpt factor graph mdl junction tree jt iterator jt get vertex iterator next var var next discrete factor ptl blank factor jt p f ptl jt p f constant factor 1 0 iterator mdl factor iterator next factor ptl factor next var parent jt find parent cluster ptl var parent unable find parent cluster ptl + ptl + jt + jt factor cpf jt get p f parent factor cpf cpf multiply ptl jt p f parent cpf debug jt na n runtime get na n table factor blank factor var log space log table factor table factor compute marginal factor graph mdl log space mdl get factor 0 log table factor build junction tree mdl propagator compute marginal jt current total message sent + propagator get total message sent compute marginal junction tree jt log space ?? jt current jt propagator compute marginal jt current total message sent + propagator get total message sent construct junction tree factor graph p graph give you structure jnuction tree factor t correspond marginal unles you call p yourself mdl factor graph compute j t junction tree build junction tree factor graph mdl jt current junction tree mdl get inference cache junction tree inferenc jt current jt current clear p f graph g topology m r f correspond factor graph mdl essentially we triangulate factor graph convert m r f first could chosen trianglualte factor graph directly didn t historical reason already have triangulate m r f bipartite factor graph note call mdl graph perfectly factor graph also direct model effect moralizing undirect graph g graph mdl graph mdl triangulate g jt current build jt structure mdl inference cache junction tree inferenc jt current init jt cpt mdl jt current jt current undirect graph dup graph undirect graph original undirect graph simple graph graph helper add graph original factor lookup marginal variable var propagator lookup marginal jt current var factor lookup marginal var var propagator lookup marginal jt current var lookup log joint assignment assn jt current lookup log joint assn dump log joint assignment assn jt current dump log joint assn junction tree compute last call link compute marginal caller value junction tree lookup junction tree jt current iterator neighbor iterator undirect graph g variable v graph helper neighbor g v iterator dump jt current current junction tree jt current dump n o current junction tree total message sent 0 total message inferenc sent get total message sent total message sent serialization serial u 1 seralization incompatible these smart can these backward compatibility write output stream o write read input stream o found read junction tree inferenc 