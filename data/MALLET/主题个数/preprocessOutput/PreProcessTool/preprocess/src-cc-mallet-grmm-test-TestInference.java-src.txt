2003 univ dept part m l l e t m achine learning languag e toolkit 1 0 information see ` l e n e test junit framework assertion fail junit framework test junit framework test junit framework test suite random logging logger io o io reader io buffer reader inference type util model reader type dirichlet type matrix type matrixn type test test serializable random gnu trove t torture test inference g r m m well actually they re torturou hopefully they re least somewhat disconcert charles sutton $ test inference v 1 1 2007 10 22 21 37 40 $ test inference test logger logger logger get logger test inference get name p p e p l o n 0 15 algorithm brute force inferenc variable elimination junction tree inferenc appx alg t r p loopy p log joint test now alg brute force inferenc junction tree inferenc t r p variable elimination loopy p tree alg tree p model undirect model model factor graph tree factor tree marg test inference name name undirect model chain graph variable var variable 5 undirect model model undirect model add variable model 0 5 i++ var variable 2 add some link prob 0 9 0 1 0 1 0 9 0 4 i++ variable pair var var + 1 table factor pot table factor pair prob model add factor pot e e print stack trace model undirect model triangle variable var variable 3 0 3 i++ var variable 2 undirect model model undirect model var pot 0 2 0 8 0 1 0 9 0 7 0 3 0 5 0 5 0 6 0 4 0 8 0 2 0 35 0 65 pot model add factor var 0 var 1 pot 0 model add factor var 1 var 2 pot 1 model add factor var 2 var 0 pot 2 table factor pot table factor variable var 0 pot 3 model add factor pot model table factor random edge random r variable v1 variable v2 max1 v1 get num outcome max2 v2 get num outcome matrix phi matrixn max1 max2 0 v1 get num outcome i++ j 0 j v2 get num outcome j++ phi value j r next rescale r next table factor variable v1 v2 phi table factor random node random r variable v max v get num outcome matrix phi matrixn max 0 v get num outcome i++ phi single value rescale r next table factor variable v phi scale into range 0 2 0 8 rescale 0 2 + 0 6 undirect model random graph num v num outcome random r variable var variable num v 0 num v i++ var variable num outcome undirect model model undirect model var 0 num v i++ j + 1 j num v j++ r next model add factor random edge r var var j var edge add node keep thing simple we ll require normalize factor pot random node r var pot normalize model add factor pot ensure exactly connect component 0 num v i++ j + 1 j num v j++ model connect var var j factor ptl random edge r var var j model add factor ptl model undirect model random grid w h max outcome random r variable var variable w h undirect model mdl undirect model w h 0 w i++ j 0 j h j++ var j variable r next max outcome 1 + 2 0 w i++ j 0 j h j++ factor ptl w 1 ptl random edge r var j var + 1 j mdl add factor ptl j h 1 ptl random edge r var j var j + 1 mdl add factor ptl mdl undirect model random tree nnode max outcome random r variable var variable nnode undirect model mdl undirect model nnode 0 nnode i++ var variable r next max outcome 1 + 2 add some random edge 0 nnode i++ j + 1 j nnode j++ mdl connect var var j r next factor ptl random edge r var var j mdl add factor ptl ensure exactly connect component 0 nnode i++ j + 1 j nnode j++ mdl connect var var j force edge + + + j factor ptl random edge r var var j mdl add factor ptl mdl test model random r random 42 these model small we can run brute force inferenc them factor graph mdl factor graph triangle chain graph random graph 3 2 r random graph 3 3 r random graph 6 3 r random graph 8 2 r random grid 3 2 4 r random grid 4 3 2 r mdl test uniform joint factor graph mdl random graph uniform chain 3 expect math log 8 0 alg length i++ inferenc inf inferenc alg instance inf compute marginal mdl assignment iterator mdl assignment iterator next assignment assn assignment inf lookup log joint assn equal incorrect joint inferenc +inf expect 1e 5 advance test joint consistent 0 alg length i++ mdl idx 0 mdl idx model length mdl idx++ mdl idx 13 inferenc inf inferenc alg instance factor graph mdl model mdl idx inf compute marginal mdl assignment assn assignment mdl mdl num variable equal math log inf lookup joint assn inf lookup log joint assn 1e 5 unsupport operation e loopy p handle edge ptl logger warning skip + mdl idx + + + + e e test factorize joint inferenc inf inferenc alg length model length 0 alg length i++ mdl 0 mdl model length mdl++ inferenc alg inferenc alg instance alg t r p t r p alg random seed 1231234 alg compute marginal model mdl inf mdl alg unsupport operation e loopy p handle edge ptl logger warning skip + mdl + + + + e e ensure lookup log joint consistent alg1 0 brute force alg2 1 alg2 alg length alg2++ mdl 0 mdl model length mdl++ inferenc inf1 inf alg1 mdl inferenc inf2 inf alg2 mdl inf1 || inf2 iterator model mdl assignment iterator next assignment assn assignment next joint1 inf1 lookup log joint assn joint2 inf2 lookup log joint assn logger fine log joint + inf1 + + inf2 + model + mdl + assn + assn + n f1 + joint1 + + n f2 + joint2 + log joint equal btwn + util name inf1 + + + util name inf2 + + model + mdl + + n f1 + joint1 + + n f2 + joint2 + math ab joint1 joint2 0 2 joint3 inf1 lookup joint assn log joint joint consistent + model + mdl + + assn math almost equal joint3 math joint1 unsupport operation e var elim doesn t compute log joint let slide logger warning skip + inf1 + + inf2 + + e test marginal factor joint factor model length inferenc appx inferencer construct appx inferencer num exact alg algorithm length num appx alg appx inferencer length num alg num exact alg + num appx alg mdl 0 mdl model length mdl++ joint mdl factor num alg query know graph know alg 0 algorithm length i++ mdl 0 mdl model length mdl++ inferenc alg inferenc algorithm instance logger fine computing marginal model + mdl + alg + alg alg compute marginal model mdl joint mdl collect marginal model mdl alg logger fine check result consistent now sure exact marginal consistent same model mdl 0 mdl model length mdl++ max v model mdl num variable vrt 0 vrt max v vrt++ alg1 0 alg1 algorithm length alg1++ alg2 0 alg2 algorithm length alg2++ factor joint1 joint mdl alg1 vrt factor joint2 joint mdl alg2 vrt we get here joint there unsupport operation joint1 joint2 joint1 almost equal joint2 assertion fail e test f l e model + mdl + vertex + vrt alg + alg1 + + alg2 + consistent m r g n l + alg1 joint1 m r g n l + alg2 joint2 marginal + alg1 + 0 max v i++ joint mdl alg1 marginal + alg2 + 0 max v i++ joint mdl alg2 model mdl dump e compare approximate algorithm brute force logger fine check approximate algorithm alg2 0 brute force appx idx 0 appx idx appx inferencer length appx idx++ inferenc alg appx inferencer appx idx mdl 0 mdl model length mdl++ logger fine running inference alg + alg + model + mdl alg compute marginal model mdl unsupport operation e loopy p support vertex potential we ll let slide alg belief propagation logger warning skip model + mdl + alg + alg + inference unsupport e lookup marginal vrt 0 alg1 num exact alg + appx idx max v model mdl num variable joint mdl alg1 factor max v iterator model mdl variable iterator next vrt++ variable var variable next logger fine lookup marginal model + mdl + vrt + var + alg + alg factor ptl alg lookup marginal var joint mdl alg1 vrt ptl duplicate vrt 0 vrt max v vrt++ factor joint1 joint mdl alg1 vrt factor joint2 joint mdl alg2 vrt joint1 almost equal joint2 p p e p l o n assertion fail e appx marginal test f l e inferenc + alg model + mdl + vertex + vrt joint1 dump joint2 dump model mdl dump marginal 0 max v i++ joint mdl alg1 dump correct marginal 0 max v i++ joint mdl alg2 dump e test + model length + undirect model inferenc construct appx inferencer illegal access instantiation alg appx alg length 2 0 appx alg length i++ alg add appx alg instance add few t fit alg add t r p messag belief propagation sum message strategy 0 8 alg add loopy p messag belief propagation sum message strategy 0 8 alg add sampling inferenc gibbs sampler 10000 10000 alg add sampling inferenc exact sampler 1000 inferenc alg inferenc alg size inferenc construct max inferencer illegal access instantiation alg alg add junction tree inferenc max alg add t r p max alg add loopy p max inferenc alg inferenc alg size factor collect marginal factor graph mdl inferenc alg vrt 0 num vertex mdl num variable factor collector factor num vertex iterator mdl variable iterator next vrt++ variable var variable next collector vrt alg lookup marginal var collector vrt query model + mdl + vertex + var + alg + alg unsupport operation e unsupport inference slide warning logger warning warning skip model + mdl + alg + alg + inference unsupport collector test query random rand random 15667 mdl idx 0 mdl idx model length mdl idx++ factor graph mdl model mdl idx size rand next 3 + 2 size math min size mdl var size collection var collection util subset mdl variable size rand variable var arr variable var variable 0 assignment assn assignment var arr size brute force inferenc brute brute force inferenc factor joint brute joint mdl marginal joint marginalize var value assn alg idx 0 alg idx appx alg length alg idx++ inferenc alg inferenc appx alg alg idx instance alg t r p trp can t handle disconnect model arise dur query alg query mdl assn equal model +mdl idx+ alg +alg marginal p p e p l o n logger info test test query pass careful cache inference algorithm result here test serializable 0 algorithm length i++ inferenc alg inferenc algorithm instance test serialization alg alg 0 appx alg length i++ inferenc alg inferenc appx alg instance test serialization alg alg inferenc max alg construct max inferencer 0 max alg length i++ test serialization alg max alg test serialization alg inferenc alg o found mdl idx 0 mdl idx model length mdl idx++ factor graph mdl model mdl idx inferenc calling random seed issue inferenc alg2 inferenc test serializable clone via serialization alg alg compute marginal mdl factor pre collect marginal mdl alg alg2 compute marginal mdl factor post2 collect marginal mdl alg2 compare marginal comparing marginal serialzation model +mdl pre post2 compare marginal msg factor pre factor post 0 pre length i++ factor ptl1 pre factor ptl2 post msg + + ptl1 dump + + ptl2 dump ptl1 almost equal ptl2 1e 3 really impossible change factor graph representation test measurement number message sent ignore test num message mdl idx 0 mdl idx model length mdl idx++ undirect model mdl model mdl idx t r p trp t r p trp compute marginal mdl expect message mdl num variable 1 2 trp iteration equal expect message trp get total message sent loopy p loopy loopy p loopy compute marginal mdl expect message mdl get edge size 2 loopy iteration equal expect message loopy get total message sent undirect model jt chain num node 4 variable node variable num node 0 num node i++ node variable 2 factor pot table factor table factor variable node 0 node 1 1 2 5 4 table factor variable node 1 node 2 4 2 4 1 table factor variable node 2 node 3 7 3 6 9 0 pot length i++ pot normalize undirect model u graph undirect model 0 num node 1 i++ u graph add factor pot u graph j t h n t e t t r e e 2 test tree random r random 185 tree factor graph random graph uniform chain 2 random graph uniform chain 4 jt chain random grid 5 1 3 r random grid 6 1 2 r random tree 10 2 r random tree 10 2 r random tree 8 3 r random tree 8 3 r model add tree compute test tree marg tree marg factor tree length brute force inferenc brute brute force inferenc 0 tree length i++ factor graph mdl tree factor joint brute joint mdl tree marg factor mdl num variable iterator mdl variable iterator next variable var variable next tree marg mdl get index var joint marginalize var test jt consistency mdl idx 0 mdl idx model length mdl idx++ undirect model mdl model mdl idx junction tree inferenc jti junction tree inferenc junction tree jt jti build junction tree mdl iterator jt get vertex iterator next var parent var next iterator it2 jt get child parent iterator it2 next var child var it2 next factor ptl jt get sepset pot parent child intersection parent intersection child intersection equal ptl var compare trp joint factor joint t r p trp assignment assn prob1 0 0 prob2 0 0 var hash var joint var iterator assignment iterator next assn assignment next prob1 trp lookup joint assn prob2 joint value assn math almost equal prob1 prob2 math ab prob1 prob2 0 01 assertion fail e t e t f l u r e compare trp joint assn expect + prob2 t r p + prob1 expect joint joint t r p dump trp dump e test trp undirect model model triangle t r p trp t r p terminator t r p iteration terminator 200 brute force inferenc brute brute force inferenc factor joint brute joint model trp compute marginal model check joint discrete joint brute joint model compare trp joint joint trp check marginal iterator model variable iterator next variable var variable next factor marg1 trp lookup marginal var factor marg2 joint marginalize var marg1 almost equal marg2 p p e p l o n iterator model factor iterator next factor factor factor next factor marg1 trp lookup marginal factor var factor marg2 joint marginalize factor var marg1 almost equal marg2 p p e p l o n assertion fail e t e t f l u r e compare trp marg marg1 marg2 complete model model dump t r p marg trp dump correct marg iterator it2 model variable iterator it2 next variable v2 variable it2 next brute compute marginal model brute lookup marginal v2 e test trp joint factor graph model triangle t r p trp t r p terminator t r p iteration terminator 25 trp compute marginal model assignment model check t r p lookup log joint t r p lookup joint consistent var hash var model variable iterator assignment iterator next assignment assn assignment next log trp lookup log joint assn prob trp lookup joint assn math almost equal math log prob logger info test trp joint pass test running t r p doesn t inadvertantly change potential original graph test trp destructivity factor graph model triangle t r p trp t r p t r p iteration terminator 25 brute force inferenc brute brute force inferenc factor joint1 brute joint model trp compute marginal model factor joint2 brute joint model joint1 almost equal joint2 logger info test trp destructivity pass test trp reuse t r p trp1 t r p t r p iteration terminator 25 0 model length i++ trp1 compute marginal model hard automatically now logger info please ensure instantiation run 25 iteration ensure edge touch undirect model mdl model 0 tree tree trp1 almost random tree factory next tree mdl t r p trp2 t r p t r p tree factory tree next tree factor graph mdl tree trp2 compute marginal mdl logger info ensure instantiation run 1000 iteration warning tree str t r e e + v r n m e v0 + f t o r v r v0 v1 + v r n m e v1 + f t o r + f t o r v r v0 v2 + v r n m e v2 + f t o r + v r + t r e e t r e e + v r n m e v1 + f t o r v r v0 v1 + v r n m e v0 + f t o r + f t o r v r v1 v2 + v r n m e v2 + f t o r + v r + t r e e t r e e + v r n m e v0 + f t o r v r v0 v1 + v r n m e v1 + f t o r v r v1 v2 + v r n m e v2 + f t o r + v r + f t o r + v r + t r e e t r e e + v r n m e v2 + f t o r v r v2 v1 + v r n m e v1 + f t o r + f t o r v r v0 v2 + v r n m e v0 + f t o r + v r + t r e e test trp tree factor graph model triangle model get variable 0 label v0 model get variable 1 label v1 model get variable 2 label v2 reader 0 tree str length i++ reader add reader tree str t r p trp t r p terminator t r p convergence terminator factory t r p tree factory reader model reader trp compute marginal model inferenc jt brute force inferenc jt compute marginal model compare marginal model trp jt verify variable index consistent undirectect model test undirect index mdl idx 0 mdl idx model length mdl idx++ factor graph mdl model mdl idx iterator mdl variable iterator next variable var1 variable next variable var2 mdl get mdl get index var1 mismatch variable index + var1 + v + var2 + model + mdl idx + + mdl var1 var2 logger info test undirect index pass test t r p max propagation same result t r p run exactly iteration test trp viterbi equiv mdl idx 0 mdl idx tree length mdl idx++ factor graph mdl tree mdl idx tree p maxprod tree p max t r p trp t r p max terminator t r p iteration terminator 1 maxprod compute marginal mdl trp compute marginal mdl t r p same result viterbi iterator mdl variable iterator next variable var variable next factor max pot bp maxprod lookup marginal var factor max pot trp trp lookup marginal var max pot bp normalize max pot trp normalize t r p 1 it maxprod propagation same plain max prod + trp + max pot trp dump + plain maxprod + max pot bp dump max pot bp almost equal max pot trp test trp tree mdl idx 0 mdl idx tree length mdl idx++ factor graph mdl tree mdl idx inferenc bp tree p inferenc trp t r p terminator t r p iteration terminator 1 bp compute marginal mdl trp compute marginal mdl outcome mdl num variable assignment assn assignment mdl outcome equal bp lookup log joint assn trp lookup log joint assn 1e 5 fill outcome 1 assn assignment mdl outcome equal bp lookup log joint assn trp lookup log joint assn 1e 5 t r p same result viterbi iterator mdl variable iterator next variable var variable next factor max pot bp bp lookup marginal var factor max pot trp trp lookup marginal var max pot bp normalize max pot trp normalize t r p 1 it bp propagation same plain max prod + trp + max pot trp dump + plain bp + max pot bp dump max pot bp almost equal max pot trp test t r p max propagation same result t r p allow run convergence test trp viterbi equiv2 mdl idx 0 mdl idx tree length mdl idx++ factor graph mdl tree mdl idx inferenc maxprod tree p max t r p trp t r p max maxprod compute marginal mdl trp compute marginal mdl t r p same result viterbi iterator mdl variable iterator next variable var variable next factor max pot bp maxprod lookup marginal var factor max pot trp trp lookup marginal var t r p maxprod propagation same plain max prod + trp + max pot trp + plain maxprod + max pot bp max pot bp almost equal max pot trp test tree viterbi mdl idx 0 mdl idx tree length mdl idx++ factor graph mdl tree mdl idx brute force inferenc brute brute force inferenc inferenc maxprod tree p max factor joint brute joint mdl maxprod compute marginal mdl iterator mdl variable iterator next variable var variable next factor max pot maxprod lookup marginal var factor max pot joint extract max var max pot normalize max pot normalize maximization fail normalize + max pot + + max pot max pot almost equal max pot logger info test tree viterbi pass + tree length + model test jt viterbi junction tree inferenc jti junction tree inferenc mdl idx 0 mdl idx model length mdl idx++ undirect model mdl model mdl idx brute force inferenc brute brute force inferenc junction tree inferenc maxprod junction tree inferenc max junction tree jt maxprod build junction tree mdl factor joint brute joint mdl maxprod compute marginal jt iterator mdl variable iterator next variable var variable next factor max pot raw maxprod lookup marginal var factor max pot raw joint extract max var factor max pot max pot raw duplicate normalize factor max pot max pot raw duplicate normalize maximization fail model + mdl idx + normalize + max pot dump + + max pot dump max pot almost equal max pot 0 01 logger info test jt viterbi pass test m m test query test tree viterbi test trp viterbi equiv test trp viterbi equiv2 test max marginal xxx because t r p termination e succeed termination iteration termination 10 usually termination convergence terminator 1e 12 1000 someth about selection random span trees??? test max marginal mdl idx 0 mdl idx model length mdl idx++ mdl idx 4 factor graph mdl model mdl idx mdl idx 3 visualizer show model mdl mdl dump e n m l +mdl idx+ brute force inferenc brute brute force inferenc factor joint brute joint mdl foo current milli foo inferenc alg construct max inferencer inf idx 0 inf idx alg length inf idx++ inferenc inf alg inf idx inf t r p t r p inf random seed 42 inf compute marginal mdl iterator mdl variable iterator next variable var variable next factor max pot inf lookup marginal var factor max pot joint extract max var max pot argmax max pot argmax logger warning argmax equal model + mdl idx + inferenc + inf + factor + max pot + + max pot err dump model + mdl idx + mdl dump max pot argmax max pot argmax logger info test max marginal pass test belief propagation mdl idx 0 mdl idx tree length mdl idx++ factor graph mdl tree mdl idx inferenc prop tree p mdl prop compute marginal mdl iterator mdl variable iterator next variable var variable next factor marg1 tree marg mdl idx mdl get index var factor marg2 prop lookup marginal var test fail graph + mdl idx + vertex + var + + model + mdl + expect + marg1 dump + + marg2 dump marg1 almost equal marg2 0 011 assertion fail e e get message m o e l mdl dump m e g e belief propagation prop dump e logger info test belief propagation pass test bp joint mdl idx 0 mdl idx tree length mdl idx++ factor graph mdl tree mdl idx inferenc bp tree p brute force inferenc brute brute force inferenc brute compute marginal mdl bp compute marginal mdl assignment iterator mdl assignment iterator next assignment assn assignment next equal brute lookup joint assn bp lookup joint assn 1e 15 eventially fold into test marginal test joint etc test direct jt direct model bn direct model brute force inferenc brute brute force inferenc brute compute marginal bn junction tree inferenc jt junction tree inferenc jt compute marginal bn compare marginal comparing junction tree brute direct model bn brute jt direct model direct model n u m o u t o m e 2 random random random 13413 dirichlet dirichlet dirichlet n u m o u t o m e 1 0 p dirichlet random vector random p dirichlet random vector random t p t n u m o u t o m e n u m o u t o m e n u m o u t o m e 0 n u m o u t o m e n u m o u t o m e i++ p add dirichlet random vector random variable var variable variable n u m o u t o m e variable n u m o u t o m e variable n u m o u t o m e direct model mdl direct model mdl add factor p t table factor var 0 p var 0 mdl add factor p t table factor var 1 p var 1 mdl add factor p t table factor var p var 2 mdl compare marginal msg factor graph fg inferenc inf1 inferenc inf2 0 fg num variable i++ variable var fg get factor ptl1 inf1 lookup marginal var factor ptl2 inf2 lookup marginal var msg + + ptl1 dump + + ptl2 dump ptl1 almost equal ptl2 1e 5 up model test model test tree model undirect model model undirect model compute test tree marg test multiply table factor p1 table factor variable p1 variable var variable variable 2 variable 2 prob 1 3 5 6 table factor p2 table factor var prob factor p3 p1 multiply p2 equal + p2 + + p3 p2 almost equal p3 t o o sure test anymore test multiplication potential variable different test multiplication2 variable var variable variable 2 variable 2 probs1 2 4 1 6 probs2a 3 7 6 5 probs2b 3 6 7 5 multinomial ptl1a multinomial var probs1 multinomial ptl1b multinomial var probs1 multinomial ptl2a multinomial var probs2a variable vars2 variable var 1 var 0 multinomial ptl2b multinomial vars2 probs2b ptl1a multiply ptl2a ptl1b multiply ptl2b ptl1a almost equal ptl1b test log marginalize factor graph mdl model 0 iterator mdl variable iterator variable v1 variable next variable v2 variable next random rand random 3214123 0 10 i++ factor ptl random edge rand v1 v2 factor logmarg1 log table factor table factor ptl marginalize v1 factor marglog1 log table factor table factor ptl marginalize v1 log marg fail correct +marglog1+ log marg +logmarg1 logmarg1 almost equal marglog1 factor logmarg2 log table factor table factor ptl marginalize v2 factor marglog2 log table factor table factor ptl marginalize v2 logmarg2 almost equal marglog2 test log normalize factor graph mdl model 0 iterator mdl variable iterator variable v1 variable next variable v2 variable next random rand random 3214123 0 10 i++ factor ptl random edge rand v1 v2 factor norm1 log table factor table factor ptl factor norm2 ptl duplicate norm1 normalize norm2 normalize log normalize fail correct +norm2+ log norm +norm1 norm1 almost equal norm2 test sum log prob random rand random 3214123 0 10 i++ v1 rand next v2 rand next sum1 math log v1 + v2 sum2 math sum log prob math log v1 math log v2 sum +v1+ + +v2 equal sum1 sum2 0 00001 test infinite cost variable var variable 3 0 var length i++ var variable 2 factor graph mdl factor graph var mdl add factor var 0 var 1 2 6 4 8 mdl add factor var 1 var 2 1 0 0 1 mdl dump inferenc bp tree p bp compute marginal mdl below potential different range bp lookup marginal var 1 almost equal bp lookup marginal var 2 test jt cache clear cache 0 model length i++ factor graph model model model inference cache junction tree inferenc factor marg factor model length stime1 get 0 model length i++ factor graph model model junction tree inferenc inf junction tree inferenc inf compute marginal model marg factor model num variable iterator model variable iterator j 1 next variable var variable next j++ marg j inf lookup marginal var etime1 get diff1 etime1 stime1 logger info pre cache take +diff1+ m stime2 get 0 model length i++ factor graph model model junction tree inferenc inf junction tree inferenc inf compute marginal model iterator model variable iterator j 1 next variable var variable next j++ marg j almost equal inf lookup marginal var etime2 get diff2 etime2 stime2 logger info post cache take +diff2+ m diff2 diff1 test find variable factor graph mdl model 0 variable var variable mdl num variable iterator mdl variable iterator next variable var variable next name var get label var mdl find variable name mdl find variable xsdfasdf test lookup marginal inferenc inf tree p factor graph mdl tree j t h n t e t t r e e variable var mdl get 0 inf compute marginal mdl previously unsupport operation exptect lookup marginal variable clique size 1 var var hash var variable var factor ptl1 inf lookup marginal var factor ptl2 inf lookup marginal var ptl1 almost equal ptl2 variable var2 mdl get 1 variable var3 mdl get 2 var c2 hash var variable var var2 var3 inf lookup marginal c2 fail expect unsupport operation clique +c2 unsupport operation e eventually move model t r p currently choke disconnect model test disconnect model variable var variable 4 0 var length i++ var variable 2 factor graph mdl undirect model var random r random 67 factor ptl factor 4 factor norm factor 4 0 var length i++ ptl random node r var norm ptl duplicate norm normalize mdl add factor ptl mdl dump inferenc inf loopy p inf compute marginal mdl 0 var length i++ factor marg inf lookup marginal var marginal equal +norm + +marg marg almost equal norm assignment iterator mdl assignment iterator next assignment assn assignment next prob 1 0 0 var length i++ prob norm value assn equal prob inf lookup joint assn 1e 5 marginalization random r random 7732847 variable var variable variable 2 variable 2 table factor ptl random edge r var 0 var 1 stime current milli 0 1000 i++ factor marg ptl marginalize var 0 factor marg2 ptl marginalize var 1 etime current milli logger info marginalization 2 outcome take + etime stime + m variable vars45 variable variable 45 variable 45 table factor ptl45 random edge r vars45 0 vars45 1 stime current milli 0 1000 i++ factor marg ptl45 marginalize vars45 0 factor marg2 ptl45 marginalize vars45 1 etime current milli logger info marginalization 45 outcome take + etime stime + m profiling run junction tree mdl idx 0 mdl idx model length mdl idx++ factor graph model model mdl idx junction tree inferenc inf junction tree inferenc inf compute marginal model iterator model variable iterator next variable var variable next inf lookup marginal var test destructive assignment variable var variable 2 variable 2 assignment assn assignment var 0 1 equal 0 assn get var 0 equal 1 assn get var 1 assn value var 0 1 equal 1 assn get var 0 equal 1 assn get var 1 test loopy convergence random r random 67 factor graph mdl random grid 5 5 2 r loopy p loopy loopy p loopy compute marginal mdl loopy iteration 8 test singleton graph variable v variable 2 factor graph mdl factor graph variable v mdl add factor table factor v 1 2 t r p trp t r p trp compute marginal mdl factor ptl trp lookup marginal v dbl table factor ptl value equal 2 dbl length equal 0 33333 dbl 0 1e 4 equal 0 66666 dbl 1 1e 4 test loopy cache factor graph mdl1 model 4 factor graph mdl2 model 5 variable var mdl1 get 0 loopy p inferenc loopy p inferenc cache inferenc compute marginal mdl1 factor orig ptl inferenc lookup marginal var 2 inferenc iteration confuse inferenc inferenc compute marginal mdl2 sure we cache correct result inferenc compute marginal mdl1 factor snd ptl inferenc lookup marginal var note we can t epsilon here les our convergence criterion huh? original +orig ptl+ +snd ptl orig ptl almost equal snd ptl 1e 4 equal 1 inferenc iteration test junction tree connect root junction tree inferenc jti junction tree inferenc jti compute marginal model 0 jti compute marginal model 1 junction tree jt jti lookup junction tree reach link queue link queue add jt get root queue empty var current var queue first queue add jt get child current reach add current equal jt cluster potential size reach size test bp large model timing timing timing undirect model mdl random graph uniform chain 800 factor graph mdl random graph uniform chain 8196 timing tick model creation belief propagation inf loopy p inf compute marginal mdl memory e o u t o f m e m o r y message sent +inf get total message sent e timing tick inference random sch p test trp large model timing timing timing undirect model mdl random graph uniform chain 800 factor graph mdl random graph uniform chain 8192 timing tick model creation inferenc inf t r p inf compute marginal mdl timing tick inference t r p test bp dual edge factor variable var variable variable 2 variable 2 variable 2 variable 2 random r random factor tbl1 edge ptl var 0 var 1 r factor tbl2a edge ptl var 1 var 2 r factor tbl2b edge ptl var 1 var 2 r factor tbl3 edge ptl var 2 var 3 r factor graph fg factor graph var fg add factor tbl1 fg add factor tbl2a fg add factor tbl2b fg add factor tbl3 inferenc inf t r p inf compute marginal fg var v tbl2a var factor marg1 inf lookup marginal v factor prod table factor multiply fg factor factor marg2 prod marginalize v marg2 normalize factor equal p +marg1 dump + e t +marg2 dump marg1 almost equal marg2 factor edge ptl variable var1 variable var2 random r dbl 4 0 dbl length i++ dbl r next table factor variable var1 var2 dbl grid str v r alpha u o n t n u o u + alpha uniform 1 0 1 0 + u uniform 2 0 2 0 + x00 unary u + x10 unary u + x01 unary u + x11 unary u + x00 x01 pott alpha + x00 x10 pott alpha + x01 x11 pott alpha + x10 x11 pott alpha test jt constant o factor graph master fg model reader read model buffer reader reader grid str junction tree inferenc jt junction tree inferenc assignment assn master fg sample continuou var random 3214 factor graph fg factor graph master fg slice assn jt compute marginal fg test suite test suite test inference test suite suite length 0 suite test suite 0 length i++ suite add test test inference suite test suite suite junit textui test runner run suite 