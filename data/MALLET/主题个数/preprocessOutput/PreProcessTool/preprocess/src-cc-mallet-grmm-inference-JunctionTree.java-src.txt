2003 univ dept part m l l e t m achine learning languag e toolkit 1 0 information see ` l e n e inference hash iterator collection type gnu trove t hash map gnu trove t hash gnu trove t iterator datastructure junction tree create tue sep 30 10 30 25 2003 charles sutton $ junction tree v 1 1 2007 10 22 21 37 49 $ junction tree tree num node sepset sepset factor p ptl p factor ptl t hash map sepset factor cpf junction tree size num node size sepset t hash map cpf factor size junction tree constructor add node parent1 child1 add node parent1 child1 var parent var parent1 var child var child1 sepset parent intersection child id1 lookup index parent id2 lookup index child put sepset id1 id2 sepset sepset sepset ptl sepset factor sepset ptl sepset sepset empty identity factor constant factor identity factor table factor sepset hash idx idx id1 id2 id1 65536 id2 65536 id1 id2 id1 16 | id2 id2 16 | id1 put sepset id1 id2 sepset sepset hash idx idx id1 id2 sepset put sepset sepset get sepset id1 id2 hash idx idx id1 id2 sepset sepset get p f accessor factor get p f var cpf lookup index p f var factor pot cpf lookup index pot clear p f 0 cpf length i++ cpf table factor var lookup vertex t iterator sepset iterator next advance sepset sepset sepset value sepset ptl sepset ptl sepset sepset potential t hash t hash t iterator sepset iterator next advance factor ptl sepset value ptl add ptl sepset pot factor pot var v1 var v2 id1 lookup index v1 id2 lookup index v2 get sepset id1 id2 ptl pot factor get sepset pot var v1 var v2 id1 lookup index v1 id2 lookup index v2 get sepset id1 id2 ptl collection potential clique junction tree e these numerator jounction tre theorem see sepset potential collection cluster potential hash h hash 0 cpf length i++ cpf h add cpf h get sepset var v1 var v2 id1 lookup index v1 id2 lookup index v2 get sepset id1 id2 factor lookup marginal variable var var find parent cluster var factor pot get p f pot marginalize var lookup log joint assignment assn accum 0 0 cpf length i++ cpf phi cpf log value assn accum + phi t iterator sepset iterator next advance factor ptl sepset value ptl phi ptl log value assn accum phi accum cluster tree contain var var find parent cluster variable var best m v l u e var retval xxx inefficient iterator get vertex iterator next var var next contain var weight best retval best weight retval cluster tree contain var collection var find parent cluster collection var best m v l u e var retval xxx inefficient iterator get vertex iterator next var var next contain var weight best retval best weight retval cluster tree contain exactly variable cluster var find cluster variable var l var iterator get vertex iterator next var c2 var next c2 contain l l contain c2 c2 normaliz potential tree both node sepset normalize n cpf length 0 n i++ cpf cpf normalize t iterator sepset iterator next advance factor ptl sepset value ptl ptl normalize get var lookup index debug function dump n cpf length j graph print our node edge dump now let print cpf vertex p f 0 n i++ cpf p f +i+ +cpf dump sepset potential sepset p f t iterator sepset iterator next advance factor ptl sepset value ptl ptl dump j t dump log joint assignment assn accum 0 0 cpf length i++ cpf phi cpf log value assn p f +i+ accum +accum t iterator sepset iterator next advance factor ptl sepset value ptl phi ptl log value assn sepset +ptl var + accum +accum accum na n n cpf length 0 n i++ cpf na n sepset potential t iterator sepset iterator next advance factor ptl sepset value ptl ptl na n entropy entropy 0 iterator cluster potential iterator next factor ptl factor next entropy + ptl entropy iterator sepset potential iterator next factor ptl factor next entropy ptl entropy entropy graphical compactible decompact cpf factor num node clear p f compact cpf junction tree 