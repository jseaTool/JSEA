2003 univ dept part m l l e t m achine learning languag e toolkit 1 0 information see ` l e n e learning gnu trove t io io writer io print writer iterator random logging logger learning r f learning r f evaluator learning r f maximizable r f label assignment optimize conjugate gradient optimize memory f g optimize optimizable optimize optimiz type logger timing training r f p p create thu oct 16 17 53 14 2003 charles sutton $ acrf trainer v 1 1 2007 10 22 21 37 43 $ acrf trainer r f trainer logger logger logger get logger acrf trainer get name optimiz max rethrow acrf trainer r f trainer constructor output prefix output prefix f output prefix f optimiz get max max max optimiz max max max rethrow rethrow rethrow rethrow acrf trainer rethrow rethrow train r f acrf instance training train acrf training log evaluator 1 train r f acrf instance training num it train acrf training log evaluator num it train r f acrf instance training r f evaluator eval num it train acrf training eval num it train r f acrf instance training instance validation instance testing num it train acrf training validation testing log evaluator num it train r f acrf instance training instance validation instance test r f evaluator eval num it optimizable gradient value macrf optimizable acrf training train acrf training validation test eval num it macrf optimizable gradient value optimizable r f acrf instance training acrf get maximizable training thread train r f acrf instance training instance validation instance test r f evaluator eval num it maximizable gradient macrf acrf get thread maximizable training train dcrf training validation test eval num it mdcrf incremental train r f acrf instance training instance validation instance testing num it incremental train acrf training validation testing log evaluator num it z e 0 1 0 5 u e t t e r 10 incremental train r f acrf instance training instance validation instance testing r f evaluator eval num it stime get 0 z e length i++ instance subset training split z e 1 z e 0 logger info training subset size + subset size optimizable gradient value subset macrf optimizable acrf subset train acrf training validation eval u e t t e r subset macrf logger info subset training + + finish etime get logger info subset training finish + etime stime + m train acrf training validation testing eval num it train r f acrf instance training instance validation instance test r f evaluator eval num it optimizable gradient value macrf optimiz maximiz max macrf maximiz gradient maximiz bold driver maximiz gradient maximiz gradient descent converge reset stime current milli num node macrf r f maximizable r f ? r f maximizable r f macrf get total node 0 thresh 1e 5 num node early stopping conservative test logger warning r f trainer test prev value n e g t v e n f n t y current value it it 0 it num it iter++ etime get logger info r f trainer iteration + it + + etime stime converge maximiz optimize 1 converge | call evaluator acrf training validation test it eval converge reset runtime e e print stack trace we get maximize reset l f g memory again we get second too just give up reset logger warning iteration + it + + e + reset l f g again maximiz memory f g memory f g maximiz reset maximiz conjugate gradient conjugate gradient maximiz reset reset logger warning iteration + it + + e + quit saying converge converge rethrow e converge early stopping current value macrf get value math ab current value prev value thresh ignore cutoff we re about reset l f g reset logger info r f trainer saying converge + current value + current value + previou + prev value + threshold + thresh + 1e 5 + num node converge prev value current value it num it logger info r f trainer too many iteration stopping training max it +num it etime current milli logger info r f training m + etime stime macrf maximizable r f maximizable r f macrf report test eval t cache test old cache acrf cache unroll graph acrf cache unroll graph eval test acrf test testing acrf cache unroll graph old cache converge optimiz max optimizable gradient value macrf max memory f g macrf max stop keep going opposite evaluator ugh call evaluator r f acrf instance training instance validation instance test it r f evaluator eval eval evaluator specify keep going blindly eval output prefix output prefix t cache test cache acrf cache unroll graph acrf cache unroll graph timing timing timing eval evaluate acrf iter+1 training validation test logger info r f trainer evaluator quit timing tick evaluation iteration +iter+ timing tick evaluation iteration +iter+ test cache back normal acrf cache unroll graph cache some unsupport train r f acrf instance training instance validation instance test r f evaluator eval num it optimizable gradient value macrf optimizable acrf training train acrf training validation test eval 5 macrf r f template tmpl acrf get template ti 0 ti tmpl length ti++ tmpl ti add some unsupport weight training logger info some unsupporetd weight initialize training train acrf training validation test eval num it macrf test r f acrf instance testing r f evaluator eval test acrf testing r f evaluator eval test r f acrf instance testing r f evaluator eval pr acrf get best label testing 0 eval length i++ eval output prefix output prefix eval test testing pr testing random r random 1729 random get random r train r f acrf instance training instance validation instance testing r f evaluator eval proportion it proportion 0 proportion length i++ proportion proportion instance list training split r proportion 1 0 logger info r f trainer round + + training proportion + proportion train acrf list 0 validation testing eval it proportion logger info r f trainer training full train acrf training validation testing eval 99999 log evaluator r f evaluator test result last result log evaluator evaluate r f acrf it instance training instance validation instance testing evaluate it training test acrf training training testing test acrf testing testing test instance test description logger info description+ instance + test size test result result compute test result test result log description last result result result print confusion test result compute test result instance test test result result test result test iterator it1 test iterator iterator it2 iterator it1 next instance inst instance it1 next instance label assignment lblseq label assignment inst get target label target lblseq get label label label it2 next target compare labeling result target result compute statistic result compare labeling test result result label label target size target size 0 size i++ +i label lbl get label label lbl target target get label result increment count lbl lbl target get joint accuracy last result get joint accuracy evaluator r f evaluator evaluator evaluate r f acrf it instance training instance validation instance testing evaluate it test acrf testing testing test instance test description logger info testing instance + test size test result result log evaluator compute test result test print writer writer print writer writer result print description writer writer close e e print stack trace result print confusion test result confusion confusion matrix num marginal confusion matrix count count precision recall f1 precision recall f1 measuring accuracy factor t factor measuring joint accuracy max t 0 correct t 0 alphabet alphabet test result instance ilist ilist get 0 test result instance inst alphabet alphabet setup alphabet inst num alphabet size confusion num num precision num recall num f1 num isn t pretty swear there easy setup alphabet instance inst label assignment lblseq label assignment inst get target factor t lblseq num slice 0 lblseq num slice i++ label alphabet dict lblseq get output alphabet factor t dict size j 0 j dict size j++ idx alphabet lookup index dict lookup j factor add idx increment count label lbl label lbl target same label accuracy j 0 j lbl size j++ label lret lbl get j label ltarget lbl target get j ltarget+ v +lret idx alphabet lookup index ltarget get entry idx ret alphabet lookup index lret get entry idx idx ret same confusion idx idx ret ++ measure joint accuracy max t++ same correct t++ compute statistic compute marginal confusion matrix confusion j label label j count num count num 0 num i++ j 0 j num j++ count + confusion j count j + confusion j compute precision recall f1 0 num i++ correct confusion count 0 precision correct 0 ? 1 0 0 0 precision correct count count 0 recall 1 0 recall correct count f1 2 precision recall precision + recall log log log desc logger info desc+ label n correct p r f1 0 num i++ logger info desc+ +i + + alphabet lookup + + count + + confusion + + count + + precision + + recall + + f1 + fnum 0 fnum factor length fnum++ correct 0 0 0 factor fnum size i++ lbl factor fnum get correct + confusion lbl lbl + count lbl logger info desc + factor + fnum + accuracy + correct + + + + correct logger info desc + correct t + correct t + maxt + max t logger info desc + joint accuracy + correct t max t print desc print writer label n correct p r f1 0 num i++ + + alphabet lookup + + count + + confusion + + count + + precision + + recall + + f1 + fnum 0 fnum factor length fnum++ correct 0 0 0 factor fnum size i++ lbl factor fnum get correct + confusion lbl lbl + count lbl desc + factor + fnum + accuracy + correct + + + + correct desc + correct t + correct t + maxt + max t desc + joint accuracy + correct t max t print confusion count 0 num i++ j 0 j num j++ + + j + + confusion j get joint accuracy correct t max t test result r f trainer 