2003 univ dept part m l l e t m achine learning languag e toolkit 1 0 information see ` l e n e type gnu trove t hash map io o io input stream io output stream util type math random multivariate multinomial p create mon sep 15 17 19 24 2003 charles sutton $ table factor v 1 1 2007 10 22 21 37 44 $ table factor discrete factor map variable say dimension prob matrix correspand var universe universe universe e f u l t var var variable num var reordering map size pass size sort matrix prob table factor bidirectional map var map init var var map identity init var bidirectional map var init var var init var variable var pass size pass var pass length size sort var pass length reordering map var pass length variable var var pass clone var hash var var var universe var sort var store mapping between variable be canonically sort we store them size 0 var length i++ variable var var get var continuou illegal argument attempt table over continou variable +all var size sort var get num outcome j 0 var pass j var j++ reordering map j size pass j var get get num outcome prob matrixn size sort prob num location 0 err warning empty create num var var length init var collection var init var variable var variable var size prob prob prob length prob num location shouldn t runtime sue me runtime attempt initialize bad probability + + prob num location + get + prob length 0 prob length i++ index pass size pass length matrixn single index index pass size pass index sort size pass length j 0 j size pass length j++ index sort j index pass reordering map j single index sort matrixn single index size sort index sort prob value location single index sort prob create identity over variable table factor variable var init var variable var identity table factor variable var value init var variable var prob value create identity over n o variable table factor init var variable identity create identity variable table factor variable var init var var identity create identity variable var collection contain variable table factor collection var init var var identity create variable probability var variable prob phi value row major table factor variable var prob init var var prob prob create variable probability var variable prob phi value row major table factor bidirectional map var prob init var var prob prob create variable probability var variable prob phi value row major table factor var var prob init var var variable prob prob create variable probability var variable prob phi value table factor variable var matrix prob init var var prob matrix prob clone matrix create variable probability var variable prob phi value table factor bidirectional map var matrix prob init var var prob matrix prob clone matrix constructor table factor table factor xxx could dangerou these nev var var num var num var projection cache initialize projection cache projection cache projection cache create variable probability var variable prob phi value table factor var var matrix prob init var var variable prob matrix prob clone matrix create same variable another different probabilite ptl prob table factor table factor ptl prob ptl var prob t t f t o r y m e t h o factor identity factor table factor table factor var val 0 prob num location i++ prob single value val t r t m e t h o force identity 1 identity factor duplicate factor normalize sum table factor blank subset variable var table factor blank subset collection var blank subset variable var variable var size get num var num var inherently dangerou variable ordering issue consider phi assignment instead value matrix prob prob single size prob single size unsupport operation reset prob matrix wrong probability previou num prob + prob single size + num prob +prob single size prob get num dimension prob get num dimension unsupport operation reset prob matrix wrong dimension prob prob iff over variable contain var variable var var contain var variable var var unmodifiable var var assignment iterator assignment iterator prob sparse matrixn idx sparse matrixn prob get index idx sparse assignment iterator var idx dense assignment iterator var raw value assignment assn value index num var 0 num var i++ variable var get variable index assn get var prob value index value raw value assignment iterator value prob single value index current assn value raw value loc value prob single value loc value value assignment assn function normalization log space compute sum log space logsum math log prob norm entropy h 0 p assignment iterator assignment iterator next p log value infinite p h p math p advance h p r o j e t o n o f n e map potential careful about thing get shallow copy whenev duplicate be e g expand contain being share thing could get ugly think everyth moment keep mind inexplicable bug show up future ca t hash map projection cache lazily construct initialize projection cache projection cache universe lookup projection cache var hash value subset variable note hash value depend membership hash scheme unsafe projection cache unles variable be canonical they compute subset hash value discrete factor subset potential 32 variable we need expandable bitset again you probably wouldn t enough memory represent anyway get num var 32 0 num var subset var size lrgi 0 relie variable being sort smi 0 smi num var smi++ var subset get variable smi loop subset fact subset anyway var get variable lrgi lrgi++ | 1 lrgi below casing small num var 1 projection prob single size large dim num var variable small var variable small var map lookup 0 large dim var map lookup index small var large dim 1 small var large idx 0 large idx prob single size large idx++ prob single index large idx large dim projection large idx large dim large dim projection didn t seem huge gain compute large idx small discrete factor small large idx small large idx multinomial small projection prob num location large dim num var small num var small var size small dim small num var large loc 0 large loc prob num location large loc++ large idx prob index location large loc prob single index large idx large dim relie variable being sort large dim 0 small dim 0 small dim small num var small dim++ variable small var small get variable small dim small var get variable large dim large dim++ small dim small dim large dim large dim projection large loc small single index small dim projection large idx small discrete factor small cachedlarge idx small large idx multinomial small projection cache initialize projection cache small ptl variable here since ordering problem we can hash key cache large idx small small small var size 1 cache large idx small small compute large idx small small cache compute large idx small ptl single variable design work small multiple variable call two potential same variable different order t o o work multiple variable canonical ordering? cache large idx small discrete factor small hashval compute subset hash value small projection cache get hashval projection compute large idx small small projection cache put hashval projection projection marginal over variable factor marginalize variable var var contain var perhap instead marginalize internal blank subset var factor marginalize collection var var contain var perhap instead marginalize internal blank subset var factor marginalize variable var var contain var perhap instead marginalize internal blank subset variable var factor marginalize variable var var hash var var var var marginalize internal blank subset var factor marginalize var bad var var hash var var var bad var marginalize internal blank subset var factor marginalize internal table factor factor extract max variable var extract max internal blank subset variable var factor extract max variable var extract max internal blank subset var factor extract max collection var extract max internal blank subset var factor extract max internal table factor n e g t v e n f n t y projection large idx small add element single large correct element small large loc 0 large loc prob num location large loc++ convert single index small small idx projection large loc whew now add large value prob value location large loc small value prob single value small idx large value small value prob value location small idx large value expand contain discrete factor pot expand pretty need expand var pot var var var hash var var var add pot var table factor ptl blank subset var ptl multiply internal var ptl var prob ptl prob num var ptl num var initialize projection cache need expand var mine var his size h his size vi m 0 vi h 0 variable var h var m vi m num var vi h size h var m mine get vi m var h his get vi h vi m++ var m var h vi h++ vi h size h conceptual equivalent pot pot variable subset multiply factor pot pot discrete factor discrete factor factor discrete factor pot expand contain factor factor ensure operand compatible factor multiply internal factor pot constant factor time equal pot value assignment table factor tbl tbl pot table unsupport operation e unsupport operation t know multiply +this+ +pot multiply tbl ensure tt log space ptl log space tt ptl logifi delogifi appropriate ptl equivalent ptl possibly logifi delogifi ptl could discrete factor ensure operand compatible discrete factor ptl ptl destructive multiplication assume variable pot multiply internal discrete factor ptl plus equal internal discrete factor ptl elementwise another factor multiply factor dist factor duplicate multiply dist conceptual equivalent pot pot variable subset divide factor pot pot discrete factor discrete factor pot1 discrete factor pot cheating expand contain pot1 pot1 ensure operand compatible pot1 divide internal pot1 pot constant factor time equal 1 0 pot value assignment table factor tbl tbl pot table unsupport operation e unsupport operation t know multiply +this+ +pot multiply tbl destructive divison assume variable pot divide internal discrete factor ptl xxx assignment argmax best idx 0 best val prob single value 0 idx 1 idx prob num location idx++ val prob single value idx val best val best val val best idx idx best idx e p 1e 5 assignment sample random r loc sample location r location2assignment loc assignment location2assignment loc dense assignment iterator var loc assignment sample location random r sum sum sample r next uniform sum cum 0 idx 0 idx prob num location idx++ val value idx cum + val sample cum + e p idx runtime internal couldn t sample +this+ +dump + value +sampl almost equal factor p almost equal p math e p l o n almost equal factor p epsilon p table factor discrete factor p2 discrete factor p var contain p2 var p2 var contain var t o o fold into prob almost eqaual variable ordering issue ev resolve also consider converge function projection large idx small p2 loc1 0 loc1 prob num location loc1++ idx2 projection loc1 v1 value location loc1 v2 p2 value idx2 math ab v1 v2 epsilon clone duplicate buffer buffer 1024 append append util name append append var append dump buffer buffer 1024 append append index num var loc 0 loc prob num location loc++ idx prob index location loc prob single index idx index j 0 j num var j++ append index j append val prob single value idx append val append append sum append sum append na n prob na n print value print 0 prob num location i++ print prob value location print print print size size num var prob get dimension size print 0 num var i++ print size + print variable find variable name 0 get num var i++ variable var get variable var get label equal name var num location prob num location index location loc prob index location loc variable get variable var get serialization serial u 1 seralization incompatible these smart can these backward compatibility write output stream o write read input stream o found read rerun initializer field projection cache t hash map divide v prob divide equal v discourage log value assignment assn log value discourage log value assignment iterator assn log value discourage value assignment iterator assn log value factor hacky mixture table factor ptl1 table factor ptl2 weight check alphabet match ptl1 get num var ptl2 get num var illegal argument 0 ptl2 get num var i++ ptl1 get variable ptl2 get variable illegal argument ptl1 ensure operand compatible ptl2 ptl2 illegal argument table factor table factor ptl1 var loc1 0 loc1 ptl1 num location loc1++ val1 ptl1 value location loc1 idx ptl1 index location loc1 val2 ptl2 value idx raw value idx weight val1 + 1 weight val2 t hash index t hash loc 0 loc ptl1 prob num location loc++ index add ptl1 prob index location loc loc 0 loc ptl2 prob num location loc++ index add ptl2 prob index location loc idx index sort idx val idx length ptl1 log table factor hack 0 idx length i++ val weight math ptl1 prob single value idx + 1 weight math ptl2 prob single value idx val math log val 0 idx length i++ val weight ptl1 prob single value idx + 1 weight ptl2 prob single value idx sz ptl1 prob get num dimension ptl1 prob get dimension sz sparse matrixn m sparse matrixn sz idx val table factor ptl1 blank subset ptl1 var map value m ptl1 na n ptl2 na n na n err oop na n average p1 +ptl1 na n + p2 +ptl2 na n + +result na n raw value single idx value matrix matrix get value matrix arr matrix num location 0 arr length i++ arr matrix value location arr single index small dim prob single index small dim matrix get value matrix matrix get log value matrix log value val value val log value matrix matrix get log value matrix matrix matrixn matrixn matrix matrix sparse matrixn sparse matrixn matrix runtime get value matrixn get value matrix add constant value table most useful add small constant zero plus equal v loc 0 loc num location loc++ plus equal location loc v plus equal factor f f discrete factor discrete factor factor discrete factor f expand contain factor factor ensure operand compatible factor plus equal internal factor f constant factor plus equal f value assignment table factor tbl tbl f table unsupport operation e unsupport operation t know add +this+ +f plus equal tbl multiplie constant value table time equal v plus equal location loc v multiplie factor constant 1 max ensure maximum value factor 1 0 table factor recent table factor table create equal restrict assignment assn variable hold fix factor over v r factor \ v r assn factor slice assignment assn intersection var intersection assn var intersection empty hash var clique hash var var clique assn get var slice internal clique variable assn factor slice internal variable var assignment observe speed var length 1 slice onevar var 0 observe var length 2 slice twovar var 0 var 1 observe slice var observe factor slice onevar variable var assignment observe factor slice twovar variable v1 variable v2 assignment observe factor slice variable var assignment observe pretty output buffer buf buffer iterator var iterator next variable var variable next buf append var get label buf append buf append table factor buf 