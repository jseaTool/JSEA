2003 univ dept part m l l e t m achine learning languag e toolkit 1 0 information see ` l e n e learning type optimize optimizable type instance type instance type sparse vector logger cache optimizable gnu trove t hash map io output stream io o io print stream io serializable bit iterator logging logger create mar 15 2005 h r e f $ pseudolikelihood r f trainer v 1 1 2007 10 22 21 37 40 $ pseudolikelihood r f trainer acrf trainer logger logger logger get logger pseudolikelihood r f trainer get name print gradient variable pseudolikelihood classical besag y v r l e 0 edge structure pseudolikelihood y e g e 1 structure type y v r l e get structure type structure type structure type structure type structure type structure type optimizable gradient value optimizable r f acrf instance training maxable acrf training control structurednes pl clique iterator next advance factor local conditional r f unroll var clique variable iterator clique iterator r f unroll graph graph assignment observe cursor vidx 1 factor ptl clique var variable iterator r f unroll graph acrf assignment observe graph acrf observe observe clique var graph num variable 0 clique var length i++ clique var iterator acrf unroll var iterator next r f unroll var clique r f unroll var next vidx 0 vidx clique size vidx++ variable var clique get vidx clique var graph get index var add clique next vidx graph num variable 1 advance vidx++ variable var graph get vidx ptl table factor var iterator clique var vidx iterator next r f unroll var clique r f unroll var next factor clique ptl graph factor clique clique ptl illegal could find clique +clique var v hash var clique ptl var v var assignment nbr assn assignment observe marginalize v factor slice clique ptl slice nbr assn ptl multiply slice factor local conditional ptl r f unroll var clique clique clique var vidx r f unroll var clique r f unroll var clique size edge iterator clique iterator r f unroll graph graph assignment observe cursor iterator cursor current clique factor ptl t hash map clique edge edge iterator r f unroll graph acrf assignment observe graph acrf observe observe clique edge t hash map iterator acrf unroll var iterator next r f unroll var clique r f unroll var next v1idx 0 v1idx clique size v1idx++ variable v1 clique get v1idx adjlist graph factor contain v1 iterator factor adjlist iterator factor next factor factor factor factor next clique edge contain key factor clique edge put factor l clique edge get factor l contain clique l add clique cursor clique edge key iterator next cursor next advance factor pair factor factor cursor next var pair var pair factor var pair var size 2 now variable v1 pair var get 0 variable v2 pair var get 1 variable var variable v1 v2 ptl table factor var local ob assignment e e p t v1 v2 var v hash var observe var v v1 v v2 assignment local ob assignment observe marginalize v current clique clique edge get pair factor iterator current clique iterator next r f unroll var clique r f unroll var next factor clique ptl graph factor clique clique ptl illegal could find clique +clique factor slice v1 clique contain v1 v2 clique contain v2 v1 v2 fast clique ptl var size 2 slice clique ptl slice clique ptl slice local ob v1 v2 slice clique ptl slice local ob v2 v1 slice clique ptl slice local ob runtime illegal cliqu eha edge variable ptl multiply slice factor local conditional ptl r f unroll var clique clique current clique r f unroll var clique r f unroll var clique size clique iterator clique iterator r f unroll graph acrf assignment observe structure type y v r l e variable iterator acrf observe structure type y e g e edge iterator acrf observe illegal argument unknown structure pseudolikelihood type +structure type maxable cache optimizable gradient serializable r f acrf instance train r f template template r f template fix tmpl bit infinite value num e f u l t g u n p r o r v r n e 10 0 get gaussian prior variance gaussian prior variance gaussian prior variance gaussian prior variance gaussian prior variance gaussian prior variance gaussian prior variance e f u l t g u n p r o r v r n e vector contain count feature observe training map clique template feature count sparse vector constraint vector contain expect value over label feature see training training label sparse vector expectation sparse vector constraint sparse vector expectation init weight instance training ugh there back into r f t know best problem maxable doesn t extend r f maxiximable can t just call init weight tidx 0 tidx template length tidx++ num + template tidx init weight training initialize constraint expectation same dimension weight zero init constraint expectation first constraint sparse vector template length expectation sparse vector template length tidx 0 tidx template length tidx++ sparse vector template tidx get weight constraint tidx sparse vector clone matrix zero expectation tidx sparse vector clone matrix zero now other constraint sparse vector template length expectation sparse vector template length tidx 0 tidx template length tidx++ r f template tmpl template tidx sparse vector weight tmpl get weight constraint tidx sparse vector weight length expectation tidx sparse vector weight length 0 weight length i++ constraint tidx sparse vector weight clone matrix zero expectation tidx sparse vector weight clone matrix zero expectation 0 they ve be initialize reset expectation tidx 0 tidx expectation length tidx++ expectation tidx 0 0 0 expectation tidx length i++ expectation tidx 0 0 maxable r f acrf instance ilist logger fine initialize optimizable r f acrf acrf template acrf get template fix tmpl acrf get fix template allocate weight constraint expectation train ilist init weight train init constraint expectation num instance train size cache value stale cache gradient stale cache unroll graph unroll graph unroll graph num instance logger info training instance + num instance logger info + num describe prior logger fine computing constraint collect constraint train describe prior logger info gaussian prior variance +gaussian prior variance get num num negate value value because weight value get buf buf length num illegal argument argument + correct dimension idx 0 tidx 0 tidx template length tidx++ r f template tmpl template tidx sparse vector tmpl get weight value get value arraycopy value 0 buf idx value length idx + value length tidx 0 tidx template length tidx++ r f template tmpl template tidx sparse vector weight tmpl get weight assn 0 assn weight length assn++ value weight assn get value arraycopy value 0 buf idx value length idx + value length internal cache value stale cache gradient stale idx 0 tidx 0 tidx template length tidx++ r f template tmpl template tidx sparse vector tmpl get weight value get value arraycopy idx value 0 value length idx + value length tidx 0 tidx template length tidx++ r f template tmpl template tidx sparse vector weight tmpl get weight assn 0 assn weight length assn++ value weight assn get value arraycopy idx value 0 value length idx + value length function unit test get constraint expectation m too lazy deep caller these sparse vector get expectation cnum expectation cnum sparse vector get constraint cnum constraint cnum print weight print buf num get buf len buf length w 0 w len w++ print buf w + compute value retval 0 0 num instance train size start current milli unroll 0 instance value nev total value we can t just sometime skip value because infinite off total value we instance infinite value happen start we t compute value instance first round instance infinite value initialize infinite value infinite value we could initialize bitset slot instance probably cheap taking hit allocate space bit become infinite value bit initialize infinite value clear statistic we about fill reset expectation fill expectation instance 0 num instance i++ instance instance train get compute marginal clique unroll start current milli r f unroll graph unroll r f unroll graph instance template fix tmpl unroll current milli unroll + unroll unroll start unroll num variable 0 happen node prune save expect value feature we compute gradient assignment observation unroll get assignment value collect expectation value unroll observation infinite value initialize infinite value logger warning instance + instance get name + infinite value skip infinite value infinite value get logger warning infinite value instance +instance get name + infinity n e g t v e n f n t y print debug info unroll illegal instance + instance get name + infinite + value now infinite value na n value na n instance +i+ +instance get name print debug info unroll illegal value na n r f get value instance +i logger warning value na n r f get value instance +i+ + infinity n e g t v e n f n t y retval + value incorporate gaussian prior weight we add w^2 2 variance log probability prior denom 2 gaussian prior variance tidx 0 tidx template length tidx++ sparse vector weight template tidx get weight j 0 j weight length j++ fnum 0 fnum weight j num location fnum++ w weight j value location fnum weight w tidx j retval + w w prior denom current milli logger info r f inference m + start logger info r f unroll m +unroll logger info get value loglikelihood +retval retval compute gradient penalize log likelihood r f place cache gradient gradient constraint expectation gaussian prior variance compute value gradient grad index into current element cache gradient gidx 0 first gradient wrt weight tidx 0 tidx template length tidx++ sparse vector these weight template tidx get weight sparse vector these constraint constraint tidx sparse vector these expectation expectation tidx j 0 j these weight num location j++ weight these weight value location j constraint these constraint value location j expectation these expectation value location j print gradient gradient +gidx+ +constraint+ ctr +expectation+ + weight gaussian prior variance + reg feature e f u l t grad gidx++ constraint expectation weight gaussian prior variance now weight tidx 0 tidx template length tidx++ r f template tmpl template tidx sparse vector weight tmpl get weight 0 weight length i++ sparse vector weight vec weight sparse vector constraint vec constraint tidx sparse vector expectation vec expectation tidx j 0 j weight vec num location j++ w weight vec value location j gradient compute below constraint constraint vec value location j expectation expectation vec value location j parameter infinity external user we gradient 0 because parameter value can nev change anyway mess up future calculation matrix infinite w logger warning infinite weight node index +i+ feature + acrf get input alphabet lookup j gradient 0 0 gradient constraint w gaussian prior variance expectation print gradient idx weight vec index location j fname acrf get input alphabet lookup idx gradient +gidx+ +constraint+ ctr +expectation+ + w gaussian prior variance + reg feature +fname+ grad gidx++ gradient feature f k compute expect value f k aver possible label sequence instance we these value store collector collector j k get expect value feature clique label assignment j input feature k collect expectation value r f unroll graph unroll assignment observation value 0 0 clique iterator clique iterator unroll observation next advance table factor ptl table factor local conditional log z ptl logsum r f unroll var clique clique assignment assn assignment observation duplicate assigment clique xxx l o w need sparsifi assignment iterator assn ptl assignment iterator assn next marginal math ptl log value assn log z ugly need map assignment single twiddle variable clique assignment assignment current assn assn assignment vi 0 vi current assn num variable vi++ variable var current assn get variable vi assn value 0 var current assn get var cidx 0 cidx clique length cidx++ r f unroll var clique clique cidx tidx clique get template index tidx 1 assn idx clique lookup assignment assn expectation tidx assn idx plus equal sparse clique get fv marginal expectation tidx location assn idx 1 expectation tidx increment value assn idx marginal assn advance value + ptl log value observation log z value collect constraint graph r f unroll graph unroll assignment observation clique iterator clique iterator unroll observation next advance r f unroll var clique clique cidx 0 cidx clique length cidx++ r f unroll var clique clique cidx tidx clique get template index tidx 0 assn idx clique lookup assignment observation constraint tidx assn idx plus equal sparse clique get fv 1 0 constraint tidx location assn idx 1 constraint tidx increment value assn idx 1 0 collect constraint instance ilist inum 0 inum ilist size inum++ logger fine collecting constraint instance +inum instance inst ilist get inum r f unroll graph unroll r f unroll graph inst template assignment assn unroll get assignment collect constraint graph unroll assn dump gradient name grad get num get value gradient grad print stream w print stream output stream name 0 num i++ w grad w close o e err could output e print stack trace dump constraint 0 constraint length i++ template +i constraint print expectation 0 expectation length i++ template +i expectation print print debug info r f unroll graph unroll acrf print err assignment assn unroll get assignment iterator unroll var iterator next r f unroll var clique r f unroll var next clique +clique dump assn clique assn clique factor ptl unroll factor clique value +ptl value assn ptl dump assn clique assignment assn r f unroll var clique iterator clique iterator next variable var variable next var+ +assn get var + +assn get var + weight w cnum j infinite w logger warning weight infinite clique +cnum+ assignment +j na n w logger warning weight nan clique +cnum+ assignment +j optimizable r f 