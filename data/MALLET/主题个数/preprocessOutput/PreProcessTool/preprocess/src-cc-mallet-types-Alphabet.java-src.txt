2002 univ dept part m l l e t m achine learning languag e toolkit 1 0 information see ` l e n e mc callum type io o io input stream io output stream io stream io output stream writer io print stream io print writer io serializable rmi dgc v m iterator concurrent concurrent hash map concurrent concurrent map concurrent lock read write lock concurrent lock reentrant read write lock mapping between mapping direction efficient assign consecutively starting zero alphabet can delete alphabet thus nev reuse p most alphabet dictionary feature name link type feature vector link type instance simple document classification usage unique word document unique entry alphabet unique feature vector rely part mapping efficiently represent subset alphabet present feature vector see feature vector see instance see pipe pipe alphabet serializable gnu trove t hash map map entry growth stop entry v m instance v m read resolve persitent instance read write lock lock reentrant read write lock alphabet capacity entry map gnu trove t hash map capacity entry capacity entry entry someone could deserialize u into image e g r m handle deserializ entry put absent instance alphabet entry 8 entry alphabet capacity capacity alphabet 8 alphabet entry entry length entry entry lookup index entry clone lock read lock lock alphabet ret alphabet ret map gnu trove t hash map map clone ret entry entry clone ret growth stop growth stop ret entry entry ret lock read lock unlock 1 entry isn t present lookup index entry add present entry illegal argument can t lookup \ null\ alphabet entry entry entry get insist entry alphabet same strictly bunch easily entry get entry illegal argument match entry + entry get + + entry lock read lock lock map contain key entry map get entry lock read lock unlock growth stop add present lock write lock lock ret index entry size map put entry ret index entry add entry ret index lock write lock unlock 1 lookup index entry lookup index entry lookup index lock read lock lock entry get index lock read lock unlock lock read lock lock entry lock read lock unlock contain entry alphabet runtime type runtime type large enough hold everyth alphabet entry tt obj tt tt ret lookup index obj obj tt lock read lock lock entry lock read lock unlock xxx disable iterator thread safety probably size lookup instead iterator iterator lock read lock lock add entry iterator lock read lock unlock lookup index lock read lock lock ret index length 0 index length i++ ret entry get index ret lock read lock unlock correspond index index look up buf store value alphabet runtime type same buf lookup index buf lock read lock lock 0 index length i++ buf entry get index buf lock read lock unlock lookup index add present ret length 0 length i++ ret lookup index add present ret contain entry lock read lock lock map contain entry lock read lock unlock size lock read lock lock entry size lock read lock unlock stop growth growth stop start growth growth stop growth stop growth stop entry entry representation alphabet entry separate newline lock read lock lock buffer sb buffer 0 entry size i++ sb append entry get sb append sb lock read lock unlock dump dump dump print stream dump print writer output stream writer dump print writer lock read lock lock 0 entry size i++ + + entry get lock read lock unlock convenience can often implement alphabet match implement alphabet carry alphabet match alphabet carry object1 alphabet carry object2 alphabet a1 object1 get alphabet alphabet a2 object2 get alphabet a1 length a2 length 0 a1 length i++ a1 a2 a1 || a2 isn t a1 equal a2 v m get instance instance debug instance v m instance serialization serial u 1 u r r e n t e r l v e r o n 1 write output stream o lock read lock lock write u r r e n t e r l v e r o n write entry size 0 entry size i++ write entry get write growth stop write entry write instance lock read lock unlock read input stream o found lock reentrant read write lock lock write lock lock read size read entry size map gnu trove t hash map size 0 size i++ o read map put o entry add o growth stop read entry read 0 instance 1 instance v m read lock write lock unlock concurrent map v m deserializ entry concurrent hash map v m get call read let decide previously read we hash map instance determine we already read stream read resolve stream previou deserializ entry get instance previou alphabet read resolve resolving previou instance instance + instance previou instance prev deserializ entry put absent instance prev prev alphabet read resolve instance instance + instance 