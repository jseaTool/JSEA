2002 univ dept part m l l e t m achine learning languag e toolkit 1 0 information see ` l e n e pipe concurrent concurrent hash map concurrent concurrent map logging iterator io rmi dgc v m type alphabet type alphabet carry type instance type single instance iterator logger superclass pipe transform type another pipe most often feature extraction p pipe pipe subclass you override link pipe link iterator former appropriate pipe processing instance strictly instance coming there exactly instance coming late appropriate pipe processing few instance arrive iterator p pipe operate link type instance carrier pipe read write field instance request process instance up pipe field instance read write usually pipe read input write output instance p pipe doesn t notion input output merely modifie instance hand helper implement link iterator instance iterate over commonly encounter input structure feed element these structure pipe instance p pipe frequently link type instance instance they process pipe instance process instance keep p usage link pipe iterator iterator directory operate over iterator walk directory create instance putting instance directory store target instance iterator feed instance instance process instance pipe keep result p pipe can hierachically compose typical usage serial pipe create hold pipe order piping instance serial pipe piping instance child pipe p pipe hold two alphabet symbol feature name encounter field instance process pipe symbol e g label encounter target field p mc callum pipe serializable alphabet carry logger logger logger get logger pipe get name alphabet alphabet alphabet target alphabet alphabet resolve target alphabet resolve target processing v m instance v m read resolve distinguish persistent instance construct pipe target dictionary pipe construct pipe target dictionary note since value dict target dict you specify argument here pipe step ev correspond dictionary argument dict alphabet dictionary target dict alphabet target dictionary pipe alphabet dict alphabet target dict alphabet dict target alphabet target dict instance process test instance pass processing pipe usage override anonymou inner sub pipe serial pipe sp serial pipe pipe sequence2 precondition instance inst inst sequence2 feature t o o precondition doesn t seem best name because we t fail we pas thru consider alternative skip pas thru skip predicate t o o actually we really want multiple different drop instance go next pas unchang current precondition instance inst t o o really isn t historical reason really isn t historical reason instance pipe instance inst unsupport operation pipe +thi get get name + guarantee mapping instance iterator instead t o o consider naming simply iterator instance iterator instance iterator instance also be process pipe you override sure check obey pipe link skip instance iterator instance iterator iterator instance simple pipe instance iterator convenience pull instance pipe result instance instance iterator instance iterator next instance 0 instance inst next next instance inst instance ret instance ret add inst next ret add next instance ret instance instance instance inst instance single instance iterator inst t o o we really want encourage behavior this? consider remove properly pipe instance instance instance inst instance result instance inst result length 0 result 0 input take target instance dur processing argument t expect find input target target processing look process target target processing look process target iff pipe expect process information tt target tt slot target processing target processing pipe produce alphabet dictionary pipe doesn t alphabet passing dictionary call until dictionary really because off chain event resolve dictionary entire pipeline generally resolution take place until pipeline completely place pipe being call xxx perhap desire wait until pipe being call unrealistic unnecessary alphabet get alphabet alphabet alphabet get target alphabet target alphabet alphabet get alphabet get alphabet alphabet get alphabet alphabet get alphabet get target alphabet alphabet match alphabet carry alphabet oas get alphabet oas length 2 oas 0 equal get alphabet oas 1 equal get target alphabet alphabet alphabet dict alphabet alphabet size 0 illegal can t pipe alphabet already alphabet dict alphabet alphabet alphabet size 0 check alphabet alphabet alphabet alphabet alphabet equal illegal alphabet match target alphabet alphabet t dict target alphabet illegal can t pipe target alphabet already target alphabet t dict check target alphabet alphabet target alphabet target alphabet target alphabet equal illegal target alphabet match preceed pipe alphabet notification alphabet alphabet alphabet preceed pipe target alphabet notification alphabet target alphabet target alphabet v m get instance instance debug instance iterator implement pipe behavior simple pipe instance iterator iterator instance iterator instance simple pipe instance iterator iterator instance next next instance next instance input next precondition input input pipe input link pipe process link instance going iterator pipe get pipe iterator instance get iterator illegal support serialization serial u 1 u r r e n t e r l v e r o n 0 write output stream o write u r r e n t e r l v e r o n write alphabet write target alphabet write alphabet resolve write target alphabet resolve write target processing write instance read input stream o found read alphabet alphabet read target alphabet alphabet read alphabet resolve read target alphabet resolve read target processing read instance v m read concurrent map v m deserializ entry concurrent hash map v m get call read let decide previously read we hash map instance determine we already read stream read resolve stream pipe read resolve instance + instance previou deserializ entry get instance previou pipe read resolve resolving previou instance instance + instance previou instance prev deserializ entry put absent instance prev prev pipe read resolve instance instance + instance 